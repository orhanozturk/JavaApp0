15.11.2022

Java Eğitimi

Java Ders programı
Salı - Perşembe
Saat: 19:00 - 22:00


github'ta ders notları yedeklenecek.


1- Java Genel giriş 
2- Java özellikleri
3- Genel programlama pradigmaları
4- Sayı sistemleri
5- Bir java programı text sayafasına yazıp derleyip çalıştıracaz


HW1
-Assembly nedir neden var neden kullanımda hala?
-Unity ve Unreal Engine nedir ve diger oyun motorlarına inceleyelim.
-Interpereted programlama dili nedir?
-Garbage Collector Nedir nasıl çalışır?
-Memory leak
-Functional Programming, Prosedürel Programlama, Object Oriented Programming,
    Generic Programming, Imperative programming, Reflective programming, Concurrent
-Java programı derleme ve çalıştırma adımları
    JVM nedir 
    JRE nedir 
    JIT nedir 
    Byte code nedir 

    Bunlar hangi aşamalardan geçerken kullanılıyor?



ali olustur 
..
..

ali silindi progaramcı silmesin ben silerim G.C devereye giriyor 

C ve C++ da Garbage C. mekanizması yoktur. Programcı kendi siler kendi olsuturdugu nesneyi.


Programlama Dillerinin Sınıflandırılması

Programlama dillerini 3(üç) biçimde sınıflandırabiliriz:
1. Seviyelerine göre sınıflandırma

2. Kullanım alanlarına göre sınıflandırma

3. Programlama modeline göre sınıflandırma



Java programı derleme ve çalıştırma adımları





--------------------------------------------------------

HW2 

Stack ve Heap Nedir ?
Donanımsal karsılıkları?

Fonksiyonel programlama ile prosüdürel programlama arasındaki fark?
Imperative Programing?
Reflective programing?
Concurrent programing? 


--------------------------------------------------------
22.11.2022


HW3 
Github reopsu olusturmak kendi java norları için
Github'a kendini anlatan bilgi veren sade bir Overwiev olustur.
Google documentler den slaytları hazırlayalım

--------------------------------------------------------
/*******************************************************/
/*******************************************************/


Sayı Sistemleri 


2-8-10-16 temelde bu sayı sistemleri var 


2 lik sayı sistemi 

Neden kullanırız: tam sayı ve gerçek sayı sistemleri için kullanırız

4 66 76  -- 123,4 555.7


0101 1011 0001 1110 

ikilik  sayı sistemi işaretli ve işaretsiz olmak üzer iki gruba ayrılır 

işaretsiz - unsigned --> sayının pozitif oldgunu söyleer
işaretli -- signed ---> sayıların hem pozitif hem negatif olabiliceğini söyler 


Sistemlerin hemen hepsinde 

8 bitlik alana byte denilmektedir.

bit bit bit bit bit bit bit  bit
1   0   1    0   1   1   0   0  === byte 

bit = binary digit 
Byte = 8bit

Sistem programlamada daha küöçük birimler var 

4 bit = Nibble = yarım byte
8 bit = byte 
2 byte = word
4 byte = double word


Sayı sistemlerinde bazı işlemler

2'ye tümleyeni bulma konusu için pratik kurallar 

	0101  0100
	1010	 1100

sagdan baslayarak ilk 1 bitini gorene kadar 
bitlerin aynısını yazıyoruz
geri kalan kısmı ters ceviriyoruz
	

	0001  1000
     1110  1000    

---------------------
işaretli 2 lik sistem

sign bit --> sayının işaretni belirler
0 --> pozitif sayı
1 --> negatif sayı


işaretli sayı sistemlerinde 
Sistemlerin hemen hepsi negatif sayıyı gösterimi için
Sayının 2'ye tümleyini aritmatigi kullanır

aynı sayıınn pozitif ve negatif degerleri
sayının 2 ye tümlenyenleri

45
-45 gibi 

1110 1001 = -23
2^0 * 1 + 2^1 * 0 + 2^2 * 0 + 2^3 * 1 + 2^4 * 0 + 2^5 * 1 + + 2^6 * 1 + 2^7 * 1
0001 0111 = 23


Soru :  bir byte lık alanda -52 sayısını ifade edermisin

önce 52 degerinin bitlerini buluruz sonrada 2'ye tümelyeni buluruz. Eksili sayının 2 bitlik ifadesini 

0011 0100 = 52
1100 1100 = -52


---------------------------------------------
temel byte alanlarında yazılabilecek en buyuk ve en kucuk degerler 

unsigned sistemde

0  - 255
0  - 65535
0  - .....


signed sistemlerde

0111 1111 -- > 127 en buyuk tam sayı degeri 
1000 0001 ---> -127 - 1 = 128 en kucuk tam sayı degeri elde edilir 
1000 0000 --> -128


-128 127
-32768 - 32767
-2147483648  - 2147483647 

--------------------------------------------------------------

Soru: İşaretli 2 lik sayı sisteminde butun bitleri 1 olan sayı nedir

1111 1111 = -128 + 127 = -1
0000 0001 = 1 


--------------------------------------------------------------

16 LIK sayı sistemi 

hexadecimal sistem 
hex system denir 

16 tane sembol var

0123456789ABCDEF


Neden hex sistemi bizi ilgilendirir

aslında 2 lık sayı sisteminde 5 bitlik alanı tekbir yerde gosterebiliriz
ayrıca 16 lık sistem 2 nın katı olması işimizi kolaylaştırır



Soru: 2lık sayı sistemini 16 lık sayı sistemine cevirelim

1001  1110 1001 1111
  9    E    9    F

Soru:  1AC  onluk sayı sistemine donusturelim

1*16^2 + 10 * 16^1 + 12 * 16^0  = 256 + 160 + 12 = .....


-----------------------------------------------------------

Önce java gereksinimleri yuklenmeli işletim sistemine göre

Sonra 
Java ayarlarımızı consol'dan incelemeliyiz aynı versiyon olmalı  

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>java -version
java version "17.0.1" 2021-10-19 LTS
Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39)
Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing)

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>javac -version
javac 17.0.1

-----------------------------------------------------------


Dil kavramı nedir?

Dil iletiişmde kullanılan semboller toplulugudur. Bir dilin kurallarına gramer denir.
Gramerin bir çok alanı vardır. En önemlileri "sentaks (syntax) " ve "semantik (semantic" dir.
Bir cümlenin olabilmesi için en azından sentaks ve semantiğe sahip olması gerekir.


Sentaks doğru yazma ve dogru dizilime ilişkin kurallardır.

		"I going to will fitness."

Java ornegi 

		System.out.println("Hello, World)";


Semantik: Dildeki dogru dizilmiş ögelerin ne anlama ifade ettiketlerine ilişkin kurallara da semantik denir.


Dipnot:
Bilgisayar Dilleri ve Programlama Dilleri: Bilgisayar bilimlerinde kullanılmak üzere tasarlanmış
dillere bilgisayar dilleri (computer langues) denir. Bir bilgisayar dilinde akış da varsa o zaman programalam dili
(programmin language) denir. Örnek: HTML, XML gibi bilgisayar dilleridir, programlama dili değildir.
C, C++, Java, C#, Swift..... gibi dillerde akış oldugunda programlama dilleridir. 


-----------------------------------------------------------

Hello World Program


package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
    }
}


komutlar

-> javac orhn/App.java

-> java orhn.App


-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

29.11.2022 Salı

Derleyici hata mesajları (diagnostics):

1. Gerçek hatalar (Error): Dilin sentaks ve semantik kurallarına uyulmamasından dolayı verilen mesajlardır.
	Bu durumda arakod(Byte code) üretilmez.

2. Uyarılar (warning): Byte kodun üretimine engel olmayan, olası programlama ve mantık hatalarının programcıya
	bildirilmesi içien verilen mesajlardır. Programcı bu uyarıları mutlaka dikkate almalıdır. Özel bir durum yoksa 
	uyarı mesajlarının oluşumuna yol açan kodlar düzeltilmelidir. Bazı duurmlarda derleyicinin uyarı mesajı verdiği ancak IDE'nin kullanıldıgı
	bir "static kod analizi araçları" konfigürasyonları gereği uyarı verebilirler. Şüphesiz bunlarda da dikkate alınmalıdır. Ancak bunların
	hepsi düzeltilmesi gerekmez.


3. Ölümcül hatalar (fatal errors): Derleme işleminin bile tamamlanmasını engelleyebilecek hatalardır. Bu durumda
	programcının yazdıgı kod açısından yapacak bir şeyi yoktur. Çünkü kod henüz derlememiştir. Programcının ölümcül hataya
	yol açan durumu ortadan kaldırmsı gerekir. Örneğin diskte yer kalmaması, derlenecek dosyanın bulunamaması gibi durumlar ölümcül hatalara örnek gösterilebilir.


Programın çalışma zamanı sırasında oluşan hatalara genel olarak "exception" denir. Exception oluştugunda program sonlanır. 
Bu durum detayları "exception işlemleri(exception handling)" konusunda ele alınacaktır. Excepiton yerine "run time error" da kullanılabilrmektedir. 
"error" denildiginde "compile time error" anlaşılır.
  

-----------------------------------------------------------

Java'da yorum satırları (comment lines)


Not: Yorum satırları kodun okunabilirliğini/algılanabilirliğini bozacak şekilde koda eklenmemelidir
	Yorum satırı eklemenin de bir "convetion"'u olmadır.

package orhn;

class App{

    //Burası derleyici tarafından dikkate alınmaz.
    public static void main(String[] args) {
        System.out.println("Hello, World");    

        /*
            Burası da 
            derleyici
            tarafından 
            dikkate alınmaz 
         */
    }
}

-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Atom (Token):
Bir programlama dilinde kendi başına anlamlı olan en küçük birime atom denir. Atomlar 6 gruba ayrılır.

1. Anahtar Sözcükler(keywords, reserved words): Dil için özel bir anlamı olan yeni dil tarafın bilinen ve 
	birçoğu doğrudan değişken ismi olarak kullanılamayan atomlardır. Örneğin: package, class, public, int, if, while vs.

2. Değişkenler (identifiers, variables): İsmini programcının belirlediği ve çeşitli kurallara göre isminin berlirlenebildiği atomlardır.
	Örneğin: App, String, System, orhn vs...

3. Operatörler (Operators): Bir işleme yol açan ve bu işlem sonucunda bir değer üreten atomlardır.
	Örneğin: a + b ifadesinde + bir operatordür

4. Sabitler (Literals, constants): Program içerisine doğrudan yazılan sayılara denir. Örneğin: a - 5 ifadesinde
	5 bir sabittir. 

5. String'ler (Strings, String Literals): iki tırnak (double quote) içersinde bulunan yazılar tırnaklarla birlikte string atomudur.
	Bu atoma string sabiti anlamında "string literal" da denir. Örneğin: "Hello, World"

6. Ayraçlar (delimiters, punctuators): Yukarıdaki gruplar dışında kaln tüm atomlara denir. Örneğin: {}, (), [] vs.

-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Programı atomlarına parçalayalım


package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
    }
}

package 		->  anahtar sözcük
orhn			-> değişken
class		-> anahtar sözcük
App			-> değişken
{}			-> ayraç
public		-> anahtar sözcük
static		-> anahtar sözcük
void 		-> anahtar sözcük
main			-> metod ismi değişken
()			-> ayıraç
String		-> değişken
[]			-> ayıraç 
args			-> değişken
{}			-> ayıraç
System		-> değişken
.			-> operator
out			-> değişken
println		-> değişken
()			-> metod çagırma operatoru
"Hello, World" -> String literals
;			-> Ayıraç


-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Boşluk karakterleri (whitespaces): Klavyeden basılıgında bosluk algısı veren karakterlerdir.
	Klavyeden basılan bosluk karakterleri tipik olarak sunlardır: space, tab, enter 

-----------------------------------------------------------
-----------------------------------------------------------

	Java programlama dilinde kod yazım kuralları şunlardır:
	1. Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.
	2. Anahtar sözcükler ve değişkenler dışında kalan atomlar istenildiği kadar bitişik yazılabilir. 
		Anahtar sözcükler ve değişken atomlar arasında en az bir boşluk (whitespace) karateri olmalıdır.


-----------------------------------------------------------
-----------------------------------------------------------

Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.


package 



orhn;

class 







App{

    public static void main(String[


    ] 
    
    args) 
    
    {
        System.             out.            println("Hello, World");    

    }
}


-----------------------------------------------------------
-----------------------------------------------------------

2. Anahtar sözcükler ve değişkenler dışında kalan atomlar istenildiği kadar bitişik yazılabilir. 
		


package orhn;class App{public static void main(String[]args){System.out.println("Hello, World");}}


-----------------------------------------------------------
-----------------------------------------------------------

Anahtar sözcükler ve değişken atomlar arasında en az bir boşluk (whitespace) karateri olmalıdır.

package orhn;class App{publicstatic void main(String[]args){System.out.println("Hello, World");}}


-----------------------------------------------------------
-----------------------------------------------------------

Not: Java'da derleme zamanı (compile time) ve çalışma zamanı (run time) denilen birbiriyle ilişkili
	ancak ayrı olan iki kavram vardır. Derleme zamanı derleme sürecinde yapılan işlemlere denir. 
	Çalışma zamanı programın çalışma sürecinde yapılan işlemlere denir.

-----------------------------------------------------------
-----------------------------------------------------------

Bildirim (declaration): Bildirim bir ismin derleyiciye tanıtılmasıdır. 
				    Derleyici bildirim ile o ismin ne anlama deldiğini anlar ve derleme işlemini ona göre yapar.


-----------------------------------------------------------
-----------------------------------------------------------

Bir java programı genel olarak paketlerden, paketler sınıflardan, sınıflarda metodlardan oluşur.

package <isim>;
Örnek:
package orhn;


class <isim> {


}

Örnek:

class Sample{
	//...
}


class Mample{
	//...
}





-----------------------------------------------------------
-----------------------------------------------------------
Metod bildirimlerin genel biçimi:

Java'da alt programlara metot (method) denir. Alt programın ne yapacağının yazılmasına "metot bildirimi (metot declaration)" denir.
Alt programın kodlarının çalıştırılmasına ise "metot çağırma (method call)" denir. Metot bildirimini genel biçimi:

[erişim belirleyici] [static/non-static] <geri dönüş değeri bilgisi> <metot ismi>([parametreler])
{
	//...
	//...

}

Açıklamalar:

-Erişim belirlemeleri şunlardan biri olabilir: public, protected, private, no-modifier(hiçbir şey yazılmaması)
	Metotların erişim berlirleyicileri konusuna gelene kadar tüm metodları public olarak bildirecez.

- Bir metot static veya non-static olabilir. static anahtar sözcüğü bildirimde yazılmasa metot non-static olur.
	non-static metotlara ilişkin konuya gelene kadar tüm metotları static olarak bildirecez.

- Metodun geri dönüş değeri bilgisi metot isminden önce yazılmalıdır. Metodun geri dönüş değerinin olmaması durumuda
	void yazılması demektir. Geri dönüş degerı kavramı da ileride ele alınacaktır.
- Metodun ismi bir değişken atomdur. Tğm değişken atomlarda oldugu gibi "değişken isimlendirme kuralları"na uygun 
	olarak isimlendirilmelidir.
-Metot bildirimlerinde motot isminden sonra parantezler içerisinde ismine "parametre (parameter)" deniken değişkenler bildirilebilir.
	Metot parametre değişkenleri ileride ele alınacaktır.
- Metot bildiriminde küme paratezleri arasında (metot gövdesi) metodun kodları yazılır 


static bir metodun çağrılmasının genel biçimi:

[paket ismi].[sınıf ismi].<metot ismi>([argümanlar]);


Bir program main metodunun çağrılmasıyla çalışmaya başlar. Programcının main metodu içerisinde çağırdığı motolar ve o metotların içerisinde çağrılan motolarla
akış devam eder. main metodu JVM tarafından çağrılır. Bu anlamda java programına verilen "byte code"'a ilişkin sınıfın main metoduna "giriş noktası (entry point)"
denir. Özel bazı özel durumlar dışında (bu özel durumlar vardı - extrem konularda karsımıza cıkar) main metodu sonlandıgında program sonlanır.
Bir metot çağrıldıgında akış metodun kodlarına dallanır (call) ve metodun kodları çalıştırılır. Şüphesiz metot içerisinde başka bir metot çağrılıyor olabilir.
Yine bu çapırma n0oktasında akıl metodun kodlarına dallanır. Metot çağrısı sonlandıgında akış metodun çağrıldıgı noktaya geri döner ve bir sonraki koddan akış 
çalışmaya devam eder.

Not: System.out.println("Hello World"); çağrısında System bir sınıf, out bir referans ve println de non-static bir metotdur.
	Bu kavramları ileride ele alacagız.

-----------------------------------------------------------
-----------------------------------------------------------

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        orhn.Sample.foo();
        orhn.Sample.bar();
        orhn.Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        orhn.Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}


-----------------------------------------------------------
-----------------------------------------------------------

Çağıran metodun (caller) ait oldugu sınıf ile çağıran metot (callee) ait oldugu sınıf 
aynı paket içerisindeyse çağırma sırasında paket ismi yazılmayabilir

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        Sample.foo();
        Sample.bar();
        Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}
-----------------------------------------------------------
-----------------------------------------------------------
Çağıran metot ile çağrılan metot aynı sınfta ise bu durumda çağırma sırasında paket ismi yazılmamışsa sınıf 
ismide yazılmayabilir.

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        Sample.foo();
        Sample.bar();
        Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
        foo();
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}


-----------------------------------------------------------
-----------------------------------------------------------
01.12.2022 Perşembe

IDE (Integrated Development Environment): Derleyiciler komut satırından çalıştırlabilen basit bir arayüze sahip
programlardır. Aslında teorik olarak java ile geliştirilecek bir uygulma içerisinde tüm java dosyları "notepad"
basit bir editor ile yazılıp, komut satırından derlenebilir. Fakat pratikte bu şekilde program yazman fazlaca 
zaman kaybettirir. Yazılım geliştirmeyi kolaylaştırmak için IDE debilen programlar kullanılır.
IDE'ler içerisinde editorler, test araçları, çeşitli kodlar üreten araçlar vs. bulunur. IDE bir derleyici değildir.
IDE derleme işlemi için derleyiciyi de çalıştırabilir. Uygulamayı çalıştırma işlemi için de yineJRE içerisindeki araçları 
kullanabilir. Java ile uygulma geliştirirken kullanılabilecek çeşitli IDE'ler bulunmaktadır. Bunlardan en yaygın 
kullanılanları "Eclipse" ve "IntelliJ IDEA" IDE'leridir. Önceleri Netbeans isminde bir IDE kullanılmaktaydı. 
Ancak Netbeans kullanımı oldukça azalmıştır.

-----------------------------------------------------------
-----------------------------------------------------------
Tür (type): Bir değişken için bellekte kaç byte ayrılacağını ve içerisindeki hangi
yöntemle veri tutulacagını belirten kavramdır.

Java'da türler genel olarak iki gruba ayrılabilir.
Temel türler (primitive/built*in/predefined types).
Programcının tanımladığı türler (user defined types).


Temel türler

Tür ismi			Uzunluğu(byte)
short				2
int					4
long				8
byte				1                           0 0 0 0  0 1 0 1  --> 5    ------- -128/127

float				4
double				8

char				2
boolean				-


-Java da türlerin uzunlukları boolean türü dışında sistemden sisteme değişmez.

-Tüm tam sayı türleri işaretlidir(signed)

-Tamsayı türleri (integer/integral types) için ikiye tümleme yöntemi kullanılır. Java'da işaretsiz tam sayı türleri yoktur.
Ancak java 8 ile birlikte belirli koşullar altında işaretsiz tamsayı işlemleri yapılabilmektedir.

-long türü en uzun tamsayı türüdür.

-Gerçek sayı(real/floating point types) için "IEEE 754 standardı" kullanılır. float ve double türleri sırasıyla
tek hassasiyetli (single precision) ve çift hassasiyetli (double precision) değerleri tutmaktadır. Bu türlerde bazı sayılar
tam olarak ifade edilemezler 0 sayıya yakın bir sayı ile ifade edilebilirler. Bir noktalı sayının ifade edilemeyip en yakın
sayı olarak ifade edilmesine yuvarlama hatası (rounding error) denir. Yuvarlama hataları değer ilk kez yerleştirilirken
de oluşabilir, bir işemin sonucunda da oluşabilir.


-Gerçek sayı türleri işaretli türlerdir.

-float türünün yuvarlama hatalarına karşı direnci zayıfır. Yanı yuvarlama hatası daha çok olmaktadır.

-Yuvarlama hataları parasal ve finansal uygulamarda hatalı değerlerin oluşmasına sebep olabilir. Sırf parasal
ve finansal uygulamalar için tasarlanmış özel türler (sınıflar) bulunur. Programcı böylesi uygulamalar için bu sınıfı
tercih eder. Ancak bu sınıflar yuvarlama hatası yapmamak için yüzlerce makine komutu ile bu işlemleri yapar.
Bu durumda programcı için parasal ve finansal uygulamalar gibi yuvarlama hatasının olmaması gerekn uygulamalar dışında double
yada durma göre float türü tercih edilmelidir.


-char türü Java'da UNICODE tablo dikkate alınarak belirlenmiştir. Bu nedenle char türü 2 byte'dır. char türünden 
değişken içerisinde bir karakterin UNICODE tablosu (ya da başka tablodaki) sıra numarası tutulur. UNICODE tablo
dünyadaki dillerde kullanılan hemen hemen tüm karakterleri ve bazı özel karakterleri ifade edebilme yeteneğine sahiptir.


-Yazılar içerisinde her bir karakter aslında bir sayı ile temsil edilir. Hangi karakterin hangi sayı ile ifade edildiği
karater tablosuna bağlıdır. ASCII tablosu 1 byte'lık yani 256 tane satırdan oluşur. UNICODE tablo 2 byte'lık
yani 65536 satırdan oluşan bir tablodur. Karakter tablolları bunlarla sınırlı değildir.


-boolean türünün alabileceği iki tane değer vardır: true, false. boolean türünün uzunluğu "Java Language Specification"'da
belirtilememiştir. Sistemden sisteme değişebilir. Ancak bu değişim programcı açısından problem oluşturmaz.

Not: int türüne "integer" demek yanlış bir terim kullanamk demektir. integer terimi tamsayılar için
kullanılan genel bir terimdir. Ayrıca "Integer" isimli bir sınıf da bulunmaktadır.

Not: Java'da en çok kullanılan tamsayı türü int türüdür. en çok kullanılan gerçek sayı türü de double türüdür.
Programcı öncelikle bu türleri tercih etmelidir. Eğer geçerli bir nedeni varsa diğer türleri kullanabilir.

-----------------------------------------------------------
-----------------------------------------------------------
HW3

IEEE 754 standardı nedir? 
Gerçek sayılar bu standarda göre nasıl ifade edilir?

1344.3454 ---> bunun sistemde nasıl ifade edildiği 
		   veya javada nasıl ifade edildiğini ögrenecez


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki yuvarlama hatası örneği inceleyelim.  
 * İleride detaylı olarak ele alınacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 0.1, b = 0.2;
		double c;
		
		c = a + b;
		
		if(c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
		
		System.out.printf("a = %.20f\n", a);
		System.out.printf("b = %.20f\n", b);
		System.out.printf("c = %.20f\n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki yuvarlama hatası örneği inceleyelim.  
 * İleride detaylı olarak ele alınacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 0.1F, b = 0.2F;
		float c;
		
		c = a + b;
		
		if(c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
		
		System.out.printf("a = %.20f\n", a);
		System.out.printf("b = %.20f\n", b);
		System.out.printf("c = %.20f\n", c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
Bir değişken kullanılmadan önce bildirilmelidir:
Değişken bildiriminin genel biçimi:
<tür> <değişken ismi>;

örnek:

int a;
float b;
boolean c;

-----------------------------------------------------------
-----------------------------------------------------------
Java'da 3 çeşit değişken vardır:
1. Yerel değişkenler (local variables)
2. Parametre değişkenleri (Parameter variables)
3. Sınıf veri elemanları (class member variables)


Değişkenler için temel kavramlar:
İsim(name): Belli kurallara göre yazılan karakterler topluluğudur.

Tür (type): Değişken için bellekte ne kadar yer ayrılacağı ve içerisinde değerlerin hangi yönteme göre tutulacağını belirtir.

Faaliyet alanı (scope): Bir değişken isminin derleyici tarafından görülebildiği kod aralığıdır. Derleme zamanına işilkindir.

Ömür (storage duration): Bir değişkenin bellekte kalma süresidir. Çalışma zamanına ilişkindir.

Temel bazı kavramlar:
Blok (block): Bir metot içerisinde { ile } arasında kalan kod bölümüdür. Metodun gövdesi de bir bloktur.

İlkdeğer verme (initialization): Bir değişkene bildirim noktasında verieln değer denir. 

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Bir metot içerisinde istenildiği kadar ayrı veya iç içe bloklar olabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		{
			//...
			
			{
				//..
			}
		}
		
		{
			//...
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Bir blok içerisinde herhangi bir yerde bildirilen değişkenlere yerel değişkenler (local variables) denir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		{
			//...
			
			{
				double b;
				int c;
				//..
			}
		}
		
		{
			float d;
			//...
		}
	}
}

class Sample{
	public static void foo()
	{
		int x;
		
		//..
		{
			//..
			boolean f;
			//..
		}
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aynı türden yerel değişkenler aralarında virgül konarak bildirilebilirler
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		double x, y, z;
	}
}

class Sample{
	public static void foo()
	{
		int x, y, z;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Yerel değişkenlere ilkdeğer verme
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //ilk deger verme
		double pi = 3.14; //ilk degerveme sentaksı
	}
}

class Sample{
	public static void foo()
	{
		int x = 10, y = 30, z;
		
		z = 33;//initizlization değil.... 
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Yerel bir değikenin faaliyet alanı bildirildği yerden bildirilği bloğun sonuna kadardır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		{
			int x;
			
			x = 20;
			
			//..
			
			{
				x = 45;
			}
		}
		
		x = 15; //error
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		int a;
		double a; //error
		//..
	}
	
	public static void bar() 
	{
		int a;
		
		{
			double a; //error
			//..
			
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Farklı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçerlidir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		{
			int x = 10;
			//..
		}
		
		{
			int x = 20;
			//..
		}
		
		int x = 30;
		
		//..
	}	
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java'da değer verilmemiş hiçbir değiken kullanılamaz. Yani içerisindeki değer işleme sokulamaz
 * Yerel değişkenlere değer verilmesi programcının sorumluluğundadır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		int b;
		
		b = a * 2; //error
		
	}
}

class Sample{
	public static void foo()
	{
	}	
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * print ve println metotları değişkenlerin içerisindeki değerleri ekrana basarlar
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		System.out.print(a); //ekrana yazdırır
		System.out.println(a); //--> print("") sonrada alt satıra geçiririm 
		
	}
}

class Sample{
	public static void foo()
	{
	}	
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimleri sayısal bir karakter ile başlamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int 1number; //error
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimleri herhangi bir uygun karakter ile başlatılıp istenildği kadar sayısal karater içerebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a12345 = 10; 
		
		System.out.println(a12345);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimlendirmede UNICODE alfabetik karakterler kullanabiliir. Örneğin türkçe karakter geçerlidir ,
 * 
 * Not: Her ne kadar değişken isimlendirmede UNICODE karakterler kullanılabildse de programlamada yalnızca
 * İngilizce alfabetik 26 karakterin kullanılması iyi bir tekniktir. Biz de bu "convention"' a uygun kodlar yazacağız.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int öğrencisayısı = 10; 
		
		System.out.println(öğrencisayısı);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimlendirmede boşluk (whitespace) karakterleri geçersizdir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int number Of Students = 10; 
		
		System.out.println(number Of Students);
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimleri büyük-küçük harf duyarlıdır (case-sensitive)
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int val, Val, VaL, VAL; //geçerli  
		
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimlendirmede  _(underscore/ alttire) karakteri kullamabilir. Hatta değişken ismi _ karateri ile başalatılabilir.
 *
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int _11 = 20;
		int _val = 22;
		int number_of_students = 11;
		
		System.out.println(_11);
		System.out.println(_val);
		System.out.println(number_of_students);
		
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java 9 ile birlikte alttire karaterinin tek başına değişken ismi olarak kullanıması geçersizdir. 
 * Java 8 ile birlikte "deprecated" olmuştur.
 * 
 * 
 * Not: Programlamda "artık kullanılması tavsiye edilmeyen" durumlar için "deprecated" terimi kullanılır.
 * Bu durum gerekçeleri farklı farklı olabilir. Programcı açısından genel olarak "deprecated" olan bir durum özel bir takım
 * nedenler yoksa tercih edilmemelidir.
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		int _ = 10; //error
		
		System.out.println(_);
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java'da değişken isimlendirme $ karakteri kullanılabilir. Hatta isimler $ karakteri ile başlayabilir. $ karakteri
 * tek başına değişken ismi olabilir. Ancak programcı açısından değişken isimlendire $ karakteri kullanılmamalıdır.
 * Derleyici ismini kendisinin belirlediği durumlarda isimlendirmede bu karateri kullanır. $ karakteri bu anlamada
 * programcı tarafından kullanılırsa iism çakışması olabilir. Zaten $ karaterinin varlık sabebi de bu
 * tip kod üretimlerinde kulllanılmasıdır.
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		int amountOf$s = 1000;
		int $ = 35;
		double $123 = 123;
		
		System.out.println(amountOf$s);
		System.out.println($);
		System.out.println($123);
		
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Anahatar sözcükler tek başına değişken ismi olarak kullanılamaz. Ancak Java'ya daha sonra eklenmiş yerine göre
 * anahtar sözcük biçiminde kullanılan bazı atomlar vardır. Bu tarz eklenen sözcükler tam anlamıyla anahtar sözcük değildir.
 * Kullanıldığı yere göre değişken ismi olup olmadığı derleyici tarafından tespit edilir (inference, deduction). 
 * Bu tarz sözcüklere programlamada "bağlamsal anahtar sözcük (contextual keywords") de denir.
 
 
 	Not: Değişken isimlerinin kolay telaffuz edilebilir, anlamlı ve yeterince uzunlukta olması gerekir.
 	
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		//int double; //error
		//double package; //error
		
		var a = 10;
		
		int var = 20;
		
		System.out.println(var);
		System.out.println(a);
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

06.12.2022 Salı


/*
 * Macar notasyonu
 * Camel case(lower camel case): numberOfCase
 * Pascal Case(upper camel case): SerialPort
 * snake case (unix style): number_of_students
 * 
 * 
 * Java coding style 
 * 
 */
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Not: Klavyeden temel türden degerler okuma yöntemlerinin tam anlamı ileride detaylı olarak ele
 * alınacak. Bu sebeple bunları bir kalıp olarak görüp yalnıca kalyeden okuma kısmı ile ilgilenecez.
 * 
 * 
 * Klavyeden int türden değer okunması kalıbı
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int result = val * val;
		
		System.out.println(result);
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden int türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a * b;
		
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 
 * Klaveyden double türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		
		
		double result = a * b;
		
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden long türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		long a = Long.parseLong(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		long b = Long.parseLong(kb.nextLine());
		
		
		long result = a * b;
		
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden float türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		float a = Float.parseFloat(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		float b = Float.parseFloat(kb.nextLine());
		
		
		float result = a * b;
		
		System.out.println(result);
		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metotlar Konusu
 * 
 * ifade(expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan herhangi bir dizilime ifade denir.
 * Değişkenler ve sabitler tek başına ifade belirtebilirken, operatorler tek başına ifade olamazlar. İstisna bir durum dışında
 * ifadeler hesaplandığında bir değer üretirler.
 * 
 *  a + b
 */

/*
 * Bir metodun geri dönüş degeri bilgisi yerine bir tür ismi yazılırsa bu metodun "geri dönüşü vardır" denir. 
 * Tersine bir metodun geri dönüş degeri varsa geri dönüş degeri bilgisi yerine bir tür ismi yazılır. 
 * Bir metodun geri dönüş deger varsa metot çağrısı bittikten sonra çağrıuldığı noktaya bir değer ile geri döner.
 * Bir metodun geri dönüş değeri yoksa geri dönüş değeri bilgisi yerine void anahtar sözcüğü yazılır. 
 * Bir metodun geri dönüş değeri metot içerisinde return  deyimi ile oluşturulur. 
 * 
 * return deyiminin genel biçimi:
 *  		return [ifade];
 *  
 * return deyimi nasıl kullanılırsa kullanılsın metodu sonlandırır. Yani metot içerisinde akış return deyimine geldiğindemetot sonlanır 
 * ve akış çağrılan noktaya geri döner. return deyimine ilişkin ifadenin değeri çağıran metoda aktarılır.
 *  
 */


/*
 * Aşağıdaki örnekte add metodunun geri dönüş değeri 3 ile çarpılmış ve sonucu result değişkenine atanmıştır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
	}
}






-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Not: Java derleyicisi genel olarak bir deyime akışın hiçber zaman gelemeyeceğini anlarsa o yazılan
 * deyim için error oluşturur (unreachable code).
 */

/*
 * return deyimi nasıl kullanılırsa kullanılsın metodu sonlandırır. Aşağıdaki örnekte return deyiminden sonra 
 * akış metot içerisinde kalmayacağından error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
		
		System.out.println("Unreachable Code");
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * akış return deyimine geldiğinde return deyimine ilişkin ifade önce hesaplanır, elde edilen değer döndürülür
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Geri dönüş değeri olan metotolarda (void olmayan metotlarda )return tek başına kullanılamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return; //error		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Geri dönüş değeri olan metotolarda  akışın her noktasında bir değere geri dönemlidir. Aksi durumda error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Geri dönüş değeri olan metotolarda  akışın her noktasında bir değere geri dönemlidir. Aksi durumda error oluşur.
 * Aşaığıdaki örnekte result 10 değerinden küçük veya eşitise metot bir değer döndürmeyeceğinden error oluşur.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		if(result > 10)
			return result;
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Derleyici geri dönüş değerinin çağıran metoda aktarımı geçici değişken yaratan bir kod üretir. 
 * Aşağıdaki ** ile belirtilen kod parçası için derleyicinin ürettiği temsili kod şu şekildedir:
 * 
 * 			int temp = a + b;
 * 
 * 			returlt = temp * 3;
 * 
 * Yani aslında geri dönüş değeri geçici değişkene yapılan bir atama işlemidir. Geçici değişkenin türü metodun
 * geri dönüş değerinin türü ile aynıdır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3; //**
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		return a + b; // int temp = a + b;
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 *Geri dönüş değeri olan metotolar geri dönüş degeri işleme sokulmayacak şekilde çağrılabilirler. 
 *Şüphesiz metodun da tasarımı bu kullanım açısından anlamlı olmalıdır. Aşağıdaki örnekte add metotdu klavyeden alınan 
 *değerlerin toplamını ekrana basıp aynı zamanda da değere geri dönmektedir. Programcı kodda metodun sadece ekrana basmasıyla ilgilenmiş
 *ve geri dönüş değerini kullanmamıştır. Şephesiz başka bir çağrıda kullanaılabilir.
 *
 *
 *Metot ekrana toplam değerini basmasaydı bu şekilde çağırma uygun olurmu? (işimize yararmıydı)?
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.add();
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		System.out.println(result);
		
		return result;
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bir metodun geri dönüş değeri başka bir motdun geri dönüş değeri olarak verilebilir. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = Util.getAdd();
		
		System.out.println(result);
	}
}

class Util{
	public static int getAdd()
	{
		System.out.println("Toplama islemi yapılıyor");
		
		return NumberUtil.add();
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		return result;
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte yine add metodunun geri dönüş değeri bir işleme sokulmuştur 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = Util.getResult();
		
		System.out.println(result);
	}
}

class Util{
	public static int getResult()
	{
		System.out.println("Toplama islemi yapılıyor");
		
		return NumberUtil.add() * 2;
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		return result;
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda return deyimi zorunlu değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda return istenirse metodu sonlandırmak için tek başına kullanılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		if(result < 0)
			return;
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	void metotlarda return deyimi ifade ile kullanılamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		if(result < 0)
			return 10; //error
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda geri dönüş değeri varmış gibi çağrılamaz. Yani void metot çağrısı geri dönüş varmış gibi işleme sokulamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.printAdd(); //error
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metot'larda parametre değişkenleri
 *
 * Metot bildirimlerinde metot isminden sonra parantezler arasında bildirilen değişkenlere "metot parametre değişkenleri"
 * ya da "parametre değişkneleri" denir. Bir metodun parametre değişkeni olmayabilir ya da istenildiği sayıda virgül ile 
 * ayrılarak bildirlebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a, int b)
	{
		//..
	}
	
	public static void printSquare(int a)
	{
		//..
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	bir metodun parametre değişkenleri aynı türden olsa bile tür bilgisi yazılmalıdır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a,  b) //error
	{
		//..
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metodun parametre değişkenleri faaliyet alanı bakımıından metot başında bildirilen yerel değişkenler gibidir.
 * Dikkat bu cümle sadece faaliyet alanı bakımından aynı oldujlarının söylüyor. Sonuçta yerel değişken ile 
 * parametre değişlkeni aynı değildir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b) //error
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metodun parametre değişkenlerine değerler metot çağrılır iken verilir. Metot çağırlırken bir parametreye verilen
 * ifadeye "argüman" denir. Bir metot kaç tane parametre sahipse o kadar sayıda arguman ile çağrılmalıdır. 
 * Argumanlardan parametrelere aktarım da bir atam işlemidir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x, y);
		
		int result = NumberUtil.square(x);
		
		System.out.println(result);		
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b) //error
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metot parametre saysı kadar argüman ile çağrılmalıdır. Aksi durumda error oluşur.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x); //error
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Metot çağrısında bir argüman ilişkin ifade önce hesaplanır, elde edilen değer ile metot çağrılır. Birden fazla
 *  parametreye sahip bir metot çağrısında tüm argümanlara ilişkin ifadeler hesaplanır, elde edilen değeler ile metot çağrılır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x + 3, y * 2);
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun parametre değişkeni ya da değişkenleri hem de degeri dönüş degeri olabilir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x + 3, y * 2);
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun geri dönüş değeri başka bir metoda argüman oalrak geçilebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.square(NumberUtil.add(x, y));

		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun geri dönüş değeri başka bir metoda argüman oalrak geçilebilir.
 *  Bu tip "compact" çözümler kodun okunabilirliğini / algılanabilirliğini etkilememelidir. Gerekirse ayrı ayrı hesaplanacak 
 *  şekilde yazılmalıdır.
 *
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.square(NumberUtil.add(x - 6, y - 5)));
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	bir önceki örnek okunabilirlik/algılanabilirlik açısından aşağıdaki gibi de yazılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int total = NumberUtil.add(x - 6, y - 5);
		int result = NumberUtil.square(total);
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Aşagıdaki  örnekte iki add çağrısı araında argumanlarda değişiklik olmamasına karşın programcı iki kere çağırmıştır.	
 * Bu duurumda kod hem iki defa çağırmanın gereksizliği hemde okunabilirlik/algılanabilirlik açısından kötü yazılmıştır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.add(x, y));
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(NumberUtil.add(x, y));
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşagıdaki  örnekte iki add çağrısı araında argumanlarda değişiklik olmamasına karşın programcı iki kere çağırmıştır.	
 * Bu duurumda kod hem iki defa çağırmanın gereksizliği hemde okunabilirlik/algılanabilirlik açısından kötü yazılmıştır.
 * 
 * 
 * kötü kod bu şekilde yazılması daha doğru
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.add(x, y);
		
		System.out.println(result);
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metotlar ne işe yarar= Ya da başka bir deyişle bir problemin çözümünde neden metotlar yazalım?
 * 
 * - Bir işi çok fazla yerde yapmak kod tekrarına yol açar. Yazılım geliştirmede temel prensip "zorunlu olmadıkça
 * 	 kod tekrarı yapılmamalıdır (do not repeat yourself)" şeklindedir. Bu durumda programcı örneğin bir metot yazar ve ilgili yerlerde bu metodu çağırır.
 * 
 * 
 * - Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde  "implemente" edilmişse, bu durumda programcı
 *  problemin bir değişiklik yapmak isterse veya bir hata oldgunda anlayıp düzeltmek isterse her yerde bu değişilikleri yapmak zorunda kalacaktır. 
 *  Bu çoğu zman zor olabilir.
 * 
 * 
 * - Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde "implemente" edilmişse, bu durumda
 *   kodun okunabilirliği de azalabilir. Yani metot çağırarak kodun okunabilirliği de artmış olur.
 * 
 * - Metot yazıldıgında başka projelere taşınarak da kullanılabilir. (code re-usability)
 * 
 * - Metodu çağıran programcı metodun nasıl yazışdıgına ilişkin detayları bilmek zorunda değildir. Çünkü metodun
 *   çağrıldığı noktada metodun nasıl yazıldıgının önemi yoktur.
 *   
 *   
 *   Not: İleride ele alacağımız "nesne yönelimli programalama tekniği"'ne ilişkin kavramlar ile kodun parçalara ayrılması metotlar
 *   dışında daha yüksek seviyede de yapılabilmektedir. Yani kabaca bu tarz programlamanın temelinde metotlar vardır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.add(x, y);
		
		System.out.println(result);
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * System.out.printf metodunun ilk argümanı String olmalıdır. Metot bu argüman dışında istenilen sayıda ve istenilen türde
 * argüman ile çağıralabilir. Metodun birinci parametresine ilişkin argümanda % karateri ile birlikte geçerli
 * bazı karakterler kullanıldıgında "yer tutucu (place holder)" belirtişmiş olur. % ile birlikte kullanıma
 * "format belirleyici (format specifiers)" da denir. % birlikte kullanılan geçerli karatere ise "format karateri" denir.
 * Metot yer tutucular yerine diğer geçilen argümanlara ilişkin degerleri yerleştirir ve ekrana bu yazıyı basar. 
 * Bazı format karaterleri bir argümana ilişkin değere karşılık gelmez. Özel anlamları vardır.
 * 
 * 
 * Not: printf gibi değişkeb sayıda argüman alabilen metotlara "variadic methods" denir. 
 * Buarada bu tarz metotların nasıl yazıldıgı ele alınmayacaktır.
 * 
 */


/*
 * Tamsayı türlerinin (short, int, long, byte) decimal olarak formatlanması  d format karateri kullanılır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int degree = Integer.parseInt(kb.nextLine());
		
		System.out.printf("Bugün hava %d derece", degree);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda imleci bir sonraki starın başına geçirmek için %n kullanılabilir. %n bu anlamda bir argümana karşılık gelmez
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Arasınav notunuzu giriniz : ");
		int midtermGrade = Integer.parseInt(kb.nextLine());
		
		System.out.print("Final notunuzu giriniz : ");
		int finalGrade = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("Arasınav : %d%nFinal: %d%n", midtermGrade, finalGrade);
		System.out.println("Geçme notrunuz hesaplanıyor!....");
		//...
		//..
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodu x, X, h, H format karaterleri ile tamsayi türlerine ilişkin değerler hexadecimal olarak formatlanabilir.
 * Ayrıca o format karateri ile tamsayı türlerine ilişkin değerler octal olarak formatlanabilir.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %x%n", val);
		System.out.printf("val = %X%n", val);
		System.out.printf("val = %h%n", val);
		System.out.printf("val = %H%n", val);
		System.out.printf("val = %o%n", val);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir. Aşağıdaki örnekte 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %-8d  %10d%n", val, val);

	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir. Aşağıdaki örnekte  %08X yer tutucu için 
 * yazıulan karater sayısı 8'den kucukse geri kalanlar için sıfır yazılır 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %8d%n", val);
		System.out.printf("val = %-8d  %8d%n", val, val);

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Gün : ");
		int day = Integer.parseInt(kb.nextLine());
		System.out.print("Ay : ");
		int mon = Integer.parseInt(kb.nextLine());
		System.out.print("Yıl : ");
		int year = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%02d/%02d/%04d%n", day, mon, year);

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Gün : ");
		int day = Integer.parseInt(kb.nextLine());
		System.out.print("Ay : ");
		int mon = Integer.parseInt(kb.nextLine());
		System.out.print("Yıl : ");
		int year = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%2d/%02d/%4d%n", day, mon, year);

	}
}



-----------------------------------------------------------
-----------------------------------------------------------
08/12/2022

/*
 * printf metodunda gerçek sayılar (folat ve double) için f format karateri kullanılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("bir gercek sayi giriniz : ");
		double dval = Double.parseDouble(kb.nextLine());
		
		System.out.printf("val = %f%n", dval);

	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodunda  f format karateri ile ondalık kısmın kaç basamak olarak formatlanacağı 
 * aşagıdaki gibi belirtilebilir.
 * Geri kalan basmaklar bilimsel olarak yuvarlanır
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("bir gercek sayi giriniz : ");
		double dval = Double.parseDouble(kb.nextLine());
		
		System.out.printf("val = %.3f%n", dval);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  char türü için c format karateri kullanilabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 3333;
		
		System.out.printf("c = %c%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  boolean türü için b format karateri kullanilabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		System.out.printf("flag = %b%n", flag);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  uygun format karakterlei kullanılmadıgında genel olarak exception oluşur.
 * 
 * Bu durumun istisnaları var
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		System.out.printf("flag = %d%n", flag);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda s format karateri ile tür ne olursa olsun formatlanabilir. Şüphesiz bu durumda türe özgü
 * biçimler (hizalama vs) kullanılmaz. Bu format karakterinin ayrıntıları ileri ele alınacak
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 3.4;
		boolean c = true;
		char d = 67;
		
		System.out.printf("a = %s, b = %s, c = %s d= %s%n", a, b, c, d);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda % karakterinden sonra uygun bir format karateri getirilmelidir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double ratio;
		
		ratio = 18.4;
		
		//  % 18.4
		
		System.out.printf("Oran : %  %f%n", ratio);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodunda % karakteri için iki tane % karateri kullanılmalıdır
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double ratio;
		
		ratio = 18.4;
		
		//  % 18.4
		
		System.out.printf("Oran : %%%f%n", ratio);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
Not: printf metodunun format karakterleri ve kullanım biçimleri oldukça geniştir. 
Burada sadece temel olanlar ele alınmıştır. Diğer format karakterleri ve kullanım biçimleri konular içerisinde ele alınacaktır.
-----------------------------------------------------------
-----------------------------------------------------------

Çalışma: Klavyeden girilen iki tane int türden sayının toplamını ve çarpımını aşagıdaki gibi
ekrana basan programı yazınız:

Girelen sayılar 10 ve 20 ise

	10 + 20 = 30
	10 * 20 = 200
	
	şeklinde çıktılar verecektir.
	
	
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 
Çalışma: Klavyeden girilen iki tane int türden sayının toplamını ve çarpımını aşagıdaki gibi
ekrana basan programı yazınız:

Girelen sayılar 10 ve 20 ise

	10 + 20 = 30
	10 * 20 = 200
	
	şeklinde çıktılar verecektir.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindSumMultiplyApp.run();
	}
}

class FindSumMultiplyApp{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d + %d = %d%n", a, b, NumberUtil.add(a, b));
		System.out.printf("%d * %d = %d%n", a, b, NumberUtil.multiply(a, b));
		
	}
}

class NumberUtil{
	public static int add(int a, int b)
	{
		return a + b;
	}
	
	public static int multiply(int a, int b)
	{
		return a * b;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Bölme işlemi tamsayılar ile yapıldıgında sonuç her zaman tamsayı çıkar. Elde edilen sayının noktadan sonraki kısmı
 * yuvarlanmadan atılır.
 * 
 * Tamsayılar ile bölme işleminde paydanın sıfır olması durumnda exception olusur
 * 
 * .Bu durumların detayları ileri ele alınacak
 * 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		double result = a / b;
		
		System.out.printf("%d  / %d = %f%n", a, b, result);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * format metot du ile printf tamamen aynı işlemi yapar
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		System.out.format("%d  %d %n", a, b);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 	Gerçek sayılar ile bölme işleminde payda sıfır olsa da işlem yapılır. Yani bir exception oluşmaz. Gerçek sayılar
	içerisinde genel olarak Matematik'teki "belirsizlik" için kullanılan "Not a number (NaN)" değeri vardır. Ayrıca
	genel olarak sonsuzluk (Matematik'teki tanımsızlık) için kullanılan -Infinity ve +Infinity değerleri de vardır. 
	Bu özel değerler dışında da başka özel değerler vardır. Bu durumda gerçek sayılar ile bölme işleminde pay sıfırdan
	farklı, payda sıfır ise payın işaretine göre + veya - Infinity, pay ve paydanın ikisi birden sıfır ise NaN sonucu
	elde edilir 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
		
		double result = a / b;
		
		System.out.printf("%f / %f = %f%n", a, b, result);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 	Neden standart metoları kullanmalıyız? Yani standart olarak var olan metodu programcı yazmalımıdır?
 * 	Java da standart olarak (JavaSE) bulunan metotların kullnılmasının bazı önemli avantajları varıdr:
 * 
 * 	-okunabilir kodlar yazılır
 *  -Testleri yapılmıştır ve yeterince etkin olarak yazılmıstır
 *  -Taşınabilir
 *  -Bazı metotlar (ki bunların sayısı oldukca fazladır) baska detay konularıda bilmeyi gerektirir
 *  -Programcının projede sadece kendi konusna odaklanmasıı saglar
 *  
 *   Bu durumda bir Java programcısı çözmesi gereken bir problem için JavaSE'de problemin çözümüne ilişkin metotlar varsa
 *	 onları kullanmalıdır. Yoksa yazma işlemine girişmelidir. Ancak bu druum programcının standart kullandığı metotların
 *	 nasıl yazıldığını gözardı etmesi anlamına gelmez. Programcı programlama yaşamı boyunca hepsini olmasa da hazır olarak
 *	 kullandıklarının nasıl gerçekleştirilebileceğini öğrenmelidir
 */

/*
 * Math sınıfı abs metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
	
		System.out.printf("|%f| = %f%n", a, Math.abs(a));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfı sqrt metodu: Metot negatif degerler için NaN degerine geri döner
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
	
		System.out.printf("sqrt(%f) = %f%n", a, Math.sqrt(a));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfı pow metodu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("Birinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
	
		System.out.printf("pow(%f, %f) = %.12f%n", a, b, Math.pow(a, b));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfı pow metodu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("Birinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
	
		System.out.printf("pow(%f, %f) = %.12f%n", a, b, Math.pow(a, b));
		
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Çalışma: Parametresi ile aldıgı double tür x1, y1, x2, y2 koordinat bilgileribe göre
 * iki nokta arasındaki ((x1, y1) ve (x2, y2) noktaları) uzaklıga geri dönen distance isimli metodu PointUtil isimli
 * sınıf içerisinde yazınız.
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1: ");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1: ");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2: ");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2: ");
		double y2 = Double.parseDouble(kb.nextLine());
	
		System.out.printf("Destance: %f%n", PointUtil.distance(x1, y1, x2, y2));
	}
}

class PointUtil
{
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Çalışma: Parametresi ile aldıgı double tür x1, y1, x2, y2 koordinat bilgileribe göre
 * iki nokta arasındaki ((x1, y1) ve (x2, y2) noktaları) uzaklıga geri dönen distance isimli metodu PointUtil isimli
 * sınıf içerisinde yazınız.
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1: ");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1: ");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2: ");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2: ");
		double y2 = Double.parseDouble(kb.nextLine());
	
		System.out.printf("Destance: %f%n", PointUtil.distance(x1, y1, x2, y2));
	}
}

class PointUtil
{
	public static double distance(double x1, double y1, double x2, double y2)
	{
		double dx = x1 - x2;
		double dy = y1 - y2;
		
		return Math.sqrt(dx * dx + dy * dy);
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfın PI ve E elemanları
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println(Math.PI);
		System.out.println(Math.E);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının trigonometrik işlem yapan metotları radyan ölçü birimi ile çalışır
 * 
 * Radyan ve derece arasındaki dönüşümler için toRadians ve toDegrees metotoları kullanılabilir. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("value: ");
		double value = Double.parseDouble(kb.nextLine());
		
		System.out.printf("sin(%f) = %f%n", value, Math.sin(Math.toRadians(value)));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının min ve max metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f) = %f%n",a ,b ,Math.min(a, b));
		System.out.printf("max(%f, %f) = %f%n",a ,b ,Math.max(a, b));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının min ve max metotları metotları ile 3 tane sayının en kucuk v e en buyuk olanını bulma
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c: ");
		double c = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f, %f) = %f%n",a ,b ,c, Math.min(Math.min(a, b), c));
		System.out.printf("max(%f, %f, %f) = %f%n",a ,b ,c, Math.max(Math.max(a, b), c));
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının min ve max metotları metotları ile 3 tane sayının en kucuk v e en buyuk olanını bulma
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c: ");
		double c = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f, %f) = %f%n",a ,b ,c, MathUtil.min(a, b, c));
		System.out.printf("max(%f, %f, %f) = %f%n",a ,b ,c, MathUtil.max(a, b, c));
	}
}

class MathUtil{
	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}
	
	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f, %f) = %f%n", a, b, MathUtil.log(a, b));
	}
}


class MathUtil{
	public static double log(double a, double b) {
		return Math.log10(b) / Math.log10(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("round(%f) = %d%n", a, Math.round(a));
		System.out.printf("ceil(%f) = %.20f%n", a, Math.ceil(a));
		System.out.printf("floor(%f) = %.20f%n", a, Math.floor(a));
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------,
	Sabitler (literals, constants)
	Program içerisinde doğrudan yazılan sayılara denir. Sabitlerin de türleri vardır. Derleyici sabitlerin türlerini 
	tespit ederek işlem yapar.
	
	Sabitlerin türlerinin tespitine ilişkin detaylar:
	- Sayı nokta içermiyorsa, sonuna bir ek almamışsa ve int türü sınırları içerisindeyse int türdendir. Sayı int türü
	sınırları içerisinde değilse error oluşur. 
	Örneğin: 100, 2000, 2000000000
	
	- Sayı nokta içermiyorsa ve sonuna L (küçük veya büyük) ekini almışsa long türdendir. Sayı long türü sınırları
	dışındaysa error oluşur. 
	Örneğin: 10L, 4000000000L
	
	Anahtar Notlar: Küçk harf L kullanımı 1(bir) rakamanına benzemesinden dolayı programlamada tercih edilmez. 
	
	- Java'da byte ve short türden sabitler yoktur
	
	- Sayı nokta içeriyorsa ve sonuna bir ek almamışsa double türdendir. Sayı double olarak ifade edilemiyor ise
	error oluşur
	Örneğin: 3.4, 6.7
	
	- Sayı nokta içersin ya da içermesin sonunda D (küçük ya da büyük) eki varsa double türdendir.
	Örneğin: 3D, 10d, 30.56D
	
	- Sayı nokta içersin ya da içermesin sonunda F (küçük ya da büyük) eki varsa float türdendir.
	Örneğin: 3F, 2f, 3.4F
	
	- boolean türden iki tane sabit vardır: true, false
	
	- char türden sabitler: İki tane tek tırnak karakteri arasında yazılan bir karakter, karakter tablosunda sıra 
	numarası belirtir. Bu şekilde yazılan sabitlere "karakter sabitleri (character literals)" denir ve bu sabitler char
	türdendir. İki tane tek tırnak karakteri arasında özel durumlar dışında birden fazla karakter yazımı geçersizdir. 
	
	Bazı karakterlerin klavyeden basılması doğrudan derleyici tarafından karakter olarak algılanamaz. Hatta bazı
	karakteler "non-printable"'dır. Örneğin bir sonraki satıra geçme karkaterinin karakter sabiti doğrudan yazılamaz.
	Bu tip bazı karakterler klavyeden doğrudan yazılamazlar. Bu tarz karakterlerin karakter sabitleri iki tane tek
	tırnak içerisinde ters bölü karakteri ile onu takip eden özel bir karakter biçiminde yazılır. Bu şekilde yazılan
	karakterlere "escape sequence" karakterler denir. Hatta bazı karakterler hem normal hem de ters bölü ile yazılabilirler:
	Java'da desteklenen escape sequence karakterler şunlardır:
	
	'\n' -> line feed (LF) 
	'\r' -> carriage return (CR)
	'\t' -> horizontal tab
	'\b' -> backspace
	'\f' -> form feed
	'\0' -> null karakter
	'\"' -> double quote (optional)
	'\'' -> single quote
	'\\' -> back slash  
----------------------------------------------------------------------------------------------------------------------*/

/*
 * char türden sabitler
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'D';
		
		System.out.println(c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * iki tane tek tırnak arasında birden fazla karater yazımı özel durumlar dışında geçersizdir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'De'; //error
		
		System.out.println(c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Line feed karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\n';
		
		System.out.printf("Marhaba");
		System.out.print(c);
		System.out.printf("Nasılsın ");
		System.out.printf("Ali");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Carriage return karater sabiti: 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\r';
		
		System.out.printf("Marhabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Horizontal tab karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\t';
		
		System.out.printf("Merhaba");
		System.out.print(c);
		System.out.print(c);
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Backspace karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\b'; 	
		
		System.out.printf("Merhaba");
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Merhaba,\nNasılsın\nİyi misin?");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Merhaba,\rİyi misin?");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch1 = '"';
		char ch2 = '\"';
		
		System.out.println(ch1);
		System.out.println(ch2);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * İki tırnak karateri string atomu içerisinde ters bölü ile yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("\"Merhaba Ali, nasıl gidiyor\"");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Tek  tırnak karateri string atomu içerisinde dogrudan ya da ters bölü ile kullanılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("'Merhaba Ali, nasıl gidiyor\'");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
13.12.2022 Salı


/*
 * Tek  tırnak karater sabiti ters bölü ile yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '\'';
		
		System.out.println(ch);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape karakterlerinden dolayı istenilen sonuç elde edilemez
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\testdata\noname.txt");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *yukarıdaki problem aşağıdaki gibi çözümlenir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\\testdata\\noname.txt");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *ters bölü karakterinden sonra özel karakterler dışında yazılan karakter error olusturur
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\testdata\orhan.txt");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *\\\\192.168.1.21\\testdata\\orhan.txt yol ifadesi "String literal" içerisinde yazılması gerek
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("\\\\192.168.1.21\\testdata\\orhan.txt");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  tek tırnak karakteri değildir -- backtick
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '`';
				
		System.out.println(ch);
		System.out.println("`Orhan OZTURK`");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü ve u karakteri ile bir karakterin sıra numarası hexadecimal olarak tek tırnak içerisinde yazıldıgında
 *  o karatere ilişkin karater sabiti yazılmış olur. Burada hexadecimal sayı kesinlikle iki byte olarak yani
 *  4 tane hex digit olarak yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '\u00CB';
				
		System.out.println(ch);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü u ile yazılan karakter sabitleri "string literal" atomu içerisinde de kullanılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Orhan OZTURK : \u1788");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü u ile yazılan karakter değişken isimlendirmede de kullanılabilir. Şüphesiz pratik değildir.
 *  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int \u0041\u0042\u00CB = 10;

		System.out.println(AB\u00CB);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  bir tamsayının ön eki yoksa bu durumda sabit "decimal" olarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;

		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik ıkarak sıfır ve x (buyuk ve kucuk farketmez) yazıldıgında ekten sonra gelen 
 *  basamaklar  "hexadecimal" oalarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 0xA;

		System.out.println(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik sıfır yazıldıgında ekten sonra gelen 
 *  basamaklar  "octal" oalarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 012;

		System.out.println(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------


/*
 *  Bir tamsayı sabitinin önüne bitişik 0b yazıldıgında ekten sonra gelen basamaklar  "binary" oalarak ele alınır.
 *  ikilik sistemde yazulan sabitler Java 7 ile eklendi.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 0b1010;

		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik 0b yazıldıgında ekten sonra gelen basamaklar  "binary" oalarak ele alınır.
 *  ikilik sistemde yazulan sabitler Java 7 ile eklendi.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		short value = 0b11101;
		
		SensorUtil.out(value);
		
		value = 0x1D;
		
		SensorUtil.out(value);
	}
}

class SensorUtil{
	public static void out(short value)
	{
		System.out.printf("value:%04X%n", value);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki örnekte SensorUtil sınıfının out metodu 16 tane pini olan bir elektronik devre için aldığı argüman 
	değerine göre değerin bit'lerin karşılık gelen pinleri 1 ya da sıfır için "high" ya da "low" seviyeye çekiyor olsun.
	Bu durumda böyle bir metodun alacağı sabit argümanın "binary" veya "hexadecimal" olarak yazılması okunabilirliliği
	artırır. Ayrıca yazım kolaylığı da sağlar. Aşağıdaki demo örneği yukarıdaki senaryoya göre düşününüz   
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		short value = 0b11101;
		
		SensorUtil.out(value);
		
		value = 0x1D;
		
		SensorUtil.out(value);
	}
}

class SensorUtil{
	public static void out(short value)
	{
		System.out.printf("value:%04X%n", value);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gercekı sayıların üstel (bilimsel) gosterilişi
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 1.3E10;
		double b = 1.3e10;
		double c = 1.3E+10;
		double d = 1.3e+10;
		double e = 1.3E-10;
		double f = 1.3e-10;
		
		
		System.out.printf("a  = %f%n", a);
		System.out.printf("b  = %f%n", b);
		System.out.printf("c  = %f%n", c);
		System.out.printf("d  = %f%n", d);
		System.out.printf("e  = %.12f%n", e);
		System.out.printf("f  = %.12f%n", f);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gercekı sayıların üstel (bilimsel) gosterilişi
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double avogadroConstant = 6.02E23;
		
		System.out.println(avogadroConstant);
		System.out.printf("%f%n", avogadroConstant);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java 7 ile birlikte tamsayı ve gerçek sayı sabitleri içerisinde alttire karaterleri kullanılabilmektedir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 0xFC_AB_CD;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Java 7 ile birlikte tamsayı ve gerçek sayı sabitleri içerisinde alttire karaterleri kullanılabilmektedir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 5_456_123_000L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri kullnaıldıgı yerde istenildigi kadar yazılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 5_______________________________________8L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri kullnaıldıgı yerde istenildigi kadar yazılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 0b10101010_10101011_10101010_0011L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sabitin sonunda ve başında olamaz sentaks hatası
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = _67; //error
		b = 43_; //error
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sayı nokta içerisiyorsa noktadan hemen önce veya sonra alttire geçilemez
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 6_.4; //error
		b = 4._4; //error
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  alttire karateri sabitin sonunda ve başında olamaz sentaks hatası
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a, b;
		
		a = 5000000000L_; //error
		b = 5000000000_L; //error
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sabit önündeki eklerdeb önce sonra yada ekler arasına konulamaz
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		
		a = 0x_AB; //error
		b = _0xAB; //error
		c = 0_xAB; //error
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * alttire karateri octal sabitler için önek ile (sıfır ile) ilk basamak arasında geçerlidir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 0_12;
		
		System.out.println(a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gerçek sayı sabitlerinin tamsayı kısmının degeri sıfır ise noktadan nce sıfır yazılmayabilir.
 * Benze şekilde sayının noktadan sonraki kısmının tamamı sıfır ise yibe sıfır noktadan sonra yazılmayabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double a, b;
		
		a = .3;
		b= 3.;
		
		System.out.printf("a = %f%n", a);
		System.out.printf("b = %f%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Yalnızca sabitlerden ve operatörleden oluşan yani içerisinde değişken olmayan ifadelere "sabit ifadesi (constant expression)" denir.
 * Buy anlamda sabit de tek başına bir sabit ifadesidir.
 * 
 * 
 * Not: İleride aslında sabit ifadesi olark kullanılabilen değişkenler de göreceğiz. Bu tarz değişknler de
 * bir ifade içersinde sabit olarak ele alınır.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		b = 20;
		
		System.out.println(NumberUtil.add(a - 2, b)); //argümanların hiçbiti sabit ifadesi değil
		System.out.println(NumberUtil.add(10 + 5, 89 - 8)); //argümanların hepsi sabit ifadesi 
	}
}

class NumberUtil{
	public static int add(int a, int b) {
		return a + b;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Derleyiciler sabit ifadelerinin değerlini hesaplayarak sonucu "byte code" a yazarlar. Bu optimizasyona
 * "constant folding optimizasyonu" denir. Bu sebeple aşağıdaki kodda 1000L * 60 * 60 * 24 * 365 ifadesinin
 * değeri byte code'a 31536000000 şeklinde yazılır. Aşağıdaki örnekte bilgi kaybı olmaması için 1000 sabitini 
 * long olarka yazılmıstır. Konuya ileride değinecez.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long divider = 1000L * 60 * 60 * 24 * 365; //byte code --> long divider = 31536000000;
		
		System.out.println(divider);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
			Operatörler
			
	Operatörler: Bir işleme yol açan ve işlem sonucunda bir değer üreten atomlara operatör denir. Operatör ile
	birlikte işleme giren ifadelere "operand" denir.
	
	Operatörleri 3(üç) biçimde sınıflandırılabilir:
	1. İşlevlerine göre sınıflandırma
		- Aritmetik (arithmetic) operatörler
		- Karşılaştırma (comparison) operatörleri
		- Mantıksal (logical) operatörler
		- Bitsel (bitwise) operatörler
		- Özel amaçlı (special purpose) operatörler	
	2. Operand sayısına göre sınıflandırma
		- Tek operandlı (unary)
		- İki operandlı (binary)
		- Üç operandlı (ternary)	
	3. Operatörün konumuna göre sınıflandırma
		- önek (prefix)
		- araek (infix)
		- sonek (postfix)
		
	Operatörün kısıtı (constraint)
	Operatörün ürettiği değer (product value)
	Operatörün yan etkisi (side effect) var mı?
	Operatörün önceliği (precedence):
	
	a = b + c * d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: c * d
	i2: b + i1
	i3: a = i2
	
	a = (b + c) * d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: b + c
	i2: i1 * d
	i3: a = i2	
	
	a = b + c - d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: b + c
	i2: i1 - d
	i3: a = i2
		
	Not: Java programcısı bir operatör için yukarıdaki durumları bilmelidir. Yani bir operatörün öğrenilmesi
	o operatör için yukarıdaki durumların bilinmesi anlamına gelir.	
	
	Not: Bazı operatörler öncelik kuralına doğrudan uymazlar. Bu tarz operatörlerin de uymadıkları durum için
	nasıl çalıştıklarının bilinmesi gerekir. Şüphesiz bu operatörlerin neden öncelik kurallarına uymadıklarının da 
	gerekçeleri (rationale) bulunur.
	
	
	Not: Operatör öncelik tablosu gruplandırma olarak düşünülebilir. Yani operatör öncelik tablosundaki öncelik
	durumlarının yapılış biçimine ilişkin istisnaları olabilir. Şüphesiz bunun da bilinmesi gerekir. Operatör öncelik
	tablosu algısal bakımdan kolaylaştırmak için vardır ve önemlidir.	

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Artimetik 4 işlem ve mod operatörleri iki operandlı (binary) ve araek (infix) operatörlerdir.
 * Bu operatörlerin ürettileri değer işlemin sonucunda elde edilen değerdir. 
 * Bu operatörlerin yan etkisi (side effect) yoktur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%d + %d = %d%n", a, b, a + b);
		System.out.printf("%d - %d = %d%n", a, b, a - b);
		System.out.printf("%d * %d = %d%n", a, b, a * b);
		System.out.printf("%d / %d = %d%n", a, b, a / b);
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mod operatörünün birinci operandı negatif ise sonuç negatif çıkar. İkinci operandının negatif olmasının bir önemi yoktur.
 * Başka bir deyile mod operatörünün sonucunun işareti birinci operandının işareti ile aynıdıur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Çalışma: Parametresi ile aldığı en fazla 3 basamaklı int türünden bir sayının basamakları toplamına
 * geri dönen digitsSum isimli metodu NumberUtil sınıfı içerisinde yazınız. Metot aldıgı argümanın en fazla
 * 3 basamaklı olup olmadıgını kontrol etmeyecektir. Basamaklar toplamı pozitif olarak döndürecektir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		DigitsSumTest.run();
	}
}

class DigitsSumTest{
	public static void run() {
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d sayısının basamakları toplamı = %d%n", val, NumberUtil.digitsSum(val));
	}
}

class NumberUtil{
	public static int digitsSum(int val) {
		int a, b, c;
		
		a = val / 100;
		b = val / 10 % 10;
		c = val % 10;
		
		return Math.abs(a + b + c);
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * işaret - aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. 
 * Operatörünün yan etkisi yoktur.
 * Operaötr operandına ilişkin ifadenin degerinin tersini üretir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		int b;
		
		b = -a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * işaret + aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. 
 * Operatörünün yan etkisi yoktur.
 * Operaötr operandına ilişkin ifadenin degerini üretir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		int b;
		
		b = +a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * işaret - operaörünün seviyesinde bulunan operaötlerin sagdan sole (right associative)
 * ele alınmasından dolayı geçerlidir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		int b;
		
		b = a - - - - - - - - - - 2;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * geçerli ifade
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a =  - - - - - - - - - - 10;
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 artırır.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 10;
		
		++a; // a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 artırır.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 10;
		
		a++; // a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ++ operatörü prefix kullanımında ürettiği deger yani işleme giren deger arttırılmıs degerdir
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = ++a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ++ operatörü postfix kullanımında ürettiği deger yani işleme giren deger arttırılMAmıs degerdir
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a++; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 azaltma.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		--a; // a = a - 1; 
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * -- operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 azaltma.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		a--; // a = a - 1; 
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü prefix kullanılmaktadır degeri o an azaltmıstır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = --a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü postfix kullanılmaktadır degeri o an azaltMAmıstır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a--; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ekrana ne bastırır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a-- + ++a; 
		
		System.out.printf("a = %d%n", a); // 10
		System.out.printf("b = %d%n", b); //21 //22 //20
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ekrana ne bastırır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 3;
		
		b = a-- + ++a * a; //3 + 3 * 3 = 12
		
		System.out.printf("a = %d%n", a); // 3
		System.out.printf("b = %d%n", b); //12
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ekrana ne bastırır
 * Aşağıdaki örnekte ++ ve -- operatörleri ve operandları aynı ifadede kullanılmıştır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a-- + a-- + a; //10 + 9 + 8
		
		System.out.printf("a = %d%n", a); // 8
		System.out.printf("b = %d%n", b); //27
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Derleyici yukarıdan aşağıya ve soldan sağa olmak üzere anlamlı en uzun ifadeyi
 * alacak şeklilde atomlarına ayırma işlemi yaparak (maximum munch). 
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 11;
		int c;
		
		c = a+++b; //a++ + b 
		
		System.out.printf("a = %d%n", a); 
		System.out.printf("b = %d%n", b); 
		System.out.printf("c = %d%n", c); 
	}
}

	Not: Okunabilirlik/algılanabilirlik açısından tek operandlı operatörleri genel olarak operandına
	bitişik biçimde yazacağız. İki operandlı operatörleri de özel ama önemli operatörler dışında operandları ile operatör
	arasında yalnızca bir tane "space" karakteri olacak şekilde yazacağız
	
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ ve -- operatörlerinin operandlarının değişken olması gerekir. Aksi durumda error oluşur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = --2;//error
		
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
15.12.2022 Perşembe

/*
 * temel karsılastırma operatorleri 6 tanedir: == , != , <, >, <= , >=
 * bu operatorlerin hepsi iki operandlı ve araek durumundadır.
 * Bu operatörlerin yan etkisi yoktur.
 * Bu operatörlerin ürettiği deger boolean türdendir. 
 * Karşılaştırmanın sonucu dogru ise true, yanlış ise false degerini üretirler.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
			
		
		System.out.printf("%d > %d -> %b%n", a, b, a > b);
		System.out.printf("%d < %d -> %b%n", a, b, a < b);
		System.out.printf("%d >= %d -> %b%n", a, b, a >= b);
		System.out.printf("%d <= %d -> %b%n", a, b, a <= b);
		System.out.printf("%d == %d -> %b%n", a, b, a == b);
		System.out.printf("%d != %d -> %b%n", a, b, a != b);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metot çağırma operatörü
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add(10, 20) * 3;
		
		System.out.printf("result = %d%n", result);
	}
}

class NumberUtil{
	public static int add(int a, int b) 
	{
		return a + b;
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java da void bir metot çağrısı "void bir ifade (expression)" olarak ele alınır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.print(10, 20);
	}
}

class NumberUtil{
	public static void print(int a, int b) 
	{
		System.out.printf("%d, %d%n", a, b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * && operatörü
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() && Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return false;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * || operatörü
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * || operatörü
 * || operatörünün kısa devre davranışı (short circuit behavior). Kısa devre davranışı doğru sonuca en çabuk biçimde 
	ulaşacak şekilde çalışmaktır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * && operatörü
 * && operatörünün kısa devre davranışı (short circuit behavior). Kısa devre davranışı doğru sonuca en çabuk biçimde 
	ulaşacak şekilde çalışmaktır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return false;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	&& ve || operatörlerinde doğru sonuca en kısa yoldan ulaşabilmek için (yani kısa devre davranışı için) ifadenin
	önce sol tarafı yapılır. Yani bu operatörler işlem sırasında işlem önceliğine uymazlar. Ancak işlem önceliğine
	uyulursa, yani matematiksel olarak (ya da da kabaca kağıt üzerinde) elde edilen sonucu verirler. Şu cümle unutulmamalıdır:
	"&& ve || operatörleri doğru sonuca en kısa yoldan erişirler". Yani derleyici bu operatörler için buna yönelik kod
	üretir. 
	
	Aşağıdaki örnekte && operatörü || operatöründen yüksek öncelikli olmasına karşın önce || işlemi yapılır. Ancak && 
	operatörünün önceliğine göre işlem yapıldığında elde edilen sonuncun aynısı elde edilir 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar() && Sample.tar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return false;
	}
	
	public static boolean tar() 
	{
		System.out.println("tar");
		return false;
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte işlem sırası ile operatörlerin öncelik sırası aynıdır. Yine en soldaki önce yapılır. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() && Sample.bar() || Sample.tar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return false;
	}
	
	public static boolean tar() 
	{
		System.out.println("tar");
		return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bitsel AND (&) ve bitsel OR (|) operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerini işleme
	sokarak değer üretirler. Bu operatörler özel olarak boolean türden ifadeler ile kullanıldıklarında kısa devre 
	davranışı olmayan AND ve OR operatörleri olarak düşünülmelidir. Yine bu operatörler için de en soldaki ifade önce
	yapılır. 
	
	Aşağıdaki örnekte && ve || operatörlerleri kullanıldığında elde edilen sonucun aynısı üretilir. Ancak tüm metotlar
	çağrılır
 */

/*
logic and &&
bitsel and &
*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() | Sample.bar() & Sample.tar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return false;
	}
	
	public static boolean tar() 
	{
		System.out.println("tar");
		return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bitsel AND (&) ve bitsel OR (|) operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerini işleme
	sokarak değer üretirler. Bu operatörler özel olarak boolean türden ifadeler ile kullanıldıklarında kısa devre 
	davranışı olmayan AND ve OR operatörleri olarak düşünülmelidir. Yine bu operatörler için de en soldaki ifade önce
	yapılır. 
	
	Aşağıdaki örnekte && ve || operatörlerleri kullanıldığında elde edilen sonucun aynısı üretilir. Ancak tüm metotlar
	çağrılır
 */

/*
logic and &&
bitsel and &
*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //00000000000000000000000000001010
		int b = 11; //00000000000000000000000000001011
		int c;
		
		c = a & b;  //00000000000000000000000000001010
		
		System.out.printf("c = %d%n", c);
		
		c = a | b;  //00000000000000000000000000001011
		
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	& ve | operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerinin işleme sokarlar. 
	Aşağıdaki örnek durumu anlatmak için yazılmıştır. Bitsel operatörlere ilişkin ayrıntılar kullanımları burada
	ele alınmayacaktır 
 */

/*
logic and &&
bitsel and &
*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //00000000000000000000000000001010
		int b = 11; //00000000000000000000000000001011
		int c;
		
		c = a & b;  //00000000000000000000000000001010
		
		System.out.printf("c = %d%n", c);
		
		c = a | b;  //00000000000000000000000000001011
		
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Mantıksal DEĞİL (logical NOT) operatörünün doğruluk tablosu
	
	op			!op
	T			 F
	F			 T
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		flag = !flag;
		
		System.out.printf("flag = %b%n", flag);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Mantıksal DEĞİL (logical NOT) operatörünün doğruluk tablosu
	
	op			!op
	T			 F
	F			 T
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		boolean a = true;		
		
		a = !flag;
		
		System.out.printf("flag = %b%n", flag);
		System.out.printf("a = %b%n", a);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Atama (=) operatörü iki operandlı araek durumunda bir operatördür. Bu operatörün birinci operandı değişken olmalıdır.
	Operatörün şüphesiz yan etkisi vardır. Bu operatör sağdan sola (right associative) öncelikli gruptadır. Atama operatörünün
	ürettiği değer ikinci operandına ilişkin değerdir
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		
		a = b = c = 10;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte atama operatörünün operandının değişken olmamasından dolayı error oluşur
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 2, b = 3, c = 5;
		
		(a = b) = c = 10;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte atama operatörünün operandının değişken olmamasından dolayı error oluşur
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 2, b = 3, c = 5;
		
		a = (b = c) = 10; //error
		

		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte parantezin konması ve konmaması aynı anlamdadır. Çünkü atama operatörü sağdan sola önceliklidir
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 2, b = 3, c = 5;
		
		a = b = (c = 10);
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	İşlemli atama operatörlerinin genel biçimi:
	
	 <ifade1> <op>= <ifade2> ifadesinin yaklaşık karşılığı
	 
	 <ifade1> = <ifade1> <op> <ifade2>
	 
	 a += b; //a = a + b;
	 a -= b; //a = a - b;
	 a *= b; //a = a * b;
	 a /= b; //a = a / b;
	 a %= b; //a = a % b;
	 
	 İşlemli atama operatörlerinin ürettiği değer yine birinci operandına atanan değerdir
	 
	 Not: Aslında işlemli atama operatörlerinin genel biçimi tam olarak yukarıdaki gibi değildir. Bu konu
	 ileride ele alınacaktır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20;
		
		a += b;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	İşlemli atama operatörleri ifadeleri daha basit yazmak için tercih edilebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20, c = 30;
		
		a *= b + c; //a = a * (b + c)
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	 örnekte aynı seviyede olan *= ve += operatörleri "right associative" olduğunda işlem sağdan sola doğru
	yapılır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20, c = 30;
		
		a *= b += c; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Java 'da etkisiz ifadeler genel olarak error olusturur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		a - 2;
		
		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	ornekte error olusturmaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		Sample.foo();
	}
}

class Sample{
	public static void foo() {
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Noktalı virgül (;) sonlandırıcıdır (terminator). Genel olarak ifadeleri ayırmak için kullanılır. Java'da noktalı
	virgülden başka sonlandırıcı karakter yoktur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		++a;System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte ++ operatörünün ürettiği değer artırılmamış değer olduğundan a sonuçta 10 olur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		a = a++;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte ++ operatörünün ürettiği değer artırılmış değer olduğundan a sonuçta 11 olur. Direk ++ uygulandığındaki
	değerle aynıdır. Bu anlamda aşağıdaki kodun etkisi yoktur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		a = ++a;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
	Deyimler (Statements):
	Bir programın çalıştırılan parçalarına denir. Bir program deyimlerin çalıştırılmasıyla çalışır. Java'da deyimler
	5(beş) gruba ayrılır:
	1. Basit deyimler (simple statements)
	2. Bileşik deyimler (compound statements)
	3. Bildirim deyimleri (declaration statements)
	4. Kontrol deyimleri (control statments)
	5. Boş deyim (null/empty statements)

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Basit deyim
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; 
		++a; //basit deyim
		System.out.printf("a = %d%n", a); //basit deyim
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bileşik deyim
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; 
		{//bileşik deyim
			++a; 
			//...
			{
				//..
				System.out.printf("a = %d%n", a); //basit deyim
			}
		}
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bildirim deyim
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;  //bildirim deyim 
		int b; //bildirim deyimi	
		
		//..
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Boş deyim. boş deyimin kullanıs durumları ileride ele alnıacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a; ;;;;;;
		//..
		
		;;;;;;;
		;;
		;
		;
		;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	if deyiminin genel biçimi:
	if (<boolean türden ifade>)
		<deyim>
	[
	else
		<deyim>
	}
	]
	
	if deyimi, varsa else kısmı ile birlikte tek bir deyimdir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0) {
			System.out.println("Çift sayı girdiniz");	
		} else {
			System.out.println("Tek sayı girdiniz");
		}
		
		System.out.println("Ali Tekrar yapiyormusun");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	if deyiminde bileşik deyimi kullanımı
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0) { 
			System.out.println("Çift sayı girdiniz");
			val /= 2;
	    }else
			System.out.println("Tek sayı girdiniz");
			val *= 2;
		
		System.out.println("Ali Tekrar yapiyormusun");
		System.out.printf("val = %d%n", val);

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	else kısmı olmayan if edyimi
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0)
			System.out.println("Çift sayı girdiniz");
		
		System.out.println("Ali Tekrar yapiyormusun");
		System.out.printf("val = %d%n", val);

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	if deyiminin parantezi sonuna yanlışlıkla noktalı virgül konması durumu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0);
			System.out.println("Çift sayı girdiniz");
			val /= 2;
			
		System.out.printf("val = %d%n", val);
		System.out.println("Ali Tekrar yapiyormusun");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte else bir if deyimine ait olmadığından error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		if (val % 2 == 0)
			;
			val /= 2;
		else
			val *= 2; 
			
		
		System.out.printf("val = %d%n", val);
		System.out.println("Ali Tekrar yapiyormusun");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki örnekte else kısmı içteki if deyimine aittir (dangling else)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		if (val > 0)
			if(val % 2 == 0)
				System.out.println("Pozitif ve çift bir sayı girdiniz : ");
			else
				System.out.println("Pozitif bir sayi girmelisiniz");
			
		System.out.println("Ali Tekrar yapiyormusun");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki örnekte else kısmı içteki if deyimine aittir (dangling else)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		if (val > 0)
			if(val % 2 == 0)
				System.out.println("Pozitif ve çift bir sayı girdiniz : ");
			else
				System.out.println("teksayi sayı girdiniz");
		else
			System.out.println("Pozitif bir sayi girmelisiniz");
		
		System.out.println("Ali Tekrar yapiyormusun");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	if deyiminin parantezinde boolean türden ifadeler için == ve != operatörleri kullanılması iyi bir teknik değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(val % 2 == 0);
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)//if(even == true)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	if deyiminin parantezinde boolean türden ifadeler için == ve != operatörleri kullanılması iyi bir teknik değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(val % 2 == 0);
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)//if(even != false)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte isEven metodunda if deyiminin else kısmına gerek yoktur. Çünkü akış return deyimine geldiğinde
	metot sonlanır yani isEven içerisinde bir sonraki deyime geçmez. Bu durumda else yazılması iyi bir teknik değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(NumberUtil.isEven(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		if(a % 2 == 0)
			return true;
		else 
			return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	yukarıdaki kodun iyi  teknikte yazılmış hali
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(NumberUtil.isEven(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		if(a % 2 == 0)
			return true;
		 
		return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	yukarıdaki kodun daha iyi  teknikte yazılmış hali
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(NumberUtil.isEven(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki örnekte geri dönüş değeri boolean olan bir metot çağrısı if deyiminde koşul ifadesi olarak kullanılmıştır 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(NumberUtil.isEven(val))
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte geri dönüş değeri boolean olan bir metot çağrısı if deyiminde koşul ifadesi olarak kullanılmıştır 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(!NumberUtil.isEven(val))
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte isOdd metodu için kod tekrarı yapılmadığına yani işi yapan başka bir metodun çağrıldığına dikkat ediniz.
	Yazılım geliştirmede "ZORUNLU OLMADIKÇA" kod tekrarı yapılmaması gerekir. Bu kavrama "DO NOT REPEAT YOURSELF" de denir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.isEven(val));
		System.out.println(NumberUtil.isOdd(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
	public static boolean isOdd(int a) 
	{
		return !isEven(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki *** ile belirtilen if deyimi else kısmı ile birlikte tek bir deyimdir. Bu if deyiminin else kısmında 
	başka bir if deyimi vardır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		else
			if(val == 0)
				System.out.println("Sıfır sayısını girdiniz");
			else
				System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
	Yukarıdaki örnek daha okunabilir/algılanabilir olarak aşağıdaki gibi yazılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		else if(val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		else
			System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki koşullar ayrık koşullardır. Bu durumda kod doğu çalışsa bile aşağıdaki gibi yazılmamalıdır. else-if
	biçiminde yazılması (yukarıdaki gibi) hem okunabilirdir hem de gereksiz yere kontrol edilmesi gibi durumlar oluşmaz.
	Aşağıdaki örnek şüphesiz kolay anlaşılırdır. Ancak büyük projelerde koşulların ayrık olup olmadığının anlaşılması
	aşağıdaki gibi bir yazımda zaman alabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		if(val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		if(val < 0)
			System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	yukarıdaki kod böyle yazılmalıydı if lerin birbiri ile ilişkili oldugundan 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		else if(val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		else if(val < 0)
			System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki koşullar ayrık oldugunda örnek özelinde else-if biçiminde kullanılması yanlış olur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 6)
			System.out.printf("val > 6%n");
		if(val > 11)
			System.out.println("val > 11%n");
		if(val > 21)
			System.out.printf("val > 21%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
20.12.2022 Salı

/*
 * Sınıf çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerin bulup ekrana yazdıran programı yazınız.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		EquationSolverApp.run();
	}
}

class EquationSolverApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci katsayiyi giriniz : ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci katsayiyi giriniz : ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("Üçüncü katsayiyi giriniz : ");
		double c = Double.parseDouble(kb.nextLine());
			
		EquationSolver.printRoots(a, b,c);
		
	}
}

class EquationSolver{
	
	public static void doWorkForDifferentRoots(double delta, double a, double b)
	{
		double x1, x2;
		double sqrtDelta = Math.sqrt(delta);
		
		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);
	
		System.out.printf("x1 = %f,  x2 = %f%n", x1, x2);
	}
	
	public static void doWorkForSameRoots(double a, double b)
	{
		double x = -b / (2 * a);
		System.out.printf("x1 = x2 = %f%n", x);
	}
	
	public static double getDelta(double a, double b, double c)
	{
		return b* b - 4 * a * c;
	}
	
	public static void printRoots(double a, double b, double c)	
	{
		double delta = getDelta(a, b, c);
		
		if(delta > 0)
			doWorkForDifferentRoots(delta, a, b);
		else if (delta == 0)
			doWorkForSameRoots(a, b);
		else 
			System.out.println("Gercek kök yok");
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Sınıf çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerin bulup ekrana yazdıran programı yazınız.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		EquationSolverApp.run();
	}
}

class EquationSolverApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci katsayiyi giriniz : ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci katsayiyi giriniz : ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("Üçüncü katsayiyi giriniz : ");
		double c = Double.parseDouble(kb.nextLine());
			
		EquationSolver.printRoots(a, b,c);
		
	}
}

class EquationSolver{
	
	public static void doWorkForDifferentRoots(double delta, double a, double b)
	{
		double x1, x2;
		double sqrtDelta = Math.sqrt(delta);
		
		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);
	
		System.out.printf("x1 = %f,  x2 = %f%n", x1, x2);
	}
	
	public static double getDelta(double a, double b, double c)
	{
		return b* b - 4 * a * c;
	}
	
	public static void printRoots(double a, double b, double c)	
	{
		double delta = getDelta(a, b, c);
		
		if(delta >= 0)
			doWorkForDifferentRoots(delta, a, b);
		else 
			System.out.println("Gercek kök yok");
	}
	
}



-----------------------------------------------------------
-----------------------------------------------------------
Döngü deyimleri (loop statements)

Bir işin yenilenmeli olarak yapılması için kullanılan kontrol deyimlerine denir. 
Java'da göngü deyimleri şunlardır:

1. while döngü deyimleri
	- Kontrolün başta yapıldığı while döngü deyimi (while döngüsü)
	- Kontrolün sonra yapıldığı while döngü deyimi (do-while döngüsü)
2. for göngü deyimi
3. for-each döngü deyimi (enhanced for loop, range based loop)

Not: Bu aşamadan itibaren tüm konular içerisinde "while döngü deyimi" ya da "while döngüsü" dendiğinde
	"kontrolün başta yapıldığı while döngü deyimi" anlaşılmalıdır. "Kontrolün sonra yapıldığı while döngü deyimi" için 
	kısaca "do-while döngüsü" ya da "do-while döngü deyimi" diyeceğiz 
-----------------------------------------------------------
-----------------------------------------------------------

Kontrolün başta yapıldığı while döngü deyiminin genel biçimi:

	while(<koşu ifadesi>)
		<deyim>
		
	koşuş ifadesi boolean türden olmalıdır. Bu döngü ifadesi true oldugu sürece yenilenir. 
	Akış while döngüsüne geldiğinde koşul kontrolü yapılır ve koşul gerçekleşmezse (yani tur degeri üretilmezse) döngüye girilmez.

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  while döngüsü ile n-kez dönen kalıp (dizi uyumlu)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  while döngüsü ile n-kez dönen kalıp (dizi uyumlu)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i++);
		}
		
		System.out.printf("%ni = %d%n", i);
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * while döngüsü ile n-kez dönen kalıp (dizi uyumlu)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = n - 1;
		
		while (i >= 0) {
			System.out.printf("%d ", i);
			--i;
		}
		
		System.out.printf("%ni = %d%n", i);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   while döngüsü ile n-kez dönen kalıp
	 n = 3 olsun 
	 Döngünün içerisindeyken her adımda basılan n değerleri	: 2, 1, 0
	 Sayaç													: 1, 2, 3
	 Döngü sonrası n										: -1	
	 
	 Buu kalıpta n-nin döngüden sonra değerinin değiştiğine, dolayısıyla döngü öncesindeki değeri kaybettiğimize dikkat 
	 ediniz. Bu kalıp kullanılacaksa ve döngüden sonra n-nin eki değerine ihtiyaç olacaksa döngü öncesinde n değeri
	 saklanmalıdır. Bu kalıbın zorunlu olarak kullanılacağı bir durum yoktur. Ancak baz programcılar bu kalıbı kullanabilirler.
	 Böyle bir kodun anlaşılması açısında döngü kalıbı bilinmelidir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
	
		while (n-- > 0) {
			System.out.printf("%d ", n);
		}
		
		System.out.printf("%ni = %d%n", n);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   while döngüsünün parantezi içerisinde bir değişkene bir metodun geri dönüş değerinin atanıp atanan değerin kontrolüne
	 ilişkin algoritmalar yazılabilmektedir. Okunabilirliği/algılanabilirliği etkilemediği sürece aşağıdaki gibi bir kod
	 yazılabilir. 
	 
	 Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. while döngüsünün parantezi
	 içerisinde atama işleminin önceliklendirildiğine dikkat ediniz.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int sum = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) 
			sum += val;
		
		System.out.printf("Toplam : = %d%n", sum);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   while döngüsünün parantezi içerisinde bir değişkene bir metodun geri dönüş değerinin atanıp atanan değerin kontrolüne
	 ilişkin algoritmalar yazılabilmektedir. Okunabilirliği/algılanabilirliği etkilemediği sürece aşağıdaki gibi bir kod
	 yazılabilir. 
	 
	 Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. while döngüsünün parantezi
	 içerisinde atama işleminin önceliklendirildiğine dikkat ediniz.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int sum = 0;
		int val;
		
		System.out.print("Bir sayi giriniz: ");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) { 
			sum += val;
			System.out.print("Bir sayi girinz, taki sıfır girene kadar: ");
		}
			
		
		System.out.printf("Toplam : = %d%n", sum);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayıların pozitif ve negatif olanlarının ayrı ayrı toplamını
 *   bulan programı yazınız. Programda hiç negatif veya pozitif sayı girilmemişse uygun mesajlar verilmelidir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindPosNegSumApp.run();
	}
}

class FindPosNegSumApp {
	public static void printResult(int posSum, int negSum) 
	{
		if(posSum != 0)
			System.out.printf("Pozitif sayıların toplamı : %d%n", posSum);
		else
			System.out.println("Hiç pozitif sayi girmediniz!!!");
		
		if(negSum != 0)
			System.out.printf("Negatif sayıların toplamı : %d%n", negSum);
		else
			System.out.println("Hiç negatif sayi girmediniz!!!");
	}
	
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int posSum = 0, negSum = 0;
		int val;
		
		System.out.print("Bir sayi giriniz: ");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) 
			if(val > 0)
				posSum += val;
			else
				negSum += val;
			
		printResult(posSum, negSum);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Yukarıdaki pozitif ve negatif sayıların kaçar tane girildiğini bulan koda çevir.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		FindPosNegSumApp.run();
	}
}

class FindPosNegSumApp {
	public static void printResult(int posSum, int negSum, int posCount, int negCount) 
	{
		if(posSum != 0)
			System.out.printf("%d tane Pozitif sayıların toplamı : %d%n",posCount, posSum);
		else
			System.out.println("Hiç pozitif sayi girmediniz!!!");
		
		if(negSum != 0)
			System.out.printf("%d tane Negatif sayıların toplamı : %d%n",negCount, negSum);
		else
			System.out.println("Hiç negatif sayi girmediniz!!!");
	}
	
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int posSum = 0, negSum = 0;
		int posCount = 0, negCount = 0;
		int val;
		
		System.out.print("Bir sayi giriniz: ");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) 
			if(val > 0) {
				posSum += val;
				++posCount;
			} else {
				negSum += val;
				negCount++;
			}
		printResult(posSum, negSum, posCount, negCount);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli
 *   metodu NumberUtil isimli sınıf içerisinde yazınız ve alttaki kod ile test ediniz.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitsTest.run();
	}
}

class CountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		System.out.print("Bir sayı giriniz:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			System.out.printf("%d sayısının basamak sayısı:%d%n", val, NumberUtil.countDigits(val));
			System.out.println("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamak sayısı:%d%n", NumberUtil.countDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		if(val == 0) // !val ile aynı şet val == 0
			return 1;
		
		int count = 0;
		
		while (val != 0) {
			++count;
			val /= 10;
		}
		
		return count;
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamakları toplamını döndüren sumDigits isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz. Metot negatif sayılar için basamakları 
	 toplamını pozitif olarak döndürecektir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		SumDigitsTest.run();
	}
}

class SumDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		System.out.print("Bir sayı giriniz:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			System.out.printf("%d sayısının basamakları toplamı:%d%n", val, NumberUtil.sumDigits(val));
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamakları toplamı:%d%n", NumberUtil.sumDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int sumDigits(int val) 
	{
		int sum = 0;
		
		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}
		
		return sum;
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının tersini döndüren reversed isimli metodu NumberUtil
	 sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	 
	 123 -> 3 -> 3 * 10 + 2 = 32 -> 32 * 10 + 1 = 321
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		ReversedTest.run();
	}
}

class ReversedTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		System.out.print("Bir sayı giriniz:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			System.out.printf("%d sayısının tersi:%d%n", val, NumberUtil.reversed(val));
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının tersi:%d%n", NumberUtil.reversed(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int reversed(int val) 
	{
		int result = 0;
		
		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}
		
		return result;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  while döngü deyiminde yanlışlıkla noktalı virgül kullanılması durumu
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		
		int sum = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0);
			sum += val;
		
		System.out.printf("Toplam : %d%n", sum);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Kontrolün sonra yapıldığı while döngü deyiminin (do-while döngüsü) genel biçimi:
	 
	 do
	 	<deyim>
	 while (<boolean türden ifade>);
	 
	 Akış do-while döngüsüne geldiğinde koşul kontrolü yapılmaz. İlk adım çalıştırıldıktan sonra kontrol yapılmaya başlar.
	 Yani bu döngü deyiminin en az bir kez çalıştırılacağı garanti altındadır. while döngü deyimi kadar sık kullanılmasa da
	 okunabilirliği/algılanabilirliği artırmak ve algoritmanın sadeleştirilmesi için tercih edilebilir. Ancak bu döngü
	 deyimi gereksiz yere kullanıldığında okunabilirliği/algılanabilirliği azaltır. Buna dikkat edilmelidir

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		do {
			System.out.printf("%d ", i);
			++i;
		} while (i < val);
		
		System.out.printf("%nDöngü sonrası :i =  %d%n", i);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
27.12.2022 Salı  11.Ders


/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu 
	 NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 Not: İleride daha iyisi yazılacaktır

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitisTest.run();		
	}
}

class CountDigitisTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(val));
			System.out.println("Bir sayi giriniz : ");
		}
		System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(0));
		
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
			
		} while (val != 0);
		
		return count;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   do- while döngüsünün deyimi içerisinde bildirilen bir değişken faaliyet alanı (scope)
 *   kuralları gereği koşul ifadesi içerisinde kullanılamaz

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		do {
			System.out.print("Bir sayı giriniz:");	
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   yukarıdaki problemi bu şekilde çözümleriz

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		do {
			System.out.print("Bir sayı giriniz:");	
			val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *    Sonsuz döngü (inifinite loop): Koşul ifadesinden dolayı sonlanmayan döngülere denir. Bu durumda hiç sonlanmayan 
	 bir döngü de sonsuz döngüdür. Tersine sonsuz döngü olarak tasarlanmış bir döngü sonlanabilecek şekilde yazılabilir

 */

/*
 * while döngüsü ile sonsuz döngü aşağaıdaki gibi oluşturulabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		while (true) {
			//..
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu 
	 NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 Not: İleride daha iyisi yazılacaktır


	Örnekteki test kodunu sonsuz döngüye çevirelim? nasıl yaparız?
	
	Run metodunu 0 geldiğinde return deyimi ile sonlandırırsak sonsuz döngüden çıkarız
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitisTest.run();		
	}
}

class CountDigitisTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.println("Bir sayi giriniz : ");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(val));
			
			if(val == 0) {
				System.out.println("0 degeri geldi, run metodu sonlandırıldı");
				return;
			}
		}	
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
			
		} while (val != 0);
		
		return count;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------	 
	 for döngü deyiminin genel biçimi:
	 for ([1.kısım]; [2.kısım]; [3.kısım])
	 	<deyim>
	 	
	 1.kısım: Akış for döngü deyimine geldiğinde bir kez yapılacak kısımdır 
	 
	 2.kısım: for döngü deyiminin koşul ifadesine ilişkin kısımdır. Buraya yazılacak ifadenin boolean türden olması gerekir.
	 Bu ifade true olduğu sürece döngü yinelenir. Akış for döngü deyimine geldiğinde 1.kısım yapıldıktan sonra kontrol 
	 yapılır
	 
	 3.kısım: Döngünün bir adımı tamamlandığında bir sonraki adıma geçmek için yapılacak kontrolden hemen önce yapılır
----------------------------------------------------------------------------------------------------------------------*/

/*
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (i = 0; i < n; i++) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for dongu deyimi tersten 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (i = n - 1; i >= 0; --i) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for dongu deyimi  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (i = 0; i < n; i += 2) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for dongu deyimi  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for döngü deyiminin birinci kısmında bildirilen değişken for döngü deyimi boyunca görülebilirdir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) {
			System.out.printf("%d ", i);
		}
		
		System.out.printf("%d ", i); //error
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Aşağıdaki for döngü deyiminde "aynı faaliyet alanı içerisinde aynı isimde birden fazla yerel değişken bildirimi
	 geçersizdir" kuralı dolayısıyla error oluşur 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) { //error
			System.out.printf("%d ", i);
		}
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Aşağıdaki for döngü deyimi "farklı faaliyet alanları içerisinde aynı isimde yerel değişenler bildirilebilir" kuralı
	 dolayısıyla geçerlidir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Döngü değişkenin değeri döngüden sonra kullanılmayacaksa döngü değişkeniş bildiriminin birinci kısımda yapılması
	 daha iyi bir tekniktir. Bu durumda döngü değişkeninin döngüden önce bildirilmesi döngüden sonra değişkenin değerinin 
	 kullanıldığı algısını oluşturur. Yani okunabilirlik/algılabilirlik artırılmış olur 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngü deyiminde yanlışlıkla noktalı virgül konması durumu. Aşağıdaki örnekte error oluşmaz  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		int i = 0;
		
		for (i = n - 1; i > 0; --i); 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngü deyiminde yanlışlıkla noktalı virgül konması durumu. Aşağıdaki örnekte neden error oluşur?  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; ++i); 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsü ile n-kez dönen döngü kalıbı (dizi uyumlu)  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; ++i) 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsü ile n-kez dönen döngü kalıbı (dizi uyumlu)  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = n - 1; i >= 0; --i) 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsü ile n-kez dönen döngü kalıbı 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 1; i <= n; ++i) 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsünün birinci ve üçüncü kısmında virgül ayracı ile birden fazla ifade yazılabilir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 1, k = 20; i <= n && k >= 0; ++i, --k) 
			System.out.printf("{i : %d, k : %d}%n", i, k);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsünün birinci ve üçüncü kısmında virgül ayracı ile birden fazla ifade yazılabilir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		int i = 0;
		
		for (System.out.println("Birinci kısım"); i < 5; System.out.println("Üçüncü kısım"), ++i) 
				System.out.println("Deyim");
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *   for döngüsünün birinci kısmında değişken bildirimi yapılmışsa başka bir ifade yazılamaz
 */
package orhn;

public class App {
	public static void main(String [] args)
	{		
		for (System.out.println("Birinci kısım"), int i = 0; i < 5; System.out.println("Üçüncü kısım"), ++i) 
				System.out.println("Deyim");
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *  for döngüsünün birinci kısmında bildirilen değişkenler aynı türden olmalıdır  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{		
		for (int i = 0, double k = 3.4; i < 5 && k > 3.8; ++i, k -= 0.03) 
				System.out.printf("{i : %d, k : %f}%n", i, k);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Aşağıdaki döngü deyimini inceleyiniz 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		int i;
		double k;
		
		for (i = 0, k = 3.4; i < 5 && k > 3.8; ++i, k -= 0.03) 
				System.out.printf("{i : %d, k : %f}%n", i, k);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünün gücü: Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;
		int val;
		
		for(System.out.println("Sayıları girmeye başlayınız:"), System.out.print("Bir sayi giriniz:");
				(val = Integer.parseInt(kb.nextLine())) != 0; sum += val, System.out.print("Bir sayı giriniz: "))
			;
		
		System.out.printf("Toplam: %d%n", sum);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Hiç sonlanmayacak sanılan ancak öyle olmayan bir döngü örneği. Örnekte i değeri azalarak  -2147483648 değerine yani
	int türünün en küçüçük değeirne geldiğinde artık bir azaltıldığında 2147483647 değeri elde edilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		int i;

		for(i = 0; i < 10; --i)
			;
		
		System.out.printf("i = %d%n", i);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde birinci kısmın boş bırakılması durumu
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		int i = 0;

		for(; i < n; ++i)
			System.out.printf("i = %d%n", i);
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde üçüncü kısmın boş bırakılması durumu
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		

		for(int i = 0; i < n;)
			System.out.printf("i = %d%n", i++);
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde birinci üçüncü kısmın boş bırakılması durumu while döngü deyimine benzetilebilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;

		for(; i < n;)
			System.out.printf("i = %d%n", i++);
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde ikinci kısmın boş bırakılması durumunda sonsuz döngü oluşur. Yani koşul her zaman gerçeklenir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for(int i = 0; ;++i)
			System.out.printf("i = %d%n", i);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsü ile sonsuz döngü oluşturmak için okunabilirlik/algılanabilirlik açısından 3 kısmın da boş bırakılması 
	iyi bir tekniktir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		for(;;)
			;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
    Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu 
	 NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitisTest.run();		
	}
}

class CountDigitisTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
					
			System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(val));
		
			if(val == 0) {
				System.out.println("Ali Tekrarlar nasıl gidiyor?");
				return;
			}
		}		
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
			
		} while (val != 0);
		
		return count;
	}
}


/**********************************************************************************************
    Sınıf Çalışması: Parametresi ile aldığı int türden a ve b değerleri için a'nın b-inci kuvvetini döndüren pow isimli
	 metodu NumberUtil sınıfı içerisinde yazınız.
	 Açıklamalar:
	 - Math sınıfının pow metodu kullanılmayacaktır
	 - Metot negatif b değerleri için 1(bir) değerine geri dönecektir
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Taban sayısı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
					
			System.out.print("Üst sayısı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			
			System.out.printf("pow(%d, %d) = %d%n", a, b, NumberUtil.pow(a, b));
		
			if(a == 0) {
				System.out.println("Ali Tekrarlar nasıl gidiyor?");
				return;
			}
		}		
	}
}

class NumberUtil{
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		for(int i = 0; i < b; i++)
			result *= a;
		
		return result;
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong 
	 isimli metodu NumberUtil sınıfı içerisinde yazınız.
	 
	 Açıklamalar:
	 - Bir sayının her basamağının basamak sayıncı kuvvetleri toplandığında sayının kendisine eşitse bu sayıya Armstrong
	 sayısı denir. Örneğin:
	 
	 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153
	 
	 - Kuvvet alma işlemi için yazılmış olan pow metodunu kullanınız
	 
	 - Sayı negatif ise Armstrong sayısı kabul etmeyiniz
	 
	 - Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
	 ekrana yazdırarak test ediniz	
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		for(int a = 1; a <= 999999; ++a)
			if (NumberUtil.isArmstrong(a)) 	
					System.out.println(a);
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isArmstrong(int a)
	{
		return a >= 0 && getDigitsPowSum(a) == a;
	}
	
	public static int getDigitsPowSum(int a)
	{
		int n = countDigits(a);
		int total = 0;

		while (a != 0) {
			total += pow(a % 10, n);
			a /= 10;
		}
		
		return total;
	}
	
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		for(int i = 0; i < b; i++)
			result *= a;
		
		return result;
		
	}
	
	public static int countDigits(int a) {
		int count = 0;
		
		do {
			++count;
			a /= 10;
			
		}while(a != 0);
			
		return  count;	
	}
	
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 
	 (Yavaş çözüm)
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		for(int a = -10; a <= 1000; ++a)
			if (NumberUtil.isPrime(a)) 	
					System.out.printf("%d ", a);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		
		for(long i = 2; i <= half; ++i)
			if(a % i == 0)
				return false;
		
		return true;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 
	 Kural: Bir sayı karekökünden küçük olan asal sayıların hiçbirisine bölünmüyorsa asaldır
	 (Hızlı çözüm)
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		for(int a = -10; a <= 1000; ++a)
			if (NumberUtil.isPrime(a)) 	
					System.out.printf("%d ", a);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;

		for(long i = 11; i * i <= a; i += 2)
			if(a % i == 0)
				return false;
		
		return true;
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 
	 Kural: Bir sayı karekökünden küçük olan asal sayıların hiçbirisine bölünmüyorsa asaldır
	 (Hızlı çözüm)
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
				
		System.out.println(NumberUtil.isPrime(1_000_003));
		System.out.println(NumberUtil.isPrimeSlow(1_000_003));
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;

		int count = 0;
		for(long i = 11; i * i <= a; i += 2) {
			count++;
			if(a % i == 0)
				return false;
			
		}
		
		System.out.printf("isPrime:count = %d%n", count);
		return true;
		
	}
	
	public static boolean isPrimeSlow(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		int count = 0;
		
		for(long i = 2; i <= half; ++i) {
			count++;
			if(a % i == 0)
				return false;
		}
		
		System.out.printf("isPrime:count = %d%n", count);
		return true;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	 metodu yazınız ve aşağıdaki kod ile test ediniz.
	 
	 Açıklamalar: 
	 	- isPrime metodunun hızlı versiyonunu hızlı olduğu bilinciyle getPrime metodunu yazınız
	 	- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();		
	}
}

class GetPrimeTest{
	public static void run() 
	{
				
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Bir sayi giriniz : ");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0) {
				return;
			}
			
			System.out.printf("%d. asal sayi: %d%n", n, NumberUtil.getPrime(n));
		}
	}
}

class NumberUtil{
	public static int getPrime(int n) 
	{
		int val = 2;
		
		for(int i = 2, count = 0; count < n; ++i)
			if(isPrime(i)) {
				++count;
				val = i;
			}
		
		return val;
	}
	
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;


		for(long i = 11; i * i <= a; i += 2) {
			if(a % i == 0)
				return false;	
		}
		
		return true;
		
	}
	
	public static boolean isPrimeSlow(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		
		for(long i = 2; i <= half; ++i) {
			if(a % i == 0)
				return false;
		}
		
		return true;
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	 metodu yazınız ve aşağıdaki kod ile test ediniz.
	 
	 Açıklamalar: 
	 	- isPrime metodunun hızlı versiyonunu hızlı olduğu bilinciyle getPrime metodunu yazınız
	 	- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();		
	}
}

class GetPrimeTest{
	public static void run() 
	{
				
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Bir sayi giriniz : ");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0) {
				return;
			}
			
			System.out.printf("%d. asal sayi: %d%n", n, NumberUtil.getPrime(n));
		}
	}
}

class NumberUtil{
	public static int getPrime(int n) 
	{
		int count = 0;
		int val = 2;
		
		for(;;) {
			if(isPrime(val))
				++count;
			
			if(count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;


		for(long i = 11; i * i <= a; i += 2) {
			if(a % i == 0)
				return false;	
		}
		
		return true;
		
	}
	
	public static boolean isPrimeSlow(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		
		for(long i = 2; i <= half; ++i) {
			if(a % i == 0)
				return false;
		}
		
		return true;
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının faktoriyel değerini döndüren factorial isimli metodu
	 NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	 Açıklamalar:
	 - Faktoriyel işlemi aşağıdaki gibidir: 
		 0! = 1
		 1!= 1
		 2! = 1 * 2
		 3! = 1 * 2 * 3
		 
		 ...
		 
		 n! = 1 * 2 * 3 * ... * (n - 1) * n
	 
	 - Negatif sayılar için faktoriyel değeri 1 olarak döndürelecektir	
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		FactorialTest.run();		
	}
}

class FactorialTest {
	public static void run()
	{		
		for (int n = -1; n <= 25; ++n)
			System.out.printf("%d! = %30d%n", n, NumberUtil.factorial(n));
	}
}

class NumberUtil{
	public static int factorial(int n) 
	{
		int result = 1;
		
		for(int i = 2; i <= n; ++i)
			result *= i;
		
		return result;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     içiçe döngüler
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		for(int i = 0; i < 5; ++i)
			for(int k = 10; k >= 0; --k)
				System.out.printf("(%d, %d)%n",i ,k);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     	Programcılar bazen tek bir döngü varsa da döngü içerisinde çağrılan metot veya metotlar içerisinde döngü kullanılmışsa
	içiçe döngü olacak şekilde bir kod yazmış olurlar
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		for(int i = 0; i < 5; ++i)
			Util.print(i);
	}
}

class Util{
	public static void print(int i) {
		for(int k = 10; k >= 0; --k)
			System.out.printf("(%d, %d)%n",i ,k);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     	3 basamaklı Armstrong sayılarının iç içe döngü ile bulunması
     	
     	abc -- 1-9  0-9 0-9
     	
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		for(int a = 1; a <= 9; ++a)
			for(int b = 0; b <= 9; ++b)
				for(int c = 0; c <= 9; ++c)
					if(a * a * a + b * b * b + c * c * c == 100 * a + 10 * b + c)
						System.out.printf("%d%d%d%n", a, b, c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------
	break deyimi döngüyü, döngünün koşul ifadesinden bağımsız olarak sonlandırmak (kırmak) için kullanılır. break deyimi
	döngü deyimleri ile kullanılır ve ileride göreceğimiz "switch" deyiminde de kullanılır. Bunlar dışında kullanımı error
	oluşturur.
	
	break deyiminin genel biçimi:
	break [etiket ismi];
     	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	break deyiminin etiketsiz kullanımında akış break deyimine geldiğinde döngü sonlandırılır. Döngüden sonraki koddan
	devam edilir. break hangi döngü içerisinde etiketsiz kullanılmışsa o döngü sonlandırılır. 
	Aşağıdkai örnekte klavyden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. Sıfır girildiğinde break
	deyimi ile döngü sonlandırılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayiları girmeye başlayınız : ");
		
		int sum = 0;
		
		for(;;) {
			System.out.print("Bir sayi giriniz : ");
			int a = Integer.parseInt(kb.nextLine());
			
			if(a == 0)
				break;
			
			sum += a;
		}
		System.out.printf("Toplam: %d%n", sum);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	 metodu yazınız ve aşağıdaki kod ile test ediniz.
	 
	 Açıklamalar: 
	 	- isPrime metodunun hızlı versiyonunu hızlı olduğu bilinciyle getPrime metodunu yazınız
	 	- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();
	}
}

class GetPrimeTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());			
			
			if (n <= 0)				
				break;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.getPrime(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");	
	}
}

class NumberUtil {
	public static int getPrime(int n)
	{
		int count = 0;
		int val = 2;
		
		for (;;) {
			if (isPrime(val))
				++count;
			
			if (count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long a)
	{
		if (a <= 1)
			return false;
		
		if (a % 2 == 0)
			return a == 2;
		
		if (a % 3 == 0)
			return a == 3;		
		
		if (a % 5 == 0)
			return a == 5;
		
		if (a % 7 == 0)
			return a == 7;

		for (long i = 11; i * i <= a; i += 2)
			if (a % i == 0)
				return false;
		
		return true;		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	break deyimi yalnızca kendi döngüsünü sonlandırır. Aşağıdaki örnekte içteki döngüde bir koşul gerçekleştiğinde 
	 dıştaki döngünün de sonlandırılması flag değişken kullanılarak yapılmıştır. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean breakAllFlag = false;
		
		for(int i = 5; i < 10; ++i) {
			for(int k = 20; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if((i + k) % 6 == 0) {
					breakAllFlag = true;
					break;
				}
			}
			
			if(breakAllFlag)
				break;
		}
		
		System.out.println("Tekrar yapalım güzel olur Ali...");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------	 
	Etiketli break (labeled break) deyiminde gerektiğinde sonlandırılacak döngü deyiminin başında bir etiket bildirimi
	yapılır. Etiket bildiriminin genel biçimi:
		<etiket ismi>:
	Etiket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Genellikle programcılar etiket isminin
	tamamını büyük harfle, birden fazla kelimeden oluşuyorsa da araya alttire karakterini koyarak isimlendirirler.
	Yukarıdaki program aşağıdaki gibi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
	
		EXIT_LOOP:
		for(int i = 5; i < 10; ++i) {
			for(int k = 20; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if((i + k) % 6 == 0)
					break EXIT_LOOP;
			}
		}
		
		System.out.println("Tekrar yapalım güzel olur Ali...");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Etiketli break (labeled break) deyiminde gerektiğinde sonlandırılacak döngü deyiminin başında bir etiket bildirimi
	yapılır. Etiket bildiriminin genel biçimi:
		<etiket ismi>:
	Etiket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Genellikle programcılar etiket isminin
	tamamını büyük harfle, birden fazla kelimeden oluşuyorsa da araya alttire karakterini koyarak isimlendirirler.
	Yukarıdaki program aşağıdaki gibi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
	
		EXIT_LOOP:
		for(int i = 5; i < 100; ++i) 
			EXIT_INNER_LOOP:
			for(int j = 0; j < 100; ++j)
				for(int k = 20; k >= 0; --k) {
					System.out.printf("(%d, %d, %d)%n", i, j, k);
					
					if((i + j + k) % 10 == 0)
						break;
					
					if((i + j + k) % 6 == 0)
						break EXIT_INNER_LOOP;
					
					if((i + j + k) % 11 == 0)
						break EXIT_LOOP;
					
				}
		
		System.out.println("Tekrar yapalım güzel olur Ali...");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	continue deyimi döngüyü değil döngünün o anki adımını sonlandırmak için kullanılır. continue deyiminin de etiketli
	biçimi vardır. Ancak yapısal programlama ve nesne yönelimli programlama tekniği açısından kullanımı tavsiye edilmez.
	continue deyiminin etiketsiz biçimi break deyimi kadar sık kullanılmasa da bazı durumlarda okunabilirlik/algılanabilirlik
	açısından tercih edilebilir. continue yalnızca döngü deyimlerinde kullanılabilir.
	
	Aşağıdaki örnekte 1 ile klavyeden girilen sayı arasındaki çift sayılar continue deyimi kullanılarak ekrana bastırılmıştır. 
	Şüphesiz daha kolay yazılabilir. Sadece continue deyiminin çalışma prensibinin anlaşılabilmesi için bu şekilde 
	yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for(int i = 1; i <= n; ++i) {
			if(i % 2 != 0)
				continue;
			
			System.out.printf("%d ", i);
		}
		
		System.out.println("\nÇok çalışalım Erken uyuyalım Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulması iskeleti yazıldı
	(ileri daha iyisi yazılacak)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if(option < 1 || option > 5) {
				System.out.println("\"Geçersiz seçenek\"");
				continue;
			}
			
			if(option == 5)
				break;
			
			doWorkFor(option);
		}
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{
		if(option == 1)
			doWorkForInsert();
		else if(option == 2)
			doWorkForUpdate();
		else if(option == 3)
			doWorkForDelete();
		else
			doWorkForList();
		
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulması iskeleti yazıldı
	(ileri daha iyisi yazılacak)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if(1 <= option && option <= 5) {
				if(option == 5)
					break;
				
				doWorkFor(option);
			} 
			else
				System.out.println("\"Geçersiz seçenek\"");
		}
		System.out.println("Teşekkürler");
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{
		if(option == 1)
			doWorkForInsert();
		else if(option == 2)
			doWorkForUpdate();
		else if(option == 3)
			doWorkForDelete();
		else
			doWorkForList();
		
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı n sayısı için n-inci Fibonacci sayısını döndüren fibonacciNumber isimli 
	metodu NumberUtil sınıfı içerisinde ve aşağıdaki kod ile test ediniz
	Açıklama:
		- Fibonnaci sayıları
			0 1 1 2 3 5 8 13 21 34 ...
		- Metot pozitif olmayan n değerleri için kontrol yapmayacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		FibonacciNumberTest.run();
	}
}

class FibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n < 1)
				break;
			
			System.out.printf("%d. Fibonacci sayısı:%d%n", n, NumberUtil.fibonacciNumber(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int fibonacciNumber(int n) 
	{
		if(n <= 2)
			return n - 1;
		
		int prev1 = 1, prev2 = 0, val = 0;
		
		for(int i = 2; i < n; ++i) {
			val = prev1 + prev2;
			prev2 = prev1;
			prev1 = val;
		}
		
		return val;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayıdan büyük ilk Fibonacci sayısına geri dönen nextFibonacciNumber
	isimli metodu yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		NextFibonacciNumberTest.run();
	}
}

class NextFibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			if (val < -999)
				break;
			
			System.out.printf("%d. sayısından büyük ilk Fibonacci sayısı:%d%n", val, NumberUtil.nextFibonacciNumber(val));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int nextFibonacciNumber(int val) 
	{
		if (val < 0)
			return 0;
		
		int prev1 = 1, prev2 = 0, next;
		
		for (;;) {
			next = prev1 + prev2;
			
			if (next > val)
				return next;
			
			prev2 = prev1;
			prev1 = next;
		}
	}	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminin genel biçimi:
	switch (<ifade>) {
		case <sabit ifadesi>:
			<deyim>
		case <sabit ifadesi>:
			<deyim>
			
		...
		
		[
		default:
			<deyim>
		]			
	}
	
	Bu deyimde parantez içerisindeki ifade temel türler için tamsayı türlerinden biri veya char türünden olabilir.
	Temel türler dışında String veya enum türlerinden de olabilir. Bu türler ileride ele alınacaktır. switch 
	deyiminin default kısmı zorunlu değildir.
	
	
	Anahrtat Notlar: switch deyimi Java 12'den itibaren ifade (expression) olarak da kullanılabilmektedir. Bu tarz 
	deyimlere/ifadelere "ifadesel deyim (expression statement)". switch'in ifade olarak kullanılmasına yönelik sentaks
	ve semantik eklentiler yapılmıştır. İleride ele alınacaktır.  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki switch deyiminin if deyimi karşılığı:
	
	if (postalCode == 414100)
		System.out.println("Gebze");
	else if (postalCode ==  37100)
		System.out.println("Kastamonu Merkez");
	else
		System.out.println("Geçersiz posta kodu");
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) {
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100:
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

04.01.2023 - Çarşamba - 13.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde default kısım olmak zorunda değildir. Aşağıdaki switch deyiminin if deyimi karşılığı:
	
	if (postalCode == 414100)
		System.out.println("Gebze");
	else if (postalCode ==  37100)
		System.out.println("Kastamonu Merkez");

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) {
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100:
			System.out.println("Kastamonu Merkez");
			break;

		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde default bölümün yerinin önemi yoktur. Şüphesiz sona koymak iyi bir tekniktir	

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) {
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100:
			System.out.println("Kastamonu Merkez");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: switch deyimin bölümlerinden (case ve default) çok fazla işlem yapılması okunabilirlik/algılanabilirlik
	açısından iyi bir teknik değildir. Bu durumda metot yazıp ilgili bölümlerde çağırmak gerekir. Bunun için net bir sınır
	olmasa da 3-4 satırı geçen kodların yazılmaması gerekir 
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde case bölümlerine ilişkin ifadeler sabit ifadesi olmalıdır 

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		int code = 37100;
		
		switch (postalCode) {

		case 414100:
			System.out.println("Gebze");
			break;
		case code: //sentaks hatası
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde aynı değere sahip birden fazla case bölümü geçersizdir  
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		
		switch (postalCode) {

		case 414100:
			System.out.println("Gebze");
			break;
		case 37100: //error
			System.out.println("Kastamonu Merkez");
			break;
		case 37100: //error
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde parantez içerisindeki ifade ve case bölümlerine ilişkin sabitlerin temel türler için tamsayı 
	türlerinden biri veya char türünden olabilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		double postalCode = Double.parseDouble(kb.nextLine());
		
		
		switch (postalCode) { //error
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100: 
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde parantez içerisindeki ifade ve case bölümlerine ilişkin sabitlerin temel türler için tamsayı 
	türlerinden biri veya char türünden olabilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		double postalCode = Double.parseDouble(kb.nextLine());
		
		switch (postalCode) { //error
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100: 
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminin aşağı düşme (fall through) özelliği vardır. Bir case bölümü veya default bölüm yakalandığında
	aşağıya doğru engelleyen herhangi bir deyim görülüncüye kadar her deyim çalıştırılır. break deyimi switch deyimini
	sonlandırmak için kullanılır. Başka engelleyici deyimler de olabilir. Aşağıdaki kodu inceleyiniz
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) { 
		case 41410:
			System.out.println("Gebze");
		case 37100: 
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminin aşağı düşme (fall through) özelliği vardır. Bir case bölümü veya default bölüm yakalandığında
	aşağıya doğru engelleyen herhangi bir deyim görülüncüye kadar her deyim çalıştırılır. break deyimi switch deyimini
	sonlandırmak için kullanılır. Başka engelleyici deyimler de olabilir. Aşağıdaki kodu inceleyiniz
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) { 
		default:
			System.out.println("Geçersiz posta kodu");
		case 41410:
			System.out.println("Gebze");
		case 37100: 
			System.out.println("Kastamonu Merkez");
			break;

		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch deyiminin aşağı düşme özelliğinden yararlanılmıştır. Aşağıdaki örnekteki 212 ve 216 kodları
	için yapılışın daha kısa bir yönetimi yoktur 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int code = Integer.parseInt(kb.nextLine());
		
		switch (code) { 
		case 212:
		case 216:
			System.out.println("İstanbul");
			break;
		case 312: 
			System.out.println("Ankara");
			break;
		case 284: 
			System.out.println("Edirne");
			break;
		default:
			System.out.println("Geçersiz telefon kodu");
		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch deyiminin aşağı düşme özelliğinden yararlanılmıştır. Aşağıdaki örnekteki 212 ve 216 kodları
	için yapılışın daha kısa bir yönetimi yoktur 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int code = Integer.parseInt(kb.nextLine());
		
		switch (code) { 
		case 212:
			System.out.println("Avrupa");
		case 216:
			System.out.println("İstanbul");
			break;
		case 312: 
			System.out.println("Ankara");
			break;
		case 284: 
			System.out.println("Edirne");
			break;
		default:
			System.out.println("Geçersiz telefon kodu");
		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulamasının iskeleti
	(ileride daha iyisi yazılacaktır)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if(1 <= option && option <= 5) {
				if(option == 5)
					break;
				
				doWorkFor(option);
			} 
			else
				System.out.println("\"Geçersiz seçenek\"");
		}
		System.out.println("Teşekkürler");
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{		
		switch (option) {
		case 1:
			doWorkForInsert();
			break;
		case 2:
			doWorkForUpdate();
			break;
		case 3: 
			doWorkForDelete();
			break;
		case 4:
			doWorkForList();
			break;
		default:
			System.out.println("\"Geçersiz seçenek\"");
		}
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Hangi metot içerisinde olursak olalım programı sonlandırmak için System sınıfının exit isimli metodu kullanılabilir.
	Bu metot parametre olarak int türden ismine "çıkış kodu (exit code)" denilen ve JVM ve oradan da işletim sistemine 
	iletilen bir değer alır. Bu değerin çoğu zama n önemi olmaz. Bazı durumlarda okunabilirliği artırmak için başarı veya
	başarısızlığa yönelik belirlenen değerler argüman olarak verilir. main normal sonlandığında JVM ve oradan da işletim
	sistemine 0 (sıfır) çıkış kodu iletilir. Çıkış kodunun nerede kullanılacağı burada ele alınmayacaktır.
	 
	Aşağıdaki örnekte geçersiz giriş durumunda program sonlandırılmıştır. Örnek exit metodunu göstermek amaçlı bu şekilde
	yazılmıştır  
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		SqrtApp.run();
	}
}

class SqrtApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		double val = Double.parseDouble(kb.nextLine());
		
		if(val < 0) {
			System.out.println("Geçersiz giriş");
			System.exit(1);
		}
		
		System.out.printf("sqrt(%f) = %f%n", val, Math.sqrt(val));
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulamasının iskeleti
	(ileride daha iyisi yazılacaktır)  
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();	
			doWorkFor(Integer.parseInt(kb.nextLine()));
		}
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{		
		switch (option) {
		case 1:
			doWorkForInsert();
			break;
		case 2:
			doWorkForUpdate();
			break;
		case 3: 
			doWorkForDelete();
			break;
		case 4:
			doWorkForList();
			break;
		case 5:
			doWorkForQuit();
		default:
			System.out.println("\"Geçersiz seçenek\"");
		}
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForQuit()
	{
		System.out.println("---------------------------------");
		System.out.println("Teşekkürler");
		System.out.println("\"Tekrar Sizleri Mekanımızda Görmek İsteriz\"");
		System.out.println("---------------------------------");
		System.exit(0);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden yıl değerinin artık yıl (leap year) olup olmadığını test eden
	isLeapYear isimli metodu yazınız ve aşağıdaki kod ile test ediniz
		
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		IsLeapYearTest.run();
	}
}

class IsLeapYearTest{
	public static void run() 
	{
		for(int y = 1900; y <= 2023; ++y)
			if(DateUtil.isLeapYear(y))
				System.out.println(y);
	}
}


class DateUtil{
	public static boolean isLeapYear(int year) 
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin geçerli olup olmadığını
	test eden isValidDate isimli metodu yazınız ve aşağıdaki kod ile test ediniz
	(İleride daha iyisi yazılacaktır)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		IsValidDateTest.run();
	}
}

class IsValidDateTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz : ");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if(day == 0)
				break;
			
			if(DateUtil.isValidDate(day, month, year))
				System.out.printf("%02d/%02d/%04d tarihi geçerlidir%n", day, month, year);
			else
				System.out.println("Geçersiz tarih");
			
		}
	}
}

class DateUtil{
	public static boolean isValidDate(int day, int month, int year)
	{
		 return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days = 31;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if(isLeapYear(year))
				++days;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year) 
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin yılın kaçıncı günü 
	olduğunu döndüren getDayOfYear metodunu yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Yılın kaçıncı günü olduğuna ilişkin algoritma için aşağıdaki örneklerini inceleyiniz:
			01.03.2020 -> 1 + 29 + 31 = 61
			01.03.2022 -> 1 + 28 + 31 = 60
			31.12.2020 -> 31 + 30 + 31 + ... + 29 + 31 = 366
			31.12.2022 -> 31 + 30 + 31 + ... + 28 + 31 = 365
			
			- İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		GetDayOfYearTest.run();
	}
}

class GetDayOfYearTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz : ");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if(day == 0)
				break;
			
			int dayOfYear = DateUtil.getDayOfYear(day, month, year);
			
			if(dayOfYear != -1)
				System.out.printf("%02d/%02d/%04d tarihi yılın %d. günüdür%n", day, month, year, dayOfYear);
			else
				System.out.println("Geçersiz tarih");
			
		}
	}
}

class DateUtil{
	
	public static int getDayOfYear(int day, int month, int year) 
	{
		if(!isValidDate(day, month, year))
			return -1;
		
		int totalDays = day;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += 28;
			if(isLeapYear(year))
				++totalDays;
		case 1:
			totalDays += 31;
		}
		
		
		return totalDays;
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{
		 return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if(isLeapYear(year))
				++days;
		default:
			days = 31;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year) 
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli metodu yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden 
		elde edilen kalan ile belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ..., 6 ise "cumartesi"
		günlerine karşılık gelir
		
		- 1.1.1900 öncesindeki tarihler geçersiz sayılacaktır
		- getDayOfWeek metodu ile birlikte 
				
		- İleride daha iyisi yazılacaktır parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin
		hafta sonu olup olmadığınıu test eden isWeekend ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız.
		Bu iki metot tarih geçerlilik kontrolü yapmayacaktır
		
		- İleride daha yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		GetDayOfYearTest.run();
	}
}

class GetDayOfYearTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz : ");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if(day == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);
		}
	}
}

class DateUtil{
	public static void printDateTR(int day, int month, int year) 
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		if(dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}
		
		switch (dayOfWeek) {
		case 0:
			System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
			break;
		case 1:
			System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
			break;
		case 2:
			System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);
			break;
		case 3:
			System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);
			break;
		case 4:
			System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
			break;
		case 5:
			System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);
			break;
		case 6:
			System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);
			break;
		}
		
		if(isWeekend(day, month, year))
			System.out.println("Bugün haftasonu....");
		else
			System.out.println("Bugün haftaiçi....");
	}
	
	public static int getDayOfWeek(int day, int month, int year) 
	{
		int totalDays;
		
		if(year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;
		
		for(int y = 1900; y < year; ++y) {
			totalDays += 365;
			if(isLeapYear(year))
				++totalDays;
		}
		
		return totalDays % 7;
	}
	
	public static boolean isWeekend(int day, int month, int year) 
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		return dayOfWeek == 0 || dayOfWeek == 6;
	}
	
	public static boolean isWeekday(int day, int month, int year) 
	{
		return !isWeekend(day, month, year);
	}
	
	public static int getDayOfYear(int day, int month, int year) 
	{
		if(!isValidDate(day, month, year))
			return -1;
		
		int totalDays = day;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += 28;
			if(isLeapYear(year))
				++totalDays;
		case 1:
			totalDays += 31;
		}
		
		
		return totalDays;
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{
		 return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if(isLeapYear(year))
				++days;
		default:
			days = 31;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year) 
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Java 12 ile birlite "preview" olarak "switch expression" dile dahil edilmiştir. Bu durumda switch deyimi artık 
	ifade biçiminde de kullanılacak şekilde sentaks ve samantik olarak geliştirilmiştir. switch deyiminin bu şekilde 
	kullanımı "switch expression statement" olarak da adlandırılabilir. Yani kabaca switch expression semantiği switch 
	statement biçiminde de kullanılabilir. Java dünyasında Java 8, Java 11 ve Java 17 LTS (Long Term Support) olarak
	kullanıldığından switch expression henüz çok yaygınlaşmamıştır. Çünkü halen en çok kullanılan sürümler Java 8 ve 
	Java 11'dir. Java'nın LTS dışında kalan ara sürümlerinin desteği daha çabuk bittiğinden ticari uygulamalarda pek
	kullanılmazlar. Üstelik şu anki durumda Android sistemlerinde Java 17 kullanımı oldukça kısıtlıdır. Ağırlıklı olarak
	Java 8 ve Java 11 kullanılmaktadır  
	
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
Aşağıdaki örnekte switch expression, statement biçiminde kullanılmıştır. switch statement karşılığı:

switch (postalCode) {
case 34387:
	System.out.println("Mecidiyeköy");
	break;
case 67100:
	System.out.println("Zonguldak Bahçelievler");
	break;
default:
	System.out.println("Geçersiz posta kodu");
}

Dikkat edilirse switch expression için aşağı düşme özelliği yoktur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
public static void main(String [] args)
{		
	java.util.Scanner kb = new java.util.Scanner(System.in);		
	
	for (;;) {
		System.out.print("Posta kodunu giriniz:");
		int postalCode = Integer.parseInt(kb.nextLine());
		
		if (postalCode <= 0)
			break;
		
		switch (postalCode) {
		case 34387 -> System.out.println("Mecidiyeköy");			
		case 67100 -> System.out.println("Zonguldak Bahçelievler");
		default -> System.out.println("Geçersiz posta kodu");
		}
	}		
	
	System.out.println("Tekrar yapıyor musunuz?");
	
}
}



/*----------------------------------------------------------------------------------------------------------------------	 
Aşağıdaki örnekte switch expression'ın değeri bir değişkene atanmıştır. Eşdeğeri aşağıdaki gibidir:
	
	switch (code) {
	case 212:
	case 216:
		plate = 34;
		break;
	case 232:
		plate = 35;
		break;
	case 372:
		plate = 67;
		break;
	default:
		plate = -1;
	}
	
	Dikkat edilirse switch expression için aşağı düşme özelliği yoktur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
public static void main(String [] args)
{		
	java.util.Scanner kb = new java.util.Scanner(System.in);		

	for (;;) {
		System.out.print("Posta kodunu giriniz:");
		int code = Integer.parseInt(kb.nextLine());
		
		if (code <= 0)
			break;
		
		int plate = switch (code) {
				case 212, 216 ->  34;
				case 232 -> 35;
				case 372 -> 67;
				default -> -1;			
		};			
				
		if (plate != -1)
			System.out.printf("Plaka:%d%n", plate);
		else
			System.out.println("Geçersiz plaka");
	}			
	
	System.out.println("Tekrar yapıyor musunuz?");
	
}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch expression'ın değeri metoda argüman olarak geçilmiştir	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;		
			
					
			Util.doWorkForPlate(
					switch (code) {
						case 212, 216 ->  34;
						case 232 -> 35;
						case 372 -> 67;
						default -> -1;			
					}			
			);
		}
		
	}
}

class Util {
	public static void doWorkForPlate(int plate)
	{
		if (plate != -1)
			System.out.printf("Plaka:%d%n", plate);
		else
			System.out.println("Geçersiz plaka");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch expression, statemnet olarak kullanıldığından default kısmı zorunlu değildir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int postalCode = Integer.parseInt(kb.nextLine());
			
			if (postalCode <= 0)
				break;
			
			switch (postalCode) {
			case 34387 -> System.out.println("Mecidiyeköy");			
			case 67100 -> System.out.println("Zonguldak Bahçelievler");			
			}
		}	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch expression'ın değeri kullanıldığından default bölüm (default case) zorunludur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = switch (code) { //error
					case 212, 216 ->  34;
					case 232 -> 35;
					case 372 -> 67;								
			};			
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Klasik switch deyiminin yield anahtar sözcüğ ile değer üretmesi yani expression olarak kullanılması sağlanabilir. Bu da
	yine Java 12 ile dile eklenmiştir. yield kullanıldığında aşağı düşme olmaz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = 
					switch (code) {
					case 212:
					case 216: yield 34;
					case 232: yield 35;
					case 372: yield 67;
					default: yield -1;													
			};			
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Klasik switch deyiminin yield anahtar sözcüğ ile değer üretmesi yani expression olarak kullanılması sağlanabilir. Bu da
	yine Java 12 ile dile eklenmiştir. yield kullanıldığında aşağı düşme olmaz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = 
					switch (code) {
					case 212:
					case 216:
						System.out.println("İstanbul");
						yield 34;
					case 232: System.out.println("izmir");  yield 35;
					case 372: yield 67;
					default: yield -1;													
					};			
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte "case 212, 216" bölümü için yield zorunludur. Ayrıca küme parantezi yani, bileşik deyim zorunludur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = 
					switch (code) {
					case 212, 216 -> {
						System.out.println("İstanbul");
						yield 34;
					}
						
					case 232 -> 35;
					case 372 -> 67;
					default -> -1;													
					};			
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch expression'ın ürettiği değer metoda geri dönüş değeri olarak verilmiştir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = Util.getPlateByCode(code);					
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}		
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class Util {
	public static int getPlateByCode(int code)
	{
		return switch (code) {
				case 212, 216 -> 34;					
				case 232 -> 35;
				case 372 -> 67;
				default -> -1;													
		};		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli metodu yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden 
		elde edilen kalan ile belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ..., 6 ise "cumartesi"
		günlerine karşılık gelir
		
		- 1.1.1900 öncesindeki tarihler geçersiz sayılacaktır
		- getDayOfWeek metodu ile birlikte 
				
		- İleride daha iyisi yazılacaktır parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin
		hafta sonu olup olmadığınıu test eden isWeekend ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız.
		Bu iki metot tarih geçerlilik kontrolü yapmayacaktır
		
		- İleride daha yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		GetDayOfWeekTest.run();		
	}
}

class GetDayOfWeekTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz?");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}
		
		switch (dayOfWeek) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
		case 2 -> System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);			
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);			
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);		
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);			
		}
		
		if (isWeekend(day, month, year))
			System.out.println("Bugün kurs var. Tekrar yaptınız mı?");
		else
			System.out.println("Kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız");
	}

	
	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;
		
		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;
		
		for (int y = 1900; y < year; ++y) {
			totalDays += 365;
			if (isLeapYear(y))
				++totalDays;
		}
		
		return totalDays % 7;
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		return dayOfWeek == 0 || dayOfWeek == 6;
	}
	
	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}
	
	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;
		
		int totalDays = day;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += 28;
			if (isLeapYear(year))
				++totalDays;
		case 1:
			totalDays += 31;			
		}
		
		return totalDays;
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{		
		return  1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);		
	}
	
	public static int getDays(int month, int year)
	{
		int days;
		
		days = switch (month) {
			case 4, 6, 9, 11 -> 30;		
			case 2 -> {			
				if (isLeapYear(year))
					yield 29;
				yield 28;
			}
			default -> 31;			
		};
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Menü uygulaması
		
		- İleride daha yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();	
			doWorkFor(Integer.parseInt(kb.nextLine()));
		}
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{		
	
		switch (option) {
		case 1 -> doWorkForInsert();
		case 2 -> doWorkForUpdate();
		case 3 -> doWorkForDelete();
		case 4 -> doWorkForList();
		case 5 -> doWorkForQuit();
		default ->System.out.println("\"Geçersiz seçenek\"");
		}
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForQuit()
	{
		System.out.println("---------------------------------");
		System.out.println("Teşekkürler");
		System.out.println("\"Tekrar Sizleri Mekanımızda Görmek İsteriz\"");
		System.out.println("---------------------------------");
		System.exit(0);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: Programcı ne zaman switch expression, ne zaman switch statement kullanmalıdır? Şüphesiz programcı 
	Java 12 öncesinde çalışıyorsa switch expression kullanamaz. Bu durumda programcı zorunlu olmadıkça, okunabilirlik 
	açısından bir sorun da yoksa switch expression tercih etmelidir
----------------------------------------------------------------------------------------------------------------------*/



-----------------------------------------------------------
-----------------------------------------------------------
05.01.2023 Perşembe - 14.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	Farklı Türlerin Birbirine Atanması (Tür dönüşümleri-Type Conversions)
	
	
	T1 ve T2 birer tür ismi olmak üzere T1 türünden, T2 türüne yapılan doğrudan atama işlemine T1 türünden T2 türüne
	"doğrudan dönüşüm (implicit conversion)" denir. Atama işlemi de aynı zamanda bir dönüşümdür. Örneğin bu işlem
	
		T1 a;
		T2 b;
		
		b = a;
	
	şeklinde belirtilebilir. Konu içerisinde anlatılcak olan istisna durumlar dışında tüm atama işlemleri için bu tanım
	geçerlidir. İstisna durumlar ayrıca ele alınacaktır
	
	Yukarıdaki atama işleminde T1 türüne "kaynak tür (source type)", T2 türüne de "hedef tür (target type)" denir. Java'da
	kaynak türden hedef türe implicit dönüşümün (atamanın) yapılıp yapılamayacağı derleme zamanında belirlenir. Kaynak türe
	ilişkin değere çalışma zamanında bakılarak karar verilemez. Zaten çoğu zaman da bu değer derleme zamanında bilinemez. 
	Yani hangi türlerin hangi türlere atanıp atanamayacağı bellidir. 
	
	Java'da genel olarak bilgi kaybına yol açmayacak doğrudan dönüşümler geçerlidir
	
	Anahtar Notlar: Java Language Specification'da temel türler arasında, uzunluk (size) olarak büyük olan türden, uzunluk
	olarak küçük olan türe yapılan dönüşüme "daraltma dönüşümü (narrowing conversion)", uzunluk olarak küçük olan türden 
	büyük olan türe	yapılan dönüşüme "genişletme dönüşümü (widening conversion)" denir.
	
	Doğrudan dönüşüme ilişkin ayrıntılar aşağıda anlatılacaktır
	

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Farklı Türlerin Birbirine Atanması (Tür dönüşümleri-Type Conversions)
	
	
	Aşağıdaki örnekte long türüne ilişkin değer çalışma zamanında belirlenir. Dolayısıyla derleyici istese de bu değeri
	bilemez. Derleyici açısından kural "long türünden int türüne doğrudan dönüşüm geçersizdir" biçimindedir. Dolayısıyla
	error oluşur
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayigiriniz : ");
		long a = Long.parseLong(kb.nextLine());
		
		int b;
		
		b = a; //error
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte long türüne ilişkin değer belli olsa da derleyici açısından bu bir değişkendir ve "long türünden
	int türüne doğrudan atama geçersizdir" kuralı uygulanır
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 10;
		
		int b;
		
		b = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan atama geçerlidir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		long b;
		
		b = a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan dönüşümde küçük tamsayı türüne ilişkin değer pozitif veya sıfır
	ise sayının yüksek anlamlı yeni bit değerleri 0(sıfır) ile beslenir. Eğer sayı negatif ise sayının işaretinin korunması
	için yüksek anlamlı bit değerleri 1(bir) ile beslenir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		short a = Short.parseShort(kb.nextLine());
		
		int b;
		
		b = a; 
		
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = 0x%04X%n", a);

		System.out.printf("b = %d%n", b);
		System.out.printf("b = 0x%08X%n", b);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Hiçbir türden char türüne doğrudan dönüşüm yapılamaz
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 67;
		char ch;
		
		ch = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Hiçbir türden char türüne doğrudan dönüşüm yapılamaz
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		byte a = 67;
		char ch;
		
		ch = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki kurala istisna olarak "char türü sınırları içerisinde kalan VE int türden olan bir sabit char türüne
	doğrudan atanabilir"
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = 67;

		System.out.printf("ch = %c%n", ch);
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki kurala istisna olarak "char türü sınırları içerisinde kalan VE int türden olan bir sabit char türüne
	doğrudan atanabilir"
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 67;
		char c1, c2, c3;
		c1 = -67; //error
		c2 = a; //error
		c3 = 67L; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	short türünden char türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		short a;
		char c;
		
		a = 10;
		
		c = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden short türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		char a;
		short c;
		
		a = 10000;
		
		c = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Anımsanacağı gibi Java'da byte ve short türden sabit yoktur. Ancak "sınırlar içerisinde olması koşuluyla int türden
	bir sabit byte/short türüne atanabilir"
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		short a;
		byte b;
		byte c;
		 
		a = 10;
		b = 24;
		c = -129; //error
		c = 45L; //error
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıda anlatılan byte, short ve char türlerine ilişkin istisna kurallar geri dönüş değerinin geçici değişkene
	yapılan atama işlemi için de geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		
	}
}


class Sample{
	public static short foo() 
	{
		return 10;
	}
	
	public static char bar() 
	{
		return 22;
	}
	
	public static byte tar() 
	{
		return 102;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıda anlatılan byte, short ve char türlerine ilişkin istisna kurallar metot çağrısında argümanlardan 
	parametrelere yapılan atama işleminde geçersizdir. Bu durumun detayları ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		Sample.foo(10);  
		Sample.bar(2);
		Sample.tar(23);
	}
}


class Sample{
	public static void foo(short a) 
	{
		//
	}
	
	public static void bar(char a) 
	{
		//
	}
	
	public static void tar(byte a) 
	{
		///
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden kendisinden uzunluk olarak büyük tüm türlere doğrudan atama geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'D';
		double b;
		
		b = c;
		
		System.out.printf("b = %f%n", b);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Bütün tamsayı türlerinden gerçek sayı türlerine doğrudan atama geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 3_000_000_000L;
		float b;
		
		b = a;
		
		System.out.printf("b = %f%n", b);
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Gerçek sayı türlerinden tamsayı türlerine doğrudan atama geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 55.656;
		long b;
		
		b = a; //error
		
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	float türünden double türüne doğrudan atama geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 55;
		double b;
		
		b = a; 		
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	double türünden float türüne doğrudan atama geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 55;
		float b;
		
		b = a; //error		
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte sabitin sonuna F konmazsa sabit double türden olduğundan atama geçersiz olur. Aşağıdaki örneği
	çalıştırarak yuvarlama hatasını gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 55.2F;
		
		System.out.printf("a = %.12f%n", a);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	boolean türünden herhangi bir türe doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean a = false;
		int b;
		
		b = a;
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Herhangi bir türden boolean türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 123;
		boolean b;
		
		b = a; //error
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------
    Temel türler için doğrudan dönüşüm (implicit conversion) tablosu:
    byte	-> short, int, long, float, double
    short	-> int, long, float, double
    int		-> long, float, double
    long	-> float, double
    float	-> double
    char	-> int, long, float, double
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesi otomatik tür dönüşümü:
	İki operandlı bir operatör için derleyici önce operandların türüne bakar. Operandlar farklı türdense ve işlem
	geçerliyse, ortak bir türe dönüştürülerek işlem yapılır. Hatta bazı durumlarda iki tür aynı olsa bile ikisini de farklı
	türe dönüştürür. Yani derleyici buna yönelik kodlar üretir. Bu dönüştürmeye "işlem öncesi otomatik tür dönüşümü" denir.
	
	Bu kuralın özeti "genel olarak küçük türe ilişkin değer büyük türe dönüştürülür. Sonuç büyük türden çıkar
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		long b;
		long c;
		
		a = 10;
		b = 22;
		c = a + b;
		
		System.out.printf("c = %d%n", c);
	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Her iki operand da byte, short veya char türlerindense ikisi birden işlem öncesinde int türüne dönüştürülür ve sonuç
	int türden çıkar. Buna "integral/integer promotion" denir
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		short a;
		short b;
		short c;
		
		a = 10;
		b = 22;
		
		c = a + b; //error
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Her iki operand da byte, short veya char türlerindense ikisi birden işlem öncesinde int türüne dönüştürülür ve sonuç
	int türden çıkar. Buna "integral/integer promotion" denir
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		short a;
		byte b;
		short c;
		
		a = 10;
		b = 22;
		
		c = a + b; //error
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bölme işleminde her iki operand da tamsayı türlerine ilişkinse sonuç tamsayı türünden çıkar. Bölme işlemi yapılır, 
	elde edilen değerin noktadan sonraki kısmı atılır
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 4;
		double c;
		
		c = a / b;
		
		System.out.printf("c = %f%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir gerçek sayı türü ile bir tamsayı türü işleme sokulduğunda dönüşüm gerçek sayı türüne doğrudur. Yani tamsayı türüne
	ilişkin değer gerçek sayı türüne dönüştürülür. Sonuç o gerçek sayı türünden çıkar
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 10.4F;
		long b = 4;
		float c;
		
		c = a + b;
		
		System.out.printf("c = %f%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türü ile büyük tamsayı türü işleme sokulduğunda dönüşüm büyük tamsayı türüne doğrudur. Sonuç büyük
	tamsayı türünden çıkar. 
	Dikkat: Integral promotion bu kuralın dışındadır
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 4;
		long c;
		
		c = a + b;
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	boolean türü hiçbir tür ile işleme sokulamaz
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean a = false;
		long b = 4;
		long c;
		
		c = a + b; //error
		
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	char türü herhangi bir tür ile işleme sokulabilir. Bu durumda char türüne ilişkin değer diğer türe dönüştürülür.
	Dikkat: Yine integral promotion bu durumun dışındadır
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 21;
		char c = 'D';
		int result;
		
		result = a + c; 
		
		System.out.println(result);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesinde otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratan
	kodu üretir. Örnekte derleyici ** ile belirtilen işlem için aşağıdakine benzer bir kod üretecektir:
		long temp = b;
		c = a + temp;
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 21;
		int b = 12;
		long c;
		
		c = a + b; //**
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesinde otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratan
	kodu üretir. Örnekte derleyici ** ile belirtilen işlem için aşağıdakine benzer bir kod üretecektir:
		int temp1 = a;
		int temp2 = b;
		c = temp1 + temp2;
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		short a = 21;
		byte b = 12;
		int c;
		
		c = a + b; //**
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Tür dönüştürme (type cast) operatörü:
	Tür dönüştürme operatörü özel amaçlı, tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Tür dönüştürme
	operatörünün genel biçimi:	
		(<hedef tür ismi>)<ifade>
		
	Bu operatör operandına ilişkin ifadenin hedef türe dönüştürüldükten sonra elde edilen değeri üretir. Tür dönüştürme
	operatörü ile yapılan dönüşüme "explicit conversion" denir. Genel olarak implicit olarak geçersiz olan dönüşümler 
	tür dönüştürme operatörü ile yapılabilir. Şüphesiz bu durumda bilgi kaybı oluşabilir. Bu bilgi kaybının nasıl olacağı da
	bellidir ve ileride ele alınacaktır
	
	implicit olarak geçerli olan dönüşümler için de tür dönüştürme operatörü kullanılabilir. Gerekli olduğu durumlar 
	vardır. 
	
	Anahtar Notlar: Tür dönüştürme operatörünün sentaks ve semantik olarak zorunlu olması durumu genel olarak 
	"işlem doğrudan yapılsaydı problem olabilirdi. Bu sebeple derleyici bunu doğrudan yapmamazı istemiyor. Biz yapmak
	istersek tür dönüştürme operatörü kullanarak derleyiciye durumun farkındayım bana izin ver" anlaşılmalıdır
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 21;
		int b = 12;
		double c;
		
		c = (double)a / b;
		
		System.out.printf("c = %f%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Tür dönüştürme operatörü
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 10;
		int b;

		b = (int)a;
		
		System.out.printf("b = %d%n", b);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	implicit olarak geçerli olan dönüşümler için de tür dönüştürme operatörü kullanılabilir. Aşağıdaki örnekte bunun
	bir anlamı yoktur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b;

		b = (long)a;
		
		System.out.printf("b = %d%n", b);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türünden küçük tamsayı türüne yapılan explicit dönüşümde kaynak türe ilişkin değer hedef türün
	sınırları içerisinde kalıyorsa bilgi kaybı oluşmaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 10;
		int b;

		b = (int)a;
		
		System.out.printf("b = %d%n", b);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türünden küçük tamsayı türüne yapılan explicit dönüşümde kaynak türe ilişkin değer hedef türün
	sınırları içerisinde kalmıyorsa bilgi kaybı oluşur. Çünkü bu işlem yüksek anlamlı byte değerlerinin atılması
	biçiminde yapılır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 1_000_000_000_000L;  // 010101010010101010100101010100101
		int b;     

		b = (int)a;               //101010100101010100101
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %X%n", b);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte bilgi kaybı oluşabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		long a = Long.parseLong(kb.nextLine());
		int b;     

		b = (int)a;        
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %016X%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %08X%n", b);
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	short türünden char türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		short a = Short.parseShort(kb.nextLine());
		char b;     

		b = (char)a;        
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %04X%n", a);
		System.out.printf("(int)b = %04X%n", (int)b);
		System.out.printf("b = %c%n", b);
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden short türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		char a = '\uF0AC';
		short b;     

		b = (short)a;        
		
		System.out.printf("(int)a = %X%n", (int)a);
		System.out.printf("(int)a = %d%n", (int)a);
		System.out.printf("a = %c%n", a);
		System.out.printf("b = %X%n", b);
		System.out.printf("b = %d%n", b);
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	boolean türünden herhangi bir türe explicit dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b;
		
		b = (int)a; //error
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Herhangi bir türden boolean türüne explicit dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 1;
		boolean b;
		
		b = (boolean)a; //error
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	byte türünden char türüne explicit dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer int türüne dönüştürülür. İkinci
	aşamada yüksek anlamlı 2 byte atılarak char türüne dönüştürülür (widening and narrowing conversion). 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		byte a = 99;//1 byte  derleyici int 4 byte  0000000000000000000000101010101
		char c; //char 2 byte
		
		c = (char)a; // 000000101010101
		
		System.out.printf("a = %X%n", a);
		System.out.printf("(int)a = %08X%n", (int)a);
		System.out.printf("(int)c = %04X%n", (int)c);
		System.out.printf("c = %c%n", c);
	
	}
	
	
}



/*----------------------------------------------------------------------------------------------------------------------	 
	byte türünden char türüne explicit dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer int türüne dönüştürülür. İkinci
	aşamada yüksek anlamlı 2 byte atılarak char türüne dönüştürülür (widening and narrowing conversion). 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		//1001 1110   ---->  1111 1111 1111 1111 1111 1111 1001 1110
		
		//1111 1111 1001 1110
		
		byte a = -62;//1 byte 
		char c; //char 2 byte
		
		c = (char)a; 
		
		System.out.printf("a = %X%n", a);
		System.out.printf("(int)a = %08X%n", (int)a);
		System.out.printf("(int)c = %04X%n", (int)c);
		System.out.printf("c = %c%n", c);
	
	}
	
	
}



/*----------------------------------------------------------------------------------------------------------------------	 
	double türünden float türüne explicit dönüşümde bilgi kaybı olabilir. Bu durumda IEEE 754 standardına göre yuvarlama
	hataları oluşur ve değer float türünde temsil edilebilecek değer olarak elde edilir. Ayrıca sayı float sınırları dışında
	ise de aynı şekilde yapılır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 5.34; 
		float b;
		
		b = (float)a; 
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Gerçek sayı türünde tamsayı türüne (veya char türüne) yapılan explicit dönüşüm şu şekilde gerçekkeşir:
	- Sayının noktadan sonraki kısmı atılır
		- Elde edilen sayı hedef türün sınırları içerisinde kalıyorsa hedef türe atanır 
		- Elde edilen sayı hedef türün sınırları içerisinde kalmıyorsa
			- Hedef tür byte, short, int ve char türlerinden biriyse
				- Elde edilen değer int türü sınırları içerisindeyse int türüne dönüştürülür. Buradan elde edilen değer
				tamsayılar arasındaki dönüşüm kurallarına göre hedef türe atanır
				- Elde edilen değer int türü sınırları içerisinde değilse değerin pozitif ya da negatif olması durumuna
				göre int türünün en büyük veya en küçük değeri alınır ve hedef türe dönüştürülür
			- Hedef tür long ise
				- Elde edilen değer long türü sınırları içerisindeyse doğrudan atanaır				
				- Elde edilen değer long türü sınırları içerisinde değilse sayının pozitif veya negatif olması durumuna
				göre long türünün en büyük veya en küçük değeri alınır ve atanır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 348.34; 
		int b;
		
		b = (int)a; 
		
		System.out.printf("b = %d%n", b);
	
	}
	
	
}





package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 100.34; 
		byte b;
		
		b = (byte)a; 
		
		System.out.printf("b = %d%n", b);
	
	}	
}





package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 2345.34; 
		byte b;
		
		b = (byte)a; 
		
		System.out.printf("2345 = %08X%n", 2345);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	
	}	
}




package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = -2345.34; 
		byte b;
		
		b = (byte)a; 
		
		System.out.printf("-2345 = %08X%n", -2345);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	
	}	
}





package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = -1234.34; 
		short b;
		
		b = (short)a; 
		
		System.out.printf("-1234 = %08X%n", -1234);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	
	}	
}




package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.34; 
		int b;
		
		b = (int)a; 
		
		System.out.printf("5_000_000_000 = %08X%n", (int)5_000_000_000L);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %X%n", b);
	
	}	
}




package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = -5_000_000_000.34; 
		int b;
		
		b = (int)a; 
		
		System.out.printf("-5_000_000_000 = %08X%n", (int)-5_000_000_000L);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %X%n", b);
	
	}	
}




package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.34; 
		byte b;
		
		b = (byte)a; 
		
		System.out.printf("-5_000_000_000 = %08X%n", (int)5_000_000_000L);
		System.out.printf("2147483647 = %d, %08X%n", 2147483647, 2147483647);		
		System.out.printf("b = %d, %X%n", b, b);	
	
	}	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan int türden sayıların ortalamasını bulan programı yazınız.
	Açıklamalar: Toplam değeri ve toplam girilen değerlerin sayısı int olarak tutulacaktır 
	
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindAverageApp.run();	
	
	}	
}

class FindAverageApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Sayileri girmeye baslayınız : ");
		int sum = 0, count = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			sum += val;
			++count;
		}
		
		double average = (double)sum / count;
		System.out.printf("Ortalama : %f%n", average);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan int türden sayıların ortalamasını bulan programı yazınız.
	Açıklamalar: Toplam değeri ve toplam girilen değerlerin sayısı int olarak tutulacaktır 
	
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindAverageApp.run();	
	
	}	
}

class FindAverageApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Sayileri girmeye baslayınız : ");
		int sum = 0, count = 0;
				
		for(int a = 0; (a = Integer.parseInt(kb.nextLine())) != 0; ++count, sum += a)
			;
		
		double average = (double)sum / count;
		System.out.printf("Ortalama : %f%n", average);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());		
		long c;
		
		c = (long)a + b;
		
		System.out.printf("c = %d%n", c);		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	
	Aşağıdaki örnekte double türden sabit kullanıldığından işlem double olarak yapılır
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;
		
		for (int i = 0; i < 4; ++i) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			sum += a;
		}
		
		double avg = sum / 4.;
		
		System.out.printf("Ortalama:%f%n", avg);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	
	Aşağıdaki örnekte double türden sabit kullanıldığından işlem double olarak yapılır
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;
		
		for (int i = 0; i < 4; ++i) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			sum += a;
		}
		
		double avg = sum / 4D;
		
		System.out.printf("Ortalama:%f%n", avg);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	İşlemli atama operatörlerinin esas çalışma biçimi:
	
	T1 a;
	T2 b;
	
	a op= b => a = (T1)(a op b)
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{		
		int a = 10;
		int b = 20;
		
		a += Math.sqrt(b); //a = (int)(a + Math.sqrt(b));
		
		
		//...
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Bir sayının basamak sayısının log10  ile bulunması 
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		int count = 1;
		
		if (a != 0)
			count = (int)Math.log10(Math.abs(a)) + 1;
	
		System.out.printf("%d sayısının basamak sayısı:%d%n", a, count);	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong 
	 isimli metodu NumberUtil sınıfı içerisinde yazınız.
	 
	 Açıklamalar:
	 - Bir sayının her basamağının basamak sayıncı kuvvetleri toplandığında sayının kendisine eşitse bu sayıya Armstrong
	 sayısı denir. Örneğin:
	 
	 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153	 
	 
	 - Sayı negatif ise Armstrong sayısı kabul etmeyiniz
	 
	 - Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
	 ekrana yazdırarak test ediniz	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{
		for (int a = -10; a <= 999999; ++a)
			if (NumberUtil.isArmstrong(a))
				System.out.println(a);	
	}
}

class NumberUtil {
	public static boolean isArmstrong(int a)
	{
		return a >= 0 && getDigitsPowSum(a) == a;				
	}
	
	public static int getDigitsPowSum(int a)
	{
		int n = countDigits(a);
		int total = 0;
		
		while (a != 0) {
			total += Math.pow(a % 10, n);
			a /= 10;					
		}
		
		return total;
	}	
	
	public static int countDigits(int a)
	{
		if (a == 0)
			return 1;
		
		return (int)Math.log10(Math.abs(a)) + 1;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
10.01.2023 Salı - 15.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	 Koşul Operatörü (conditional operator): Koşul operatörü özel amaçlı, üç operandlı (ternary) ve araek durumunda
	 bir operatördür. Operatörün genel biçimi:
	 
	 <operand1> ? <operand2> : <operand3>
	 
	 
	 operand1: boolean türden bir ifade olamalıdır. 
	 
	 
	 if(a < b)
	 	min = a;
	 else
	 	min = b
	 	
	 	
	 	bu ilişkiyi koşul operatörü ile yapabilirmiyim?
	 
	  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	 if(a < b)
	 	min = a;
	 else
	 	min = b;
	 	
	 	bu ilişkiyi koşul operatörü ile yapabilirmiyim?
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int min;
		
		 min = a < b ? a: b;
		 
		 System.out.printf("min(%d, %d) = %d%n", a, b, min);
	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int result;
		
		 result = a < b ? a: b - 100;
		 
		 System.out.printf("result = %d%n", result);
	
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örnekte koşul operatörünün ürettiği değerden 100 çıkartılacaktır. Parantaz ile bu sağlanmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int result;
		
		 result = (a < b ? a: b) - 100;
		 
		 System.out.printf("result = %d%n", result);
	
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örneği inceleyelim
	 	kısa devre davranısını unutmyalım
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int result;
		
		result = a > 0 && a < b ? a: b;
		 
		System.out.printf("result = %d%n", result);
	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örneği inceleyelim
	 	kısa devre davranısını unutmyalım
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int min;
		
		min = a < b ? a: b;
		 
		System.out.printf("result = %d%n", min);
	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örneği inceleyelim
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		 
		System.out.printf("result = %d%n", Util.min(a, b));
	
	}
}

class Util{
	public static int min(int a, int b) 
	{
		return a < b ? a : b;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örneği inceleyelim
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		 
		System.out.printf("result = %d%n", a < b ? a : b);
	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong 
	 isimli metodu NumberUtil sınıfı içerisinde yazınız.
	 
	 Açıklamalar:
	 - Bir sayının her basamağının basamak sayıncı kuvvetleri toplandığında sayının kendisine eşitse bu sayıya Armstrong
	 sayısı denir. Örneğin:
	 
	 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153	 
	 
	 - Sayı negatif ise Armstrong sayısı kabul etmeyiniz
	 
	 - Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
	 ekrana yazdırarak test ediniz
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{
		IsAmrstrongTest.run();
	
	}
}

class IsAmrstrongTest{
	public static void run() 
	{
		for(int a = -10; a <= 999999; ++a)
			if(NumberUtil.isArmstrong(a))
				System.out.println(a);
	}
}

class NumberUtil{
	public static boolean isArmstrong(int a) 
	{
		return a >= 0 && getDigitsPowSum(a) == a;
	}
	
	public static int getDigitsPowSum(int a) 
	{
		int n = countDigits(a);
		int total = 0;
		while (a != 0) {
			total += Math.pow(a % 10, n);
			a /= 10;
		}
		
		return total;
	}
	
	public static int countDigits(int a) 
	{
		return a == 0 ? 1 : (int)Math.log10(Math.abs(a)) + 1;
	}
	
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli metodu yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden 
		elde edilen kalan ile belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ..., 6 ise "cumartesi"
		günlerine karşılık gelir
		
		- 1.1.1900 öncesindeki tarihler geçersiz sayılacaktır
		- getDayOfWeek metodu ile birlikte 
				
		- İleride daha iyisi yazılacaktır parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin
		hafta sonu olup olmadığınıu test eden isWeekend ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız.
		Bu iki metot tarih geçerlilik kontrolü yapmayacaktır
		
		- İleride daha yazılacaktır
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		GetDayOfWeekTest.run();		
	}
}

class GetDayOfWeekTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz?");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}
		
		switch (dayOfWeek) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
		case 2 -> System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);			
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);			
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);		
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);			
		}
		
		System.out.println(isWeekend(day, month, year) ? "Bugün kurs var. Tekrar yaptınız mı?" : "Kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız"); // ifade daha kısaltılabilir. İleride göreceğiz
		
	}

	
	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;
		
		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;
		
		for (int y = 1900; y < year; ++y) 
			totalDays += isLeapYear(y) ? 366 : 365;
		
		return totalDays % 7;
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		return dayOfWeek == 0 || dayOfWeek == 6;
	}
	
	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}
	
	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;
		
		int totalDays = day;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += isLeapYear(year) ? 29 : 28;
		case 1:
			totalDays += 31;			
		}
		
		return totalDays;
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{		
		return  1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);		
	}
	
	public static int getDays(int month, int year)
	{
		int days;
		
		days = switch (month) {
			case 4, 6, 9, 11 -> 30;		
			case 2 -> isLeapYear(year) ? 29 : 28;			
			default -> 31;			
		};
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
		 	
	 Koşul operatörünün ikinci ve üçüncü operandı void bir ifade olamaz
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		a < b ? Sample.foo() : Sample.bar(); //errror
		
	}
}



class Sample{
	public static void foo() 
	{
		System.out.println("foo");
	}
	
	public static void bar() 
	{
		System.out.println("bar");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
		 	
	 Yukarıdaki örnekte çözğmleme bu sekilde yapılır
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		if(a < b)
			Sample.foo();
		else
			Sample.bar();
		
	}
}



class Sample{
	public static void foo() 
	{
		System.out.println("foo");
	}
	
	public static void bar() 
	{
		System.out.println("bar");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
		 	
	Koşul operatörünün bir kullanımı. Örnekte parantez kullanımına sentaks açısından gerek yoktur
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		

		System.out.print("Üçüncü sayiyi giriniz : ");
		int c = Integer.parseInt(kb.nextLine());
		
		int min;
				
		min = a < b ? a < c ? a : c : b < c ? b : c;
		
		System.out.printf("min = %d%n", min);
		
	}
}






/*----------------------------------------------------------------------------------------------------------------------	 
		 	
	Yukarıdaki örnekte koşul operatörünün operandlarını parantez içerisine almak okunabilirliği artırır
	
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		

		System.out.print("Üçüncü sayiyi giriniz : ");
		int c = Integer.parseInt(kb.nextLine());
		
		int min;
				
		min = (a < b) ? (a < c ? a : c) : (b < c ? b : c);
		
		System.out.printf("min = %d%n", min);
		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------


Method Overloading: 

	Bir sınıf içerisinde aynı isimde metot yazılması durumuna "method overloading" denir.
	Bu kavram aynı isimde fakat farklı sınıflarda olan metotlar için geçerli değildir.



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki durum "method overloading" değildir. Çünkü aynı isimde olan metotlar farklı sınıflardadır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		Sample.foo();
		Mample.foo();
		
	}
}

class Sample{
	public static void foo() 
	{
		System.out.println("Sample.foo");
	}
}

class Mample{
	public static void foo() 
	{
		System.out.println("Mample.foo");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: Bir sınıf içerisinde AYNI metottan birden fazla olamaz. Bu durumda bir metodun "overload" edilebilmesi
	için kendisiyle aynı isimde olanlardan FARKLI olması gerekir. Aşağıdaki maddelerde metodun AYNI ya da FARKLI olmasına
	ilişkin detaylar anlatılmaktadır 
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun erişim belirleyicisinin "overload" işlemine etkisi yoktur. Yani errişim belirleyicilerin farklı olması
	metodu farklı yapmaz 
	
	 Bir sınıf içerisinde AYNI metottan birden fazla olamaz. Bu durumda bir metodun "overload" edilebilmesi
	için kendisiyle aynı isimde olanlardan FARKLI olması gerekir.
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	

		
	}
}

class Sample{
	public static void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun static olup olmamasının da overload işlemine etkisi yoktur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	

		
	}
}

class Sample{
	public static void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
	
	public void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun geri dönüş değeri bilgisinin de overload işlemine etkisi yoktur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	

		
	}
}

class Sample{
	public static void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
	
	public static int foo() //ERROR 
	{
		System.out.println("Sample.foo");
		
		return 10;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun parametre isimlerinin de overload işlemine etkisi yoktur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	

		
	}
}

class Sample{
	public static void foo(int a, int b) //ERROR 
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo(int a, int b) //ERROR 
	{
		System.out.println("Sample.foo");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun "overload" edilebilmesi için metodun parametre tür bilgisi ve parametrelerin diziliminin farklı olması 
	gerekir.  Buna genel olarak "parametrik yapı" diyebiliriz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
	}
}

class Sample{
	public static void foo() 
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo(int a) 
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo(double a) 
	{
		System.out.println("Sample.foo double");
	}
	
	public static void foo(int a, double b) 
	{
		System.out.println("Sample.foo int double");
	}
	
	public static void foo(double a, int b) 
	{
		System.out.println("Sample.foo double int");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir sınıf içerisinde metodun ismi ve parametrik yapısının ikisine birden o metodun "imzası (signature)" diyelim.
	 
	Kural: Bir sınıf içerisinde aynı imzaya sahip 1(bir)'den fazla metot bildirimi geçersizdir  	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
	}
}

class Sample{
	public static void foo()  //foo
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo(int a)  //foo, int
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo(double a)  //foo, double
	{
		System.out.println("Sample.foo double");
	}
		
	public static void foo(int a, double b) //foo , int , double
	{
		System.out.println("Sample.foo int double");
	}
	
	public static void foo(double a, int b) //foo, double, int
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void bar() //bar 
	{
		System.out.println("Sample.bar ");
	}
	
	public static void bar(int a) //bar, int
	{
		System.out.println("Sample.bar int");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metot çağrısında derleyicinin hangi metodun çağrılacağına karar vermesi sürecine "method overload resolution"
	ya da kısaca "overload resolution" denir  	 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	 Metot çağrısında argümanlar ile karşılık geldikleri parametrelerin türlerinin aynı olduğu o isimde bir metot sınıf
	 içerisinde varsa o çağrılır (best match)  	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10, b = 20;
		double c = 30;
		
		Sample.foo(c, b);
	}
}

class Sample{
	public static void foo()  //foo
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo(int a, int b)  //foo,int,int
	{
		System.out.println("Sample.foo int int");
	}
	
	public static void foo(int a)  //foo, int
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo(double a)  //foo, double
	{
		System.out.println("Sample.foo double");
	}
		
	public static void foo(int a, double b) //foo , int , double
	{
		System.out.println("Sample.foo int double");
	}
	
	public static void foo(double a, int b) //foo, double, int
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void bar() //bar 
	{
		System.out.println("Sample.bar ");
	}
	
	public static void bar(int a) //bar, int
	{
		System.out.println("Sample.bar int");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
 	 Tam uyum (best match) yoksa overload resolution işlemi aşağıdaki gibi yapılır:
	 1. Aday metotlar (candidate methods) belirlenir: Çağrılan metot ile aynı isimde olan tüm metotlardır.
	 
	 2. Uygun metotlar (applicable methods) belirlenir: Aday metotlar içerisindeki, parametre sayısı çağrıdaki argüman
	 sayısı ile aynı olan ve argümanlardan karşılık geldikleri parmetrelere otomatik (implicit) tür dönüşümünün geçerli
	 olduğu metotlardır.
	 
	 3. En uygun metot (the most applicable method) belirlenir: Uygun metotlar içerisinde daha kaliteli, ya da daha kalitesiz
	 olmayan dönüşümü sunan metottur. Ya da başka bir deyişle "en uygun metot öyle bir metottur ki, argümanlardan parametrelere
	 yapılan dönüşümler kalite olarak yarışa sokulduğunda daha iyi ya da daha kötü olmayan dönüşümü sunar"
	 
	 Dönüşümün kalitesi aşağıdaki kurallara göre belirlenir:
	 T1 argümanın türü, T2 ve T3 yarıştırılan uygun metotların T1'e ilişkin argümana karşılık geldiği parametresinin 
	 türleri olsun:
	 
	 1. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2 veya T3'den biri T1 ile aynı ise aynı olan dönüşüm daha kalitelidir.
	 Örneğin:
	 int -> int *
	 int -> double
	 
	 2. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2'den T3'e otomatik dönüşüm var, T3'den T2'ye otomatik dönüşüm yok ise
	 T2 kalitelidir
	 Örneğin:
	 int -> long *
	 int -> float
	 
	 ya da örneğin
	 
	 short -> int *
	 short -> double
	 
	 
	 Burada aday metotlar bulunamazsa VEYA aday metotlar var ancak uygun metotlar bulunamazsa VEYA uygun metotlar var ancak
	 en uygun metot yoksa error oluşur. 	 
	 
	 Yukarıdaki anlatım "overload resolutiıon" kavramının basitleştirilmiş bir anlatımıdır 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: 1, 2, 3, 4, 5
 	2. Uygun metotla: 1, 2, 3
 	3. En uygun metot: 1
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;
		
		Sample.foo(a, b);
	}
}

class Sample{
	public static void foo(int a, int b)  //#1
	{
		System.out.println("Sample.foo int int");
	}
	
	public static void foo(double a, int b)  //#2
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void foo(int a, long b)  //#3
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#4
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#5
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#6
	{
		System.out.println("Sample.bar int");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
 	 Tam uyum (best match) yoksa overload resolution işlemi aşağıdaki gibi yapılır:
	 1. Aday metotlar (candidate methods) belirlenir: Çağrılan metot ile aynı isimde olan tüm metotlardır.
	 
	 2. Uygun metotlar (applicable methods) belirlenir: Aday metotlar içerisindeki, parametre sayısı çağrıdaki argüman
	 sayısı ile aynı olan ve argümanlardan karşılık geldikleri parmetrelere otomatik (implicit) tür dönüşümünün geçerli
	 olduğu metotlardır.
	 
	 3. En uygun metot (the most applicable method) belirlenir: Uygun metotlar içerisinde daha kaliteli, ya da daha kalitesiz
	 olmayan dönüşümü sunan metottur. Ya da başka bir deyişle "en uygun metot öyle bir metottur ki, argümanlardan parametrelere
	 yapılan dönüşümler kalite olarak yarışa sokulduğunda daha iyi ya da daha kötü olmayan dönüşümü sunar"
	 
	 Dönüşümün kalitesi aşağıdaki kurallara göre belirlenir:
	 T1 argümanın türü, T2 ve T3 yarıştırılan uygun metotların T1'e ilişkin argümana karşılık geldiği parametresinin 
	 türleri olsun:
	 
	 1. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2 veya T3'den biri T1 ile aynı ise aynı olan dönüşüm daha kalitelidir.
	 Örneğin:
	 int -> int *
	 int -> double
	 
	 2. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2'den T3'e otomatik dönüşüm var, T3'den T2'ye otomatik dönüşüm yok ise
	 T2 kalitelidir
	 Örneğin:
	 int -> long *
	 int -> float
	 
	 ya da örneğin
	 
	 short -> int *
	 short -> double
	 
	 
	 Burada aday metotlar bulunamazsa VEYA aday metotlar var ancak uygun metotlar bulunamazsa VEYA uygun metotlar var ancak
	 en uygun metot yoksa error oluşur. 	 
	 
	 Yukarıdaki anlatım "overload resolutiıon" kavramının basitleştirilmiş bir anlatımıdır 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: 1, 2, 3, 4, 5
 	2. Uygun metotlar: 3
 	3. En uygun metot: 3
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		double b = 20;
		
		Sample.foo(a, b);

	}
}

class Sample{
	public static void foo(double a, int b)  //#1
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void foo(int a, float b)  //#2
	{
		System.out.println("Sample.foo int float");
	}
	
	public static void foo(int a, double b)  //#3
	{
		System.out.println("Sample.foo int double");
	}
		
	public static void foo(int a) //#4
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#5
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#6
	{
		System.out.println("Sample.bar int");
	}
}





/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: yok
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10;
		float b = 20;
		
		Sample.fo(a, b);

	}
}

class Sample{
	public static void foo(int a, int b)  //#1
	{
		System.out.println("Sample.foo int int");
	}
	
	public static void foo(double a, int b)  //#2
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void foo(int a, double b)  //#3
	{
		System.out.println("Sample.foo int double");
	}
		
	public static void foo(int a) //#4
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#5
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#6
	{
		System.out.println("Sample.bar int");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: 1, 2, 3, 4, 5
 	2. Uygun Metotlar: yok
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10;
		float b = 20;
		
		Sample.foo(a, b); //error

	}
}

class Sample{
	public static void foo(int a, int b)  //#1
	{
		System.out.println("Sample.foo int int");
	}
	
	public static void foo(double a, int b)  //#2
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void foo(int a, long b)  //#3
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#4
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#5
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#6
	{
		System.out.println("Sample.bar int double");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: 1, 2, 3, 4
 	2. Uygun Metotlar: 1, 2
 	3. En uygun metot: yok
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		short b = 20;
		
		Sample.foo(a, b); //error, ambiguity

	}
}

class Sample{
	public static void foo(long a, int b)  //#1
	{
		System.out.println("Sample.foo long int");
	}
	
	public static void foo(int a, long b)  //#2
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#3
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#4
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#5
	{
		System.out.println("Sample.bar int double");
	}
}





/*----------------------------------------------------------------------------------------------------------------------	 
 	tam uyum var best macth
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		short b = 20;
		
		Sample.foo((long)a, (int)b); 

	}
}

class Sample{
	public static void foo(long a, int b)  //#1
	{
		System.out.println("Sample.foo long int");
	}
	
	public static void foo(int a, long b)  //#2
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#3
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#4
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#5
	{
		System.out.println("Sample.bar int double");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
 	1.Aday metotlar : 1, 2, 3, 4
 	2. Uygun metotlar: 1
 	3. En uygun metot: 1
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		short b = 20;
		
		Sample.foo((long)a, b); 

	}
}

class Sample{
	public static void foo(long a, int b)  //#1
	{
		System.out.println("Sample.foo long int");
	}
	
	public static void foo(int a, long b)  //#2
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#3
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#4
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#5
	{
		System.out.println("Sample.bar int double");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
 	1.Aday metotlar : 1, 2, 3, 4
 	2. Uygun metotlar: 1, 2, 3, 4
 	3. En uygun metot: 1
 	
 	
 	T1 ->T2 T1-> T3------  T2 -> T3 ve T2 ye donusmuyor T2
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		
		MyMath.abs(a); 

	}
}

class MyMath{
	public static int abs(int a)  //#1
	{
		System.out.println("MyMath.abs int");
		return a < 0 ? -a : a;
	}
	
	public static double abs(double a)  //#2
	{
		System.out.println("MyMath.abs double");
		
		return a < 0 ? -a : a;
	}
		
	public static float abs(float a)  //#3
	{
		System.out.println("MyMath.abs float");
		
		return a < 0 ? -a : a;
	}
	
	public static long abs(long a)  //#4
	{
		System.out.println("MyMath.abs long");
		
		return a < 0 ? -a : a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
    12.01.2023 - Perşembe - 16.Ders

	Nesne Yönelimli Programalama Tekniği (NYPT): Bu tekniği tek bir cümle ile anlatmak pek mümkün değildir. Ancak bu 
	tekniğin detaylarını bilen bir kişiye "sınıflar kullanarak program yazma tekniğidir" şeklinde bir cümle söylenebilir.
	Aslında NYPT anahtar kavramların birleşiminden oluşur. Bu anahtar kavramlar birbirlerinden tamamen ayrık değildir. 
	Bu kavramlar içiçe geçmiş daireler gibi düşünülebilir. Tüm anahtar kavramların temelinde kodu daha iyi algılanabilir 
	olması ve daha iyi yönetilmesi vardır. Örneğin benzer işi yapan metotlara aynı ismi vermek iyi bir tekniktir. Çünkü 
	bu durumda bu metotları kullanan kişiler "çok şey var" duygusundan uzaklaşıp "az şey var" gibi bir algı oluştururlar.
	Bu da hatırlamayı kolaylaştırır.
	
	NYPT insanın doğayı algılayış biçimini model almıştır. İnsanlar herşeyi nesne biçiminde ele alıp onu kullanırlar. 
	Örneğin, elimizdeki bilgisayarlar farklı bile olsa konuşurken bizim için hepsi bilgisayardır. Gerekirse onların 
	başka özellikler ayrıca söylenebilir.
	
	NYPT'de artık ağırlıklı olarak fonksiyonlarla (Java'da metot) değil, sınıflarla konuşulur. Böylece yine "çok şey var"
	algısından uzaklaştırılıp "az şey var" algısı oluşturulur. Bu anlamda aslında kullanan programcı açısından detaylar
	metotların detayları gizlemesinden daha fazla gizlenebilir. Böylelikle kullanım kolaylaşır. Bunların detayları ileride
	daha iyi anlaşılacaktır 




	Değişkenlerin Ömürleri (storage duration):
	Bir değişkenin ömrü onun bellekte yer kapladığı zaman aralığıdır. Yani bir değişkenin ömrü o değişkenin bellekte
	yaratılmasıyla (yer ayrılmasıyla) yok edilmesi arasında geçen zaman aralığıdır.
	Anımsanacağı gibi bir değişkenin faaliyet alanı (scope) derleme zamanına ilişkindir. Ömür ise çalışma zamanına 
	ilişkindir. 
		
	
	Bir Java programı için çalışma zamanında "stack" ve "heap" denilern iki ayrı belek alanı yaratılır. Her uygulama 
	için bu alanlar ayrı olarak yaratılırlar. Aşağı seviyede başka alanlar da bulunur. Stack ve heap RAM'de organize
	organize edilir. Stack ve heap'in yeri (yani hangi adresten başladığı) ve uzunluğu sistemden sisteme değişebilmektedir.
	Program çalıştırılırken bu alanların uzunlukları belirlenebilirç. Belirlenmezse default değerler kullanılır. İşte bu
	default değerler sistemden sisteme farklı olabilir. 
	
	Stack'te yaratma ve yok etme işlemi birer makine komutuyla çok hızlı bir biçimde yapılır. Stack alanınde değişken
	yaratılması ve yok edilmesi stack veri yapısı ile gerçekleştirilir
	

	Veri yapısı (Data structure): Verileri belirli bir algoritmaya göre tutan ve verilere istenildiği zaman erişebilen
	yapılara denir.

	Stack veri yapısında eleman ekleme işlemine "push", eleman silme işlemine de "pop" denilmektedir.
	
	Anahtar Notlar: Stack veri yapısı "LIFO (Last In First Out)" kuyruk sistemine göre çalışan veri yapısıdır. LIFO'da
	ekleme sona yapılır. Eleman elde etme (ve silme) sondan yapılır. Yani son eklenen eleman elde edilir. Örneğin bir 
	pişti oyununda ortada biriken kağıtlar için bu veri yapısı kullanılabilir. Ya da örneğin editör programların 
	"undo-redo" işlemleri de stack veri yapısı ile gerçekleştirilebilir





/*----------------------------------------------------------------------------------------------------------------------	 
 	Yerel değişkenler ve parametre değişkenleri stack alanında yaratılırlar. Yerel bir değişken, akış bakımından bildirim
	noktasına gelindiğinde yaratılır, bildirildiği bloğun sonuna gelindiğinde yok edilir. Zaten değişkenlere faaliyet
	alanı bakımından bildirildikleri bloktan sonra erişilememesinin nedeni budur. Parametre değişkenleri metot çağrıldığında
	yaratılır, metot çağrısı bittiğinde yok edilir. 
	
	Anahtar Notlar: Her ne kadar faaliyet alanı (scope) ve ömür (storage duration) farklı zamanlara (compile or run) 
	ilişkin kavramlar olsa da aralarında mantıksal bir bağ söz konusudur. Yani aralarında dolaylı da olsa da bir ilişkin 
	bulunur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		//....
		//..
		
		{
			int a; //akış buraya geldi stack yaratılır
			double b = 4.5; // stackte yaratılı initialize edilir
		}//a ve b yok edilir 
		
		
		Sample.foo(5,  3.4); //metodun parametre değişkenleri yaratılır ve argümanlarına degerleri ilgili parametreler aktarılır 
		//metot çagrısı bittiginde parametre değişkneleride yok edilir
		
		
		//
		
		
		Sample.foo(12, 2.2);//metodun parametre değişkenleri yaratılır ve argümanlarına degerleri ilgili parametreler aktarılır 
		//metot çagrısı bittiginde parametre değişkneleride yok edilir
		
	}
}


class Sample{
	public static void foo(int a, double b) 
	{
		int x; //Akış buraya geldiğinde x stack'de yaratılır
		//..
		
		//..
	}//x in hayatı burada sonlanır
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf içerisindeki bildirimlere sınıfın elemanları (members) denir. Sınıfın elemanı bir alt programsa buna metot denir.
	Sınıfın elemanı bir değişken ise veri elemanı (member field/variable ya da yalnızca field) denir. Sınıfın başka 
	elemanları da olabilir. Bunlar ileride ele alaıncaktır  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın içerisinde tüm metotların dışında herhangi bir yerde bildirilen değişkenlere sınıfın veri elemanları denir.
	Sınıf veri elemanları da metotlarda olduğu gibi erişim belirleyiciye sahiptir, veri elemanları da static ve non-static
	olarak bildirilebilirler. Sınıf elemanlarının erişim belirleyiciler konusuna kdar tüm veri elemanlarını da public
	olarak bildireceğiz  
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

class App {	
	public static void main(String [] args)
	{
		
	}
}

class Sapmle{
	
	public int a;
	private static double b;
	
	public static void foo(int x)
	{
		//...
		
	}
	
	protected int c;
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Bir sınıf içerisinde aynı isimde birden fazla veri elemanı bildirimi yapılamaz  
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

class App {	
	public static void main(String [] args)
	{
	}
}

class Sapmle{
	
	public int a;
	private static double b; //error duplicate
	
	public static void foo(int x)
	{
		//...
		
	}
	
	protected int b;//error duplicate
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Birden fazla veri elemanı aynı türdense, static veya non-static olma durumları aynı ise, ve aynı erişim
	  belirleyiciye sahipse virgül ile ayrılarak yani listelenerek bildirim yapılabilir
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

class App {	
	public static void main(String [] args)
	{
	}
}

class Sapmle{
	
	public int a, b;
	private static double d, c, y, t; 
	
	public static void foo(int x)
	{
		//...
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıf bildirimi aslında bir tür bildirimidir (user defined type)
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

class Sensor{
	//...
}

class Student{
	//..
	int id;
	String name;
	
}

class Person{
	//...
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıf bildirimi bir tür bildirimi olduğuna göre sınıf türünden değişkenler bildirilebilir. 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;


class App {	
	public static void main(String [] args)
	{
		int a;
		double b, c;
		
		Sensor s;
		Student stdnt;
		Person p;
		
	}
}

class Sensor{
	//...
}

class Student{
	//..
	int id;
	String name;
	
}

class Person{
	//...
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Java'da türler kategori olarak iki gruba ayrılır: değer türleri (value types), referans türleri (reference types).
	 
	 T bir tür olmak üzere T türden bir değişken içerisinde tutulan değer bir adres iese bu durumda T bir referans türüdür.
	 Adres değilse T bir değer türüdür. Java'da temel türler değer türleridir. Yani temel türden bir değişken içerisinde
	 adres tutulmaz. Programcı tarafından bildirilen türler (user defined type) (sınıflar, enum sınıflar, interface'ler vb.)
	 referans türleridir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıf türünden bir değişkene (aslında referans türünden bir değişkene) "referans değişken" ya da kısaca "referans"
	 denir. 
	 
	 Anahtar Notlar: Java'da "referans" sözcüğü "adres" anlamında da kullanılır. Örneğin "bir nesnenin adresi" yerine
	 "bir nesnenin referansı" demek de aynıdır. Ancak buradaki referans terimi bir değişkeni değil adresi temsil eder.
	 "Referans değişken ya da kısaca referans" içerisinde adres (referans) tutan değişkendir.     
----------------------------------------------------------------------------------------------------------------------*/

package orhn;




class App {	
	public static void main(String [] args)
	{
		int a; //value type
		double b, c;
		
		Sensor s; // s bir referans 
		Student st; //st bir referans
		Person p;//p bir referans
		
	}
}

class Sensor{
	//...
}

class Student{
	//..
	int id;
	String name;
	
}

class Person{
	//...
}



/*----------------------------------------------------------------------------------------------------------------------	 
	  - Sınıf türünden bellekte ayrılan bir alana o sınıf türünden nesne (object) denir
	 
	 - Nesneler heap'de yaratılırlar. Java'da stack'te nesne yaratılamaz
	 
	 - Java'da nesnenin kendisi değil adresi aynı türden bir referansta tutulabilir
	 
	 - Bir nesneyi yaratmak için new operatörü kullanılır. new operatörü kullanımının genel biçimi:
	 	new <sınıf ismi>([argümanlar]);   
	 	
	 new operatörü özel amaçlı, tek operandlı (unary) ve önek (prefix) durumda bir operatördür. new operatörü nesne
	 yaratılması aaşamaları tamamlandıktan sonra heap'te yaratılmış olan nesnenin adresini (referansını) üretir. Bu durumda
	 bu operatörün ürettiği değer yani adres aynı türden bir referansa atanabilir
	 
	 - Bir nesne ilgili sınıf türünden bir örnektir. Buna "instance" da denir 
	 
	 
	 - Aşağıdaki örnekte, nesne yönelimli programlama anlamında "s" birer nesne DEĞİLDİR. Bunlar ilgili sınıflar
	 türünden referanslardır.  ** ile belirtilen deyimle birlikte "s referansı yaratılan nesneyi gösteriyor" duruma gelir.
	 
	 - Referans ve nesne kavramları birbirinden farklıdır. Referans değişken bir nesneyi gösterebilir	
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;




class App {	
	public static void main(String [] args)
	{
		Sensor s; //s bir referans (değişken)
		
		java.util.Scanner kb = new java.util.Scanner(System.in); 
				
		s = new Sensor(); //**
	}
}

class Sensor{
	//...
}

class Student{
	//..
	int id;
	String name;
	
}

class Person{
	//...
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıfın non-static veri elemanları her nesne için ayrıca yaratılırlar ve nesnenin içerisinde bulunurlar. Sınıfon 
	non-static veri elemanlarına sınıf dışından (yani başka bir sınıfın içinden) referans ve nokta operatörü ile 
	erişilir. Nokta operatörü özel amaçlı, iki operandlı ve araek durumundadır. Nokta operatörünün birinci operandı bir
	referans, ikinci operandı bir veri elemanı ise bu durumda nokta operatörü o veri elemanına ilişkin değişkeni üretir.
	Aslında referans ve nokta operatörü ile veri elemanı ismi kullanımı o referansın gösterdiği nesnenin ilgili veri elemanına
	erişmek anlamına gelir. Her new işlemi yeni bir nesne yaratmak demektir
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;




class App {	
	public static void main(String [] args)
	{
		Sample s, k; //referans
		
		s = new Sample();
		k = new Sample();
		
		s.a = 10;
		s.b = true;
		
		k.a = 20;
		k.b = false;
		
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte s yerel değişkenine değer atanmadan kullanıldığı için error oluşur
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;




class App {	
	public static void main(String [] args)
	{
		Sample s; //referans

		s.a = 10; //error
		s.b = true; //error

		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);

		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Farklı türden referanslar birbirine tür dönüştürme operatörü ile bile atanamazlar 
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s; //referans
		Mample m;

		s = new Sample();
		
		m = (Mample)s;

	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}

class Mample{
	public int a;
	public boolean b;
	
	//..
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Non-static veri elemanlarına nesnenin yaratılması aşamasında default değerler atanır. Default değer türe özgü
	mantıksal sıfır değeridir. Örneğin int türü için sıfırken, boolean türü için false değeridir 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k; //referans

		s = new Sample();
		k = new Sample();
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);

	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir nesnenin uzunluğu yani bellekte kapladığı alan "en az non-static veri elemanlarının toplam uzunluğu kadardır".
	Bu durumda aynı türden nesneler için aynı uzunlukta yer ayrılır. Farklı türden nesneler için farklı veri elemanları
	olabileceğinden aynı uzunlukta yer ayrılması gerekmez
	
	Türü ne olursa olsun referansların (referans değişkenlerin) uzunlukları aynıdır. Bu da adreslenebilecek sayıları
	tutabilecek uzunluktur. Örneğin 64 bit sistemlerde tüm referanslar 64 bit(8 byte) uzunluğundadır. Benzer şekilde 
	32 bit sistemlerde tüm referanslar 32 bit (4 byte) uzunluğundadır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Aynı türden iki referansın biribirine atanması iki referansın da artık aynı nesneyi göstermesi demektir. Bu durumda
	hangi referans ile nesneye erişildiğinin bir önemi yoktur. Aşağıdaki örnekte **'da s referansı gösterdiği nesneden 
	kopartılmış ve k'nın içerisindeki adres atandığından artık k ve s aynı nesneyi gösterir duruma gelmiştir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k; //referans

		s = new Sample(); 
		k = new Sample(); 
		
		s.a = 20;
		s.b = true;
		
		k.a = 15;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("***************************************");
		
		s = k; //**

		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("***************************************");
		
		++s.a;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("***************************************");
		
		
		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte değer türü kullanıldığından b'nin değeri artırılmış olmaz

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10;
		int b;
		
		b = a;
		
		System.out.printf("a = %d%n", a); //10
		System.out.printf("b = %d%n", b); //10
		System.out.println("***************************************");
		
		++a;
		
		System.out.printf("a = %d%n", a); //11
		System.out.printf("b = %d%n", b); //10
		System.out.println("***************************************");
		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte değer türü kullanıldığından b'nin değeri artırılmış olmaz

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.a = 20;
		s.b = true;
		
		k.a = 55;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("************************");
		
		s = k;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("************************");
		
		++s.a;
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("************************");
		
		s = new Sample();
		
		--s.a;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("************************");
		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun geri dönüş değeri referans olabilir. Bu durumda bu metodun geri dönüş değerine ilişkin return deyimine
	ait ifadenin türünün aynı türden bir referans olması gerekir. Bir metodun parametre değişkeni bir referans olabilir. 
	Bu durumda metot aynı türden bir referans ile çağrılabilir. Metoda geçilen referans ile metot içerisinde ilgili nesneye
	erişilmiş olur. Referans parametreli bir metot aldığı referansa ilişkin nesne üzerinde değişiklik yapabilir. Bu durumda
	bu değişiklik metodu çağıran kodda ki referans üzerinden yine aynı nesneye erişildiği için görülebilir
	
	Aşağıdaki örnekte createDate metodu içeride yaratmış olduğu nesnenin referansını geri dönüş değeri olarak vermektedir.
	printDate metodu parametresi ile aldığı Date türden referansın gösterdiği nesneye erişip bilgilerini ekrana yazdırmaktadır.
	changeDate metodu aldığı referansa ilişkin nesneye erişerek day, month ve year elemanlarını değiştirmiştir. Örneği 
	çalıştırarak durumu	gözlemleyiniz

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Date birtDate;
		
		birtDate = DateUtil.createDate(11, 9, 1990);
		
		DateUtil.printDate(birtDate);
		DateUtil.changeDate(birtDate, 5, 3, 2021);
		DateUtil.printDate(birtDate);
		
	}
}

class DateUtil{
	public static void changeDate(Date d, int day, int month, int year) 
	{
		//..
		d.day = day;
		d.month = month;
		d.year = year;
	}
	
	public static Date createDate(int day, int month, int year)
	{
		Date d = new Date();
		d.day = day;
		d.month = month;
		d.year = year;
		
		return d;
	}
	
	public static void printDate(Date d)
	{
		System.out.printf("%02d/%02d/%04d%n", d.day, d.month, d.year);
		System.out.println("****************************************");
	}

}

class Date{
	public int day, month, year;
	//..
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örneği inceleyiniz

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Date birtDate;
		
		birtDate = new Date();
		birtDate.day = 23;
		birtDate.month = 06;
		birtDate.year = 1992;
		
		DateUtil.printDate(birtDate);
		
		DateUtil.changeDate(birtDate, 24, 10, 1997);
		
		DateUtil.printDate(birtDate);
		
		
		Date newDate = DateUtil.createDate(13, 02, 2002);
		
		DateUtil.printDate(newDate);
		
		DateUtil.changeDate(newDate, 11, 01, 2022);
		
		DateUtil.printDate(newDate);
		
		newDate = birtDate; //artık iki referans ta aynı adresi temsil eder

		DateUtil.printDate(newDate);
		DateUtil.printDate(birtDate);
	}
}

class DateUtil{
	public static void changeDate(Date d, int day, int month, int year) 
	{
		//..
		
		d.day = day;
		d.month = month;
		d.year = year;
	}
	
	public static Date createDate(int day, int month, int year)
	{
		Date d = new Date();
		d.day = day;
		d.month = month;
		d.year = year;
		
		return d;
	}
	
	public static void printDate(Date d)
	{
		System.out.printf("%02d/%02d/%04d%n", d.day, d.month, d.year);
		System.out.println("****************************************");
	}

}

class Date{
	public int day, month, year;
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte main içerisindeki yerel değişken olan a'nın değeri metot çağrısından sonra değişmez. Çünkü
	argümanlardan parametrelere aktarım bir atama işlemidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a;
		
		a = 20;
		
		Sample.foo(a);
		
		System.out.printf("a = %d%n", a);	
	}
}


class Sample{
	public static void foo(int a) 
	{
		System.out.printf("foo:a = %d%n", a);
		++a;
		System.out.printf("foo:a = %d%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte main içerisindeki yerel değişken olan a'nın değeri metot çağrısından sonra değişmez. Çünkü
	argümanlardan parametrelere aktarım bir atama işlemidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a;
		
		a = 20;
		
		Sample.foo(a);
		
		System.out.printf("a = %d%n", a);
		System.out.println("**************************");
		
		
		/*******************************************/
		
		Mample m = new Mample();
		
		m.a = 14;
		
		Sample.foo(m.a);
		
		System.out.printf("m.a = %d%n", m.a);
		System.out.println("**************************");
		
		
		/*******************************************/
		
		Sample.changeValueMample(m);
		System.out.printf("m.a = %d%n", m.a); //15
	}
}


class Sample{
	public static void foo(int a) 
	{
		System.out.printf("foo:a = %d%n", a);
		++a;
		System.out.printf("foo:a = %d%n", a);
	}
	
	public static void changeValueMample(Mample m) 
	{
		System.out.printf("m.a = %d%n", m.a); //14
		++m.a; //15
		System.out.printf("m.a = %d%n", m.a); //15
	}
}

class Mample{
	int a;
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir veri elemanı bir tanedir. Bu elemanın kullanılması için nesne yaratılması gerekmez. Sınıfın
	static bir veri elemanına sınıf dışından sınıf ismi ve nokta operatörü ile erişilebilir. Sınıfın static veri elemanları
	sınıfın bir elemanı ilk kez kullanıldığında yaratılır ve programın sonuna kadar yaşarlar. Ayrıntılar ileride ele
	alınacaktır. Sınıfın static veri elemanlarına da yaratıldıklarında default değerler atanır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		System.out.printf("Sample.a = %d%n", Sample.a);
		System.out.printf("Sample.b = %b%n", Sample.b);
		
		Sample.a = 10;
		Sample.b = true;
				
		System.out.printf("Sample.a = %d%n", Sample.a);
		System.out.printf("Sample.b = %b%n", Sample.b);	
		
	}
}


class Sample{
	public static int a;
	public static boolean b;
}





/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir veri elemanı bir tanedir. Bu elemanın kullanılması için nesne yaratılması gerekmez. Sınıfın
	static bir veri elemanına sınıf dışından sınıf ismi ve nokta operatörü ile erişilebilir. Sınıfın static veri elemanları
	sınıfın bir elemanı ilk kez kullanıldığında yaratılır ve programın sonuna kadar yaşarlar. Ayrıntılar ileride ele
	alınacaktır. Sınıfın static veri elemanlarına da yaratıldıklarında default değerler atanır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		System.out.printf("Sample.a = %d%n", Sample.a);
		System.out.printf("Sample.b = %b%n", Sample.b);
		
		Sample.a = 10;
		Sample.b = true;
		
		Sample s1 = new Sample();
		s1.c = 12;
		
		Sample s2 = new Sample();
		s2.c = 15;
				
		System.out.printf("Sample.a = %d%n", Sample.a);
		System.out.printf("Sample.b = %b%n", Sample.b);	
		
		
		System.out.printf("s1.a = %d%n", s1.a);
		System.out.printf("s1.b = %b%n", s1.b);	
		System.out.printf("s1.c = %d%n", s1.c);	
		
		System.out.printf("s1.a = %d%n", s2.a);
		System.out.printf("s1.b = %b%n", s2.b);	
		System.out.printf("s2.c = %d%n", s2.c);
		
		s1.a = 19;
		s2.a = 23;
		System.out.printf("s1.a = %d%n", s1.a);
		System.out.printf("s2.a = %d%n", s2.a);
	}
}

class Sample{
	public static int a;
	public static boolean b;
	public int c;
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir veri elamanına sınıf dışından sınıf ismi ile erişilemez. Çünkü non-static veri elemanı
	nesneye özeldir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample.a = 10; // non static oldugu için gecersiz
		
	}
}


class Sample{
	public int a;
	public boolean b;
}




-----------------------------------------------------------
-----------------------------------------------------------

18.01.2023 Çarşamba - 17.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir veri elemanına sınıf dışından referans ve nokta operatörü ile de erişilebilir. Sınıf ismi ile
	erişmekten farkı yoktur. Sınıfın static veri elemanlarına bu şekilde okunabilirlik açısından tercih edilmemelidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s = new Sample();
		
		s.a = 10;
		s.b = true;
		
		System.out.printf("s.a = %d%n", Sample.a);
		System.out.printf("s.b = %b%n", Sample.b);
	}
}


class Sample{
	public static int a;
	public static boolean b;
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte sayaçlar, sınıfları kullanan programcı tarafından oluşturulmuştur. Programcı sayacı artırmayı
	veya azaltmayı unutabilir. Ayrıca başka sınıflar ve dolayısıyla nesneler için de sayaç tutulması gerektiğinde sayaç
	için kullanılacak değişkenlere isim bulma zorluğu oluşabilir. Üstelik oyun bir çok başka işlem de içerdiğinden
	programlaması karmaşıklaşabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		WarGameApp.run();
	}
}

class WarGameApp{
	public static void run() 
	{
		int soldierCount = 0, alienCount = 0;
		
		for (int i = 0; i < 10; i++) {
			Alien a = new Alien();
			
			//
			
			++alienCount;
		}
		
		for (int i = 0; i < 20; i++) {
			Soldier s = new Soldier();
			
			//
			
			++soldierCount;
		}
		
		///
		
		System.out.printf("Number of Soldiers : %d%n", soldierCount);
		System.out.printf("Number of Aliens : %d%n", alienCount);
		
	}
}

class Soldier{
	public int title;
	public int numberOfGuns;
}

class Alien{
	public int numberOfArms;
	public int color;
}

class Building{
	
}

class Civilian{
	
}

class Animal{
	
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki örnekte anlatılan problemler aşağıdaki gibi static veri elemanları kullanılarak çözülebilir. Böylece kod
	karmaşıklığı da azaltılmış olur. Şüphesiz örnekte detaylar göz ardı edilmiştir. Burada anlatılmak istenen konulara
	odaklanmanız önerilir. ** ile belirtilen kod parçaları şu an için önemsizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		WarGameApp.run();
	}
}

class WarGameApp{
	public static void run() 
	{	
		for (int i = 0; i < 10; i++) {
			Alien a = new Alien();
			
			//
			
		}
		
		for (int i = 0; i < 20; i++) {
			Soldier s = new Soldier();
			
			//

		}
		
		
		///
		
		System.out.printf("Number of Soldiers : %d%n", Soldier.count);
		System.out.printf("Number of Aliens : %d%n", Alien.count);
		
	}
}

class Soldier{
	public static int count;
	public int title;
	public int numberOfGuns;
	
	public Soldier() //***
	{
		++count;
	}
}

class Alien{
	public int numberOfArms;
	public int color;
	public static int count;
	
	public Alien()//***
	{
		++count;
	}
}

class Building{
	public static int count;
	
}

class Civilian{
	public static int count;
	
}

class Animal{
	public static int count;
	
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu sınıf dışından referans ve nokta operatörü ile çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s = new Sample();
		
		s.foo();
	}
}

class Sample{
	public void foo()
	{
		//
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu sınıf dışından sınıf ismi ve nokta operatörü ile çağrılamaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample.foo(); //error
	}
}

class Sample{
	public void foo()
	{
		//
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu sınıf dışından sınıf ismi ve nokta operatörü ile çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample.foo(); //error
	}
}

class Sample{
	public static void foo()
	{
		//
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu sınıf dışından referans ve nokta operatörü ile çağrılabilir. Sınıf ismi ile çağırmaktan
	farkı yoktur. Sınıfın static metotlarının bu şekilde çağrılması okunabilirlik açısından tercih edilmemelidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s = new Sample();
		
		s.foo(); //olur ama kullanmayın 
		
		Sample.foo(); //bu daha uygun
	}
}

class Sample{
	public static void foo()
	{
		//
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu içerisinde o sınıfın non-static bir veri elemanına doğrudan erişilebilir. Doğrudan 
	erişilen veri elamanı metot çağrısında kullanılan referansın gösterdiği nesnenin veri elemanı olur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		k.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
	}
}

class Sample{
	public int x;
	
	public void foo(int a)
	{
		x = a;
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu içerisinde o sınıfın non-static bir metodu doğrudan çağrılabilir. Doğrudan çağrılan
	metot, çağıran metodu çağıran referans ile çağrılmış olur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		k.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
	}
}

class Sample{
	public int x;
	
	public void foo(int a)
	{
		bar(a);
	}
	
	public void bar(int a)
	{
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki maddenin özeti olarak şu söylenebilir: Sınıfın non-static bir metodu içerisinde aynı sınıfın 
    non-static elemanlarına (member) doğrudan erişilebilir

----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu içerisinde o sınıfın static bir veri elemanına doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		System.out.printf("s.x = %d%n", Sample.x);
		k.foo(20);
		System.out.printf("k.x = %d%n", Sample.x);
		
	}
}

class Sample{
	public static int x;
	
	public void foo(int a)
	{
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu içerisinde o sınıfın static bir metodu doğrudan çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		System.out.printf("s.x = %d%n", Sample.x);
		k.foo(20);
		System.out.printf("k.x = %d%n", Sample.x);
		
	}
}

class Sample{
	public static int x;
	
	public void foo(int a)
	{
		x = a;
		bar(a);
	}
	
	public static void bar(int a)
	{
		System.out.println("bar");
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki iki maddenin özeti olarak şu söylenebilir: Sınıfın non-static bir metodu içerisinde aynı sınıfın 
    static elemanlarına doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki dört maddenin özeti olarak şu söylenebilir: Sınıfın non-static bir metodu içerisinde aynı sınıfın 
   	tüm elemanlarına doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu içerisinde o sınıfın non-static bir veri elemanına doğrudan erişim yoktur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		System.out.printf("s.x = %d%n", Sample.x);
		k.foo(20);
		System.out.printf("k.x = %d%n", Sample.x);
		
	}
}

class Sample{
	public int x;
	
	public static void foo(int a)
	{
		x = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu içerisinde o sınıfın non-static bir metodu doğrudan çağrılamaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		System.out.printf("s.x = %d%n", Sample.x);
		k.foo(20);
		System.out.printf("k.x = %d%n", Sample.x);
		
	}
}

class Sample{
	public int x;
	
	public static void foo(int a)
	{
		bar(a);
	}
	
	public void bar(int a) 
	{
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki iki maddenin özeti olarak şu söylenebilir: Sınıfın static bir metodu içerisinde aynı sınıfın 
    non-static elemanlarına doğrudan erişilemez
---------------------------------------------------------------------------------------------------------------------*/




/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu içerisinde o sınıfın static bir veri elemanına doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{

		Sample.foo(10);
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample{
	public static int x;
	
	public static void foo(int a)
	{
		x = a;
	}

}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu içerisinde o sınıfın non-static bir metodu doğrudan çağrılamaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{

		Sample.foo(10);
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample{
	public static int x;
	
	public static void foo(int a)
	{
		bar(a);
	}

	public static void bar(int a)
	{
		x = a;
	}

}




/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki iki maddenin özeti olarak şu söylenebilir: Sınıfın static bir metodu içerisinde aynı sınıfın 
    static elemanlarına doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki dört maddenin özeti olarak şu söylenebilir: Sınıfın static bir metodu içerisinde aynı sınıfın 
    yalnızca static elemanlarına doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki sekiz maddenin özeti olarak şu söylenebilir: Sınıfın non-static bir metodu içerisinde aynı sınıfın tüm
    elemanlarına doğrudan erişilebilirken, static bir metodu içerisinde aynı sınıfın yalnızca static elemanlarına 
    doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte bar metodunun doğrudan çağrılmadığına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
	}
}

class Sample{
	public int x;
	
	public static void foo(int a)
	{
		Sample s = new Sample();
		s.bar(a);
	}

	public void bar(int a)
	{
		x = a;
	}

}


/*----------------------------------------------------------------------------------------------------------------------	 
	Soru: Bir sınıfın metodunun non-static mi, static mi olduğuna nasıl karar vereceğiz?
	
	Cevap: Bu soru için basit bir kural şu şekilde benimsenebilir: "Bir metot non-static elemanlara doğrudan erişmeyecekse 
	static yapılmalıdır". Bu durumda "non-static bir metot için kesinlikle non-static bir elemana doğrudan erişiyordur" 
	anlamı çıkar. Bu da okunabilirliği artırır. Yani aslında "bir metodu yapmak non-static metotların okunabilirliğini
	artırır". Ayrıca non-static metotların sınıf dışında referans ve nokta operatörü ile çağrılması gerektiğinden static
	yapılabilecek olan ancak non-static bir metot boşu boşuna referans ile çağrılmış olur. 
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerini bulup ekrana yazdıran
	programı yazınız. 
	
	
	Sınıfın aşağdaki kullanım şekli sınıfların yararı 100 birim düşünülürse %1 civarındadır. Şüphesiz örnek farklı 
	yaklaşımlarla da yazılabilir. Sınıfın kullanımını göstermek için yazılmıştır. İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		EquationSolverApp.run();
	}
}

class EquationSolverApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("ikinci dereceden denklemin katsayılarını giriniz : ");
		System.out.print("a : ");
		double a = Double.parseDouble(kb.nextLine());
		System.out.print("b : ");
		double b = Double.parseDouble(kb.nextLine());
		System.out.print("c : ");
		double c = Double.parseDouble(kb.nextLine());
		
		QuadraticEquationRootInfo ri = EquationSolverUtil.findQuadraticEquationRoots(a, b, c);
		
		if(ri.exists)
			System.out.printf("x1 = %f, x2 = %f%n", ri.x1, ri.x2);
		else
			System.out.println("Gerçek kök yok.....");
	}
}

class QuadraticEquationRootInfo{
	public double x1, x2;
	public boolean exists;
}

class EquationSolverUtil{
	public static double getDelta(double a, double b, double c) 
	{
		return b * b - 4 * a * c;
	}
	
	public static QuadraticEquationRootInfo findQuadraticEquationRoots(double a, double b, double c) 
	{
		double delta = getDelta(a, b, c);
		QuadraticEquationRootInfo ri = new QuadraticEquationRootInfo();
		
		if(delta >= 0) {
			double sqrtDelta = Math.sqrt(delta);
			ri.x1 = (-b + sqrtDelta) / (2 * a);
			ri.x2 = (-b - sqrtDelta) / (2 * a);
			ri.exists = true;
		}
		
		return ri;
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Point p1, p2;
		
		p1 = new Point();
		p2 = new Point();
		
		p1.x = 10;
		p1.y = 20;
		p2.x = 15;
		p2.y = 25;
		
		p1.print();
		p2.print();
		
		int x = 13, y = 16;
		
		double d;
		
		d = p1.distance(x, y);
		
		System.out.printf("Distance : %f%n", d);
		
		d = p1.distance(p2);
		
		System.out.printf("Distance : %f%n", d);
		
		d = p1.distance();
		
		System.out.printf("Distance : %f%n", d);
	}
}


class Point{
	public int x;
	public int y;
	
	public double distance() 
	{
		return distance(0, 0);
	}
	
	public double distance(Point other) 
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b) 
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
19.01.2023 Perşembe - 18.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	Random sınıfının parametresiz nextInt metodu int türü sınırları içerisinde rasgele üretilmiş bir sayıya geri döner
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.println(r.nextInt());
		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Random sınıfının int parametreli nextInt metodyu [0, bound) aralığında rasgele üretilmiş int türden bir sayıya 
	geri döner
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d ", r.nextInt(100)); //[0, 100]
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Random sınıfında Java 17 ile birlikte dolaylı olarak iki tane int türden parametreli bir nextInt metodu da vardır.
	Anahtar Notlar: Java 17 ile birlikte RandomGenerator denilen bir arayüz (interface) eklenmiştir. Random sınıfı da 
	bu arayüzü desteklemektedir (implements). Bu arayüzle birlikte bir çok yeni meotot da Random sınıfına eklenmiştir.
	Arayüz kavramı ve anlatılan kısımların detayları ileride ele alınacaktır. Şu an için bu metotların Random sınıfına
	ait olduğunun bilinmesi yeterlidir 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d ", r.nextInt(20, 100)); //[20, 100]
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Java 17 öncesinde [a, b) aralığında rasgele sayı üretimi
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayiyi giriniz: ");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayiyi giriniz: ");
		int b = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d ", r.nextInt(b -a) + a); //[a, b)
		}
		
		System.out.println();
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	 Java 17 öncesinde [a, b] aralığında rasgele sayı üretimi
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayiyi giriniz: ");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayiyi giriniz: ");
		int b = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d ", r.nextInt(b -a + 1) + a); //[a, b]
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfının nextLong metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d%n", r.nextLong());
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfı Java 17 ile dolaylı olarak eklenen  nextLong metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d%n", r.nextLong(10_000_000_000L));
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfı Java 17 ile dolaylı olarak eklenen  nextLong metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d%n", r.nextLong(1L, 10_000_000_000L));
		}
		
		System.out.println();
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	  Random sınıfının nextDouble metodu [0, 1) aralığında rasgele üretilmiş double türden bir sayıya geri döner
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%f%n", r.nextDouble()); [0,1)
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfının Java 17 ile dolaylı olarak eklenen nextDouble metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%f%n", r.nextDouble(5));
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfının Java 17 ile dolaylı olarak eklenen nextDouble metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%f%n", r.nextDouble(3.14, 6.18));
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	  Random sınıfının nextBoolean metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%b%n", r.nextBoolean());
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	  Sınıf Çalışması: Hilesiz bir paranın yazı gelme olasılığının yaklaşık olarak 0.5 olduğunu bulan basit bir 
	simülasyon programı yazınız
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		CoinSumilation cs = new CoinSumilation();
		
		for(;;) {
			System.out.print("Parayi kac kez atmak istiyorsunuz?");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0)
				break;
			
			cs.run(n);
			
			System.out.printf("Yazı gelme olasiliği: %f%n", cs.p);
		}
	}
}


class CoinSumilation{
	public double p;
	
	public static int getTailCount(int n) 
	{
		java.util.Random r = new java.util.Random();
		int count = 0;
		
		for (int i = 0; i < n; i++) {
			count += r.nextInt(2);
		}
		
		return count;
	}
	
	public void run(int n) 
	{
		p = getTailCount(n) / (double)n;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	  Sınıf Çalışması: Hilesiz bir paranın yazı gelme olasılığının yaklaşık olarak 0.5 olduğunu bulan basit bir 
	simülasyon programı yazınız
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		CoinSumilation cs = new CoinSumilation();
		
		for(;;) {
			System.out.print("Parayi kac kez atmak istiyorsunuz?");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0)
				break;
			
			cs.run(n);
			
			System.out.printf("Yazı gelme olasiliği: %f%n", cs.p);
		}
	}
}


class CoinSumilation{
	public double p;
	
	public static int getTailCount(int n) 
	{
		java.util.Random r = new java.util.Random();
		int count = 0;
		
		for (int i = 0; i < n; i++) {
			if(r.nextBoolean())
				++count;
		}
		
		return count;
	}
	
	public void run(int n) 
	{
		p = getTailCount(n) / (double)n;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	  Sınıf Çalışması: İki zar atıldığında zarların (ikisinin de aynı) olasılığının yaklaşık olarak 
	hesaplayan simülasyon programını yazınız
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		SameDiceSumilation ds = new SameDiceSumilation();
		
		for(;;) {
			System.out.print("Kaç kez zar atmak istiyorsunuz?");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0)
				break;
			
			ds.run(n);
			
			System.out.printf("Çift gelme olasiliği: %f%n", ds.p);
		}
	}
}


class SameDiceSumilation{
	public double p;
	
	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(1, 7) == r.nextInt(1, 7); //java 17
	}
	
	public static int getSameCount(int n) 
	{
		java.util.Random r = new java.util.Random();
		int count = 0;
		
		for (int i = 0; i < n; i++) {
			if(areSame(r))
				++count;
		}
		
		return count;
	}
	
	public void run(int n) 
	{
		p = getSameCount(n) / (double)n;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	  Sınıf Çalışması: İki zar atıldığında zarların (ikisinin de aynı) olasılığının yaklaşık olarak 
	hesaplayan simülasyon programını yazınız
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		SameDiceSumilation ds = new SameDiceSumilation();
		
		for(;;) {
			System.out.print("Kaç kez zar atmak istiyorsunuz?");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0)
				break;
			
			ds.run(n);
			
			System.out.printf("Çift gelme olasiliği: %f%n", ds.p);
		}
	}
}


class SameDiceSumilation{
	public double p;
	
	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(6) + 1 == r.nextInt(6) + 1;
	}
	
	public static int getSameCount(int n) 
	{
		java.util.Random r = new java.util.Random();
		int count = 0;
		
		for (int i = 0; i < n; i++) {
			if(areSame(r))
				++count;
		}
		
		return count;
	}
	
	public void run(int n) 
	{
		p = getSameCount(n) / (double)n;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Tohum değeri setSeed metodu ile değiştirilebilir. Aşağıdaki örnek her çalıştırıldığında aynı dizilim elde edilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		java.util.Random r = new java.util.Random();
		
		r.setSeed(1500);
		
		for (int i = 0; i < 10; i++) 
			System.out.printf("%d ", r.nextInt(0, 100));
		
		
		System.out.println();
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	 Aşağıdaki örnekte rasgele üretilen ilk 10 sayının dizilimi her çalıştırmada farklı olur. İlk 10 sayının diziliminin
	 aynı gelme olasılığı çok düşüktür. İkinci üretilen 10 sayı klavyeden alınan tohum değerine göre üretilir. Bu durumda
	 örneğin her çalıştırmada tohum değeri 100 olarak girilirse ikinci 10 sayının dizilimi hep aynı olacaktır. Kodu 
	 çalıştırıp sonucu gözlemleyiniz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz :");
		long seed = Long.parseLong(kb.nextLine());
				
		for (int i = 0; i < 10; i++) 
			System.out.printf("%d ", r.nextInt(0, 100));
		
		System.out.println();
		
		r.setSeed(seed);
		
		for (int i = 0; i < 10; i++) 
			System.out.printf("%d ", r.nextInt(0, 100));
		
		System.out.println();
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Aşağıdaki örnekte rasgele üretilen ilk 10 sayının dizilimi her çalıştırmada farklı olur. İlk 10 sayının diziliminin
	 aynı gelme olasılığı çok düşüktür. İkinci üretilen 10 sayı klavyeden alınan tohum değerine göre üretilir. Bu durumda
	 örneğin her çalıştırmada tohum değeri 100 olarak girilirse ikinci 10 sayının dizilimi hep aynı olacaktır. Kodu 
	 çalıştırıp sonucu gözlemleyiniz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;){
			
			System.out.print("Kaç tane nokta üretilsin:");
			int count = Integer.parseInt(kb.nextLine());
			
			if(count <= 0)
				break;
			
			System.out.print("Minimum deger giriniz: ");
			int a = Integer.parseInt(kb.nextLine());
			
			System.out.print("Maksimum deger giriniz: ");
			int b = Integer.parseInt(kb.nextLine());
			
			
			System.out.println("------------------------------------");
			for (int i = 0; i < count; i++) {
				Point p = RandomPointGenerator.randomPoint(r, a, b);
				
				p.print();
			}
			System.out.println("------------------------------------");
		}
		
	}
}

class RandomPointGenerator{
	public static Point randomPoint(java.util.Random r, int a, int b) 
	{
		Point p = new Point();
		
		p.x = r.nextInt(a, b + 1);
		p.y = r.nextInt(a, b + 1);
		
		return p;
	}
}

class Point{
	public int x;
	public int y;
	
	public double distance() 
	{
		return distance(0, 0);
	}
	
	public double distance(Point other) 
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b) 
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Math sınıfının random metodu [0, 1) aralığında rasgele üretilmiş double türden bir değere geri döner. Bu metot 
	içsel olarak her çağıramda aynı Random nesnesini kullanır. Bu metot ilk kez çağrıldığında kullandığı Random
	nesnesi yaratılır ve her çağrıda bu nesne kullanılır. Aşağıdaki örneğin yaklaşık eşdeğeri:
	 
	 
	 java.util.Random r = new java.util.Random();
	
	 for (int i = 0; i < 10; ++i)
		System.out.println(r.nextDouble());
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.println(Math.random());
		}
		
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Nesne yaratılma adımları:
	1. Bellekten yer ayrılır
	2. non-static olan (ancak final olmayan) veri elemanlarına default degerler atanır
	3. Constructor (ctor) çağrılır
	
	Bu üç adımın sonunda new operatörünün ürettiği deger yani nesnenin adresi(referans) elde edilir.
	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	ctor aşağıdaki özelliklere sahip bir metottur:
	- Sınıfı yazan programcı sınıfa hiçbir ctor yazmazsa parametresiz ctor'u (default ctor) derleyici tarafından içi
	boş ve public olarak yazılır.
	
	- Sınıfı yazan programcı en az bir tane ctor yazarsa default ctor derleyici tarafından yazılmaz. Artık default
	ctor'un yazılıp yazılmayacağına programcı karar verecektir
	
	- ctor overload edilebilir (constructor overloading)
	
	- Sınıfın ctor'u sınıf ismi ile aynı olan ve geri dönüş değeri kavramı olmayan bir metottur. Geri dönüş değeri bilgisi
	yazılmaz. void da yazılmaz. Sınıf ismi ile aynı isimde bir metot yazılıp geri dönüş değeri bilgisi yazılırsa artık 
	bu metot ctor olmaz. Şüphesiz bu şekilde bir metot yazılmamalıdır
	
	- ctor non-static bir metottur
	
	- ctor new operatörü ile nesne yaratılması sırasında çağrılır. Hangi ctor'un çağrılacağı derleme zamanında new operatörü
	ile kullanımda geçilen argümanlara göre "method overload resolution" kurallarına göre belirlenir.
	
	- Programcı ctor'u çağıramaz. Programcı new operatörü ile ilgili ctor'un ÇAĞRILACAĞI kodun derleyici tarafından
	üretilmesini sağlar.
	
	- ctor'dan önce non-static ve final olmayan veri elemanlarına default değerler atanmış olur 
	
	- ctor içerisinde return tek başına ctor'u sonlandırmak amaçlı kullanılabilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1, s2, s3, s4, s5;
		
		s1 = new Sample();
		s2 = new Sample(10);
		s3 = new Sample(3.4);
		s4 = new Sample(3.4f);
		s5 = new Sample(10, 1000000L);
		
	}
}

class Sample{
	public Sample() //default ctor
	{
		System.out.println("default ctor");
	}
	
	public Sample(int a) 
	{
		System.out.println("ctor has a int parameter");
	}
	
	public Sample(float a)
	{
		System.out.println("ctor has a float parameter");
	}
	
	public Sample(double a)
	{
		System.out.println("ctor has a double parameter");
	}
	
	public Sample(int a, long b)
	{
		System.out.println("ctor has int and long parameter");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte Sample sınıfını yazan programcı int parametreli bir ctor yazdığı için derleyici artık default 
	ctor'u yazmaz. Default ctor'un olması artık sınıfı yazan programcının karar vermesi gereken bir durumdur
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1,s2;
		
		s1 = new Sample(); //error
		s2 = new Sample(10);

		
	}
}

class Sample{
	public Sample(int a) 
	{
		System.out.println("ctor has a int parameter");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	ctor'dan önce non-static ve final olmayan veri elemanlarına default değerler atanmış olur
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1, s2, s3;
		
		s1 = new Sample();
		System.out.println("-------------------------------");
		s2 = new Sample(10, true);
		System.out.println("-------------------------------");
		s3 = new Sample(20);

		
	}
}

class Sample{
	public int x;
	public boolean y;
	
	public Sample() 
	{
		System.out.printf("x = %d, y = %b%n", x, y);
	}
	
	public Sample(int a, boolean b) 
	{
		System.out.printf("x = %d, y = %b%n", x, y);
	}
	
	public Sample(int a) 
	{
		System.out.printf("x = %d, y = %b%n", x, y);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	ctor içerisinde birçok işlem yapılabilir. ctor'un temel işlevi nesne yaratıldığı noktada bir takım ilk işlemlerin
	o nesne için yapılmasını sağlamaktır. Bun ilk işlemlerdeen en çok karşılaşılanı ctor içerisinde non-static veri
	elemanlarına değer verilmesidir. Bu durumda nesne yaratıldığı zaman non-static veri elemanları istenen değerde
	gelmiş olur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1, s2, s3;
		
		s1 = new Sample();
		s2 = new Sample(10, true);
		s3 = new Sample(20);
		
		System.out.printf("s1.x = %d, s1.y = %b%n", s1.x, s1.y);
		System.out.printf("s2.x = %d, s2.y = %b%n", s2.x, s2.y);
		System.out.printf("s3.x = %d, s3.y = %b%n", s3.x, s3.y);
	}
}

class Sample{
	public int x;
	public boolean y;
	
	public Sample() 
	{
	}
	
	public Sample(int a, boolean b) 
	{
		x = a;
		y = b;
	}
	
	public Sample(int a) 
	{
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	ctor içerisinde istenirse return tek başşına ctor'u sonlandırmak için kullanılabilir. Örnekte konuyu anlatmak için
	kod bu şekilde yazılmıştır 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1, s2;
		
		s1 = new Sample(10);
		s2 = new Sample(-20);
		
		System.out.printf("s1.x = %d, s1.y = %b%n", s1.x, s1.y);
		System.out.printf("s2.x = %d, s2.y = %b%n", s2.x, s2.y);
	}
}

class Sample{
	public int x;
	public boolean y;
	
	public Sample(int a) 
	{
		if(a >= 0)
			return;
		
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Random sınıfının tohum değeri parametreli ctor'u. Tohum değeri parametreli ctor ile aşağıdaki şu işlem bir hamlede
	yapılmış olur:
	
	java.util.Random r = new java.util.Random();
	
	r.setSeed(100);
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random(100);
		
		for (int i = 0; i < 10; i++) 
			System.out.printf("%d ", r.nextInt(100));
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: Sınıfı yazan programcı default dışında bir ctor yazdığında default ctor'u yazıp yazmayacağına nasıl 
	karar verecektir? Aslında bu, yazılan sınıfa bağlıdır. Bunun için başlangıç düzeyinde şu soru sorulabilir:
	"Bu sınıf türünden nesnenin default durumu var mı?" Örneğin Random sınıfının default ctor'u bu nesnenin default
	durumudur. Yani tohum değerini her default ctor çağrısında mümkün olduğunca farklı verecek şekilde bir nesnenin
	yaratılmasını sağlamaktır. Ancak bazı özel durumlarda sınıfı kullanan başka sınıflar ya da ortamlar (framework) 
	default ctor olmasını isteyebilirler. Bu durumda programcı default ctor'u yazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Point sınıfı inceleme
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Point p1, p2, p3;
		
		p1 = new Point();
		p2 = new Point(100);
		p3 = new Point(100, 200);
		
		p1.print();
		p2.print();
		p3.print();
	}
}

class Point{
	public int x;
	public int y;
	
	public Point()
	{
	}
	
	public Point(int a)
	{
		x = a;
	}
	
	public Point(int a, int b)
	{
		x = a;
		y = b;
	}
	
	public double distance() 
	{
		return distance(0, 0);
	}
	
	public double distance(Point other) 
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b) 
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
}





/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex();
		Complex z2 = new Complex(-3, 4.56);
		Complex z3 = new Complex(4.3);
		
		z1.print();
		z2.print();
		z3.print();
	}
}


class Complex{
	public double real;
	public double imag;
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex(2, 5);
		Complex z2 = new Complex(-3, 4.56);
		Complex z;
		

		z = z1.add(z2);
		z.print();
		
		z = z1.add(3.4);
		z.print();
		
		z = Complex.add(3.5, z1);
		z.print();
		
	}
}


class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2)
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------

24.01.2023 Salı - 19.Ders


/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex(5, 10);
		Complex z2 = new Complex(-7, 20.56);
		Complex z;
		

		z = z1.subtract(z2);
		z.print();
		
		z = z1.subtract(3.4);
		z.print();
		
		z = Complex.subtract(3.5, z1);
		z.print();
		
	}
}


class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex(5, 10);
		Complex z2 = new Complex(-7, 20.56);
		Complex z;
		

		z = z1.multiply(z2);
		z.print();
		
		z = z1.multiply(3.4);
		z.print();
		
		z = Complex.multiply(3.5, z1);
		z.print();
		
	}
}


class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public static Complex multiply(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return new Complex(a1 * a2 - b1 * b2, a1 * b2 + a2 * b1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public static Complex multiply(double value, Complex z)
	{
		return multiply(value, 0, z.real, z.imag);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex multiply(double value)
	{
		return multiply(real, imag, value, 0);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex(5, 10);
		
		z1.inc(3);
		z1.print();
		z1.dec(3);
		z1.print();
		z1.inc();
		z1.print();
		//Complex z2 = z1.getComjugate();
		//z2.print();
		
		z1.getComjugate().print();
		z1.print();
		
	}
}


class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public static Complex multiply(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return new Complex(a1 * a2 - b1 * b2, a1 * b2 + a2 * b1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	public double getLength()
	{
		return getNorm();
	}
	
	public Complex getComjugate()
	{
		return  new Complex(real, -imag);
	}
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public static Complex multiply(double value, Complex z)
	{
		return multiply(value, 0, z.real, z.imag);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex multiply(double value)
	{
		return multiply(real, imag, value, 0);
	}
	
	public void inc(double value)
	{
		real += value;
	}
	
	public void inc()
	{
		inc(1);
	}
	
	public void dec(double value)
	{
		inc(-value);
	}
	
	public void dec()
	{
		dec(1);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	String Literal - string sabiti
	
	Derleyici bir String sabitini (string literal) gördüğünde ve bu string sabitinin özdeşini daha önce görmemişse 
	şöyle bir kod üretir: "Çalışma zamanında String türden bir nesne yarat, karakterlerini bu nesneye aktar ve o
	nesnenin referansını (adresini) ver"
	
	print ve println metotlarının String parametreli overload'ları argüman olarak aldıkları String referansına 
	ilişkin yazıyı ekrana basarlar
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s;
		
		s = "istanbul";
		
		System.out.println(s);
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	printf metodunda s format karakteri ile String referansına ilişkin yazı formatlanıp ekrana basılabilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s;
		
		s = "istanbul";
		
		System.out.printf("Yazı: %s%n", s);
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Scanner sınıfının nextLine metodu ile klavyeden bir yazı alınabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir yazı giriniz: ");
		String s = kb.nextLine();
		
		System.out.printf("Yazı: %s%n", s);
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Immutable class: Bir nesnenin non-static veri elemanları sınıfı kullanan programcı tarafından değiştirilemiyor
	ise bu tarz sınıflara "immutable class" denir. Immutable sınıfların nasıl yazılabileceği ileride ele alınacaktır.
	immutable sınıfların avantajlı ve dezavantajlı durumları vardır. Bunlar da zamanla anlaşılacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte Complex sınıfı türünden bir nesnenin real veri elemanı değiştirilmiştir. Yani nesnenin içeriği
	değiştirilebilir. Dolayısıyla bu sınıf "immutable" bir sınıf değildir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		Complex z = new Complex(33, 11);
		
		z.print();
		
		z.real *= 2;
		
		z.print();
		
	}
}

class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public static Complex multiply(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return new Complex(a1 * a2 - b1 * b2, a1 * b2 + a2 * b1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	public double getLength()
	{
		return getNorm();
	}
	
	public Complex getComjugate()
	{
		return  new Complex(real, -imag);
	}
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public static Complex multiply(double value, Complex z)
	{
		return multiply(value, 0, z.real, z.imag);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex multiply(double value)
	{
		return multiply(real, imag, value, 0);
	}
	
	public void inc(double value)
	{
		real += value;
	}
	
	public void inc()
	{
		inc(1);
	}
	
	public void dec(double value)
	{
		inc(-value);
	}
	
	public void dec()
	{
		dec(1);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------	 
	İki aynı türden referans == ve != operatörü ile karşılaştırılabilir. Bu karşılaştırma adres (referans) karşılaştırmasıdır.
	Bu durumda == operatörü iki referans da aynı nesneyi gösteriyorsa true, göstermiyorsa false değerini üretir. Benzer 
	şekilde != operatörü iki referans da aynı nesneyi gösteriyorsa false, göstermiyorsa true değerini üretir. 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		Complex z1, z2;
		z1 = new Complex(3, 4);
		z2 = z1; //new Complex(3, 4);
		
		System.out.println(z1 == z2 ? "Aynı nesne" : "Farklı nesne");
		System.out.println(z1 != z2 ? "Farklı nesne" : "Aynı nesne");
		
	}
}

class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public static Complex multiply(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return new Complex(a1 * a2 - b1 * b2, a1 * b2 + a2 * b1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	public double getLength()
	{
		return getNorm();
	}
	
	public Complex getComjugate()
	{
		return  new Complex(real, -imag);
	}
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public static Complex multiply(double value, Complex z)
	{
		return multiply(value, 0, z.real, z.imag);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex multiply(double value)
	{
		return multiply(real, imag, value, 0);
	}
	
	public void inc(double value)
	{
		real += value;
	}
	
	public void inc()
	{
		inc(1);
	}
	
	public void dec(double value)
	{
		inc(-value);
	}
	
	public void dec()
	{
		dec(1);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfı immutable bir sınıftır. Yani String nesnesine ilişkin yazı üzerinde değişiklik yapılamaz. Yazı 
	üzerinde değişiklik yapan metotlar değişiklik yapılmış yazıyı içeren yeni bir String nesnesinin referansına geri
	dönekler. Örneğin bir yazının tamamını büyük harfe çeviren toUpperCase non-static metodu yazı üzerinde değişiklik
	yapamayacağı için tamamı büyük harflerden oluşan yazıyı içeren yeni bir String referansına geri döner 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının toUpperCase metodu 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		String upper = s.toUpperCase();
		
		System.out.println(s);
		System.out.println(upper);
		
		System.out.println(s == upper ? "Aynı nesne" : "Farklı nesne");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfı immutable bir sınıftır. Yani String nesnesine ilişkin yazı üzerinde değişiklik yapılamaz. Yazı 
	üzerinde değişiklik yapan metotlar değişiklik yapılmış yazıyı içeren yeni bir String nesnesinin referansına geri
	dönekler. Örneğin bir yazının tamamını büyük harfe çeviren toUpperCase non-static metodu yazı üzerinde değişiklik
	yapamayacağı için tamamı büyük harflerden oluşan yazıyı içeren yeni bir String referansına geri döner 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının toUpperCase metodu 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		String upper = s.toLowerCase();
		
		System.out.println(s);
		System.out.println(upper);
		
		System.out.println(s == upper ? "Aynı nesne" : "Farklı nesne");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte mantıksal olarak değiştirilmiş bir yazı ile akışın devam ettiği bir kod yazılmıştır. Şüphesiz
		s = s.toLowerCase()
	ifadesi toLowerCase metodunun döndürdüğü referensın s'ye atanmasıdır. Bu durumda s artık yeni nesneyi gösterir
	duruma gelir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		s = s.toLowerCase();
		
		System.out.println(s);
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının length isimli metodu ile yazının karakter sayısı elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
			
		System.out.printf("Length : %d%n", s.length());
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının charAt metodu ile herhangi bir indeksteki karakter elde edilebilir. Indeks numarası sıfır değerinden
	başlar
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		int length = s.length();
		
		for (int i = 0; i < length; ++i) 
			System.out.printf("%c ", s.charAt(i));
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının charAt metoduna pozitif ya da negatif bakımdan sınırlar dışında değer verilirse exception oluşur.
	Indeks değerleri [0, length) aralığıdır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		char ch = s.charAt(-4);
		
		System.out.println(ch);
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Yazıların eşitlik karşılaştırması == ve != operatörleri ile yapılamaz. Çünkü == ve != karşılaştırması bir referans
	karşılaştırmasıdır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz : ");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz : ");
		String s2 = kb.nextLine();
		
		System.out.println(s1 == s2 ? "Aynı yazı": "Farklı yazılar");
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Yazıların eşitlik karşılaştırması equals metodu ile yapılabilir. Bu metot büyük-küçük harf duyarlı (case sensitive)
	karşılaştırma yapar
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz : ");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz : ");
		String s2 = kb.nextLine();
		
		System.out.println(s1.equals(s2) ? "Aynı yazı": "Farklı yazılar");
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının equalsIgnoreCase metodu ile büyük-küçük harf duyarsız (case insensitive) eşitlik karşılaştıması
	yapılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz : ");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz : ");
		String s2 = kb.nextLine();
		
		System.out.println(s1.equalsIgnoreCase(s2) ? "Aynı yazı": "Farklı yazılar");
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Derleyici özdeş string sabitleri (string literals) için aynı nesnenin referansını verecek bir kod üretir. Yani bir
	string sabiti ile özdeş kaç tane sabit olursa olsun hepsi için aynı nesnenin referansı elde edilir. Yeniden nesne
	yaratılmaz. Aşağıdaki örnekte yine referans karşılaştırması yapılmıştır. Ancak s1 ve s2'ye atanan string'ler özdeş
	olduğundan aynı adresler tutulmuş olur. Örnek durumu anlatmak için yazılmıştır
	
	Anahtar Notlar: Derleyicinin özdeş string'ler için aynı adresi vermesi String sınıfının immutable olmasındandır. Aksi
	olsaydı yani String sınıfı immutable olmasaydı aynı adres verildiğinde herhangi bir referans üzerinden değişiklik 
	yapılması durumunda diğer referans da değişiklik yapılmış yazıyı görürdü. Bu durumda bu tasarım programcının hatalı 
	kodlar yazma olasılığını artırırdı.
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s1 = "istanbul";
		String s2 = "istanbul";
		
		System.out.println(s1 == s2 ? "Aynı yazı": "Farklı yazılar");
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının yazı içerisinde karakter arayan indexOf metodu
	indexOf metotları bulamamaları durumunda -1 değerine geri dönerler
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "İyi bir programcı olmak için çok çalışmak gerekir!";
		char ch = 'z';
		
		int idx = s.indexOf(ch);
		
		System.out.printf("Index : %d%n", idx);
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının yazı içerisinde yazı arayan indexOf metodu
	indexOf metotları bulamamaları durumunda -1 değerine geri dönerler
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "İyi bir programcı olmak için çok çalışmak gerekir!";
		String str = "bir";
		
		int idx = s.indexOf(str);
		
		System.out.printf("Index : %d%n", idx);
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının yazı içerisinde belirli bir indeksten itibaren yazı arayan indexOf metodu
	indexOf metotları bulamamaları durumunda -1 değerine geri dönerler
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "İyi bir programcı olmak için çok çalışmak gerekir!";
		String str = "bir";
		
		int idx = s.indexOf(str, 3);
		
		System.out.printf("Index : %d%n", idx);
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının lastIndexOf metotları
	lastIndexOf metotları bulamamaları durumunda -1 değerine geri dönerler
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "İyi bir programcı olmak için çok bir çok çalışmak gerekir!";
		String str = "bir";
		
		int idx = s.lastIndexOf(str);
		
		System.out.printf("Index : %d%n", idx);
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisinden kaç tane olduğunu döndüren 
	countString isimli metodu ve büyük küçük harf duyarsız olarak çalışan countStringIgnore isimli metodu yazınız ve
	aşağıdaki kod ile test ediniz.
	
	Örneğin
	
	aaa yazısı içerisinde aa dan 2(iki) tane vardır
	
	bbaaa
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		CountStringTest.run();
	}
}

class CountStringTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan %d adet var%n", count);
			count = StringUtil.countStringIgnoreCase(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan büyük küçük harf duyarsız olarak %d adet var%n", count);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static int countString(String s1, String s2)
	{
		int count = 0;
		int idx = 0;
		
		while((idx = s1.indexOf(s2, idx)) != -1) {
			++count;
			++idx;
		}
		
		return count;
	}
	
	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisinden kaç tane olduğunu döndüren 
	countString isimli metodu ve büyük küçük harf duyarsız olarak çalışan countStringIgnore isimli metodu yazınız ve
	aşağıdaki kod ile test ediniz.
	
	Örneğin
	
	aaa yazısı içerisinde aa dan 2(iki) tane vardır
	
	bbaaa
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		CountStringTest.run();
	}
}

class CountStringTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan %d adet var%n", count);
			count = StringUtil.countStringIgnoreCase(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan büyük küçük harf duyarsız olarak %d adet var%n", count);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static int countString(String s1, String s2)
	{
		int count = 0;
		int idx = -1;
		
		while((idx = s1.indexOf(s2, idx + 1)) != -1)
			++count;
		
		return count;
	}
	
	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisinden kaç tane olduğunu döndüren 
	countString isimli metodu ve büyük küçük harf duyarsız olarak çalışan countStringIgnore isimli metodu yazınız ve
	aşağıdaki kod ile test ediniz.
	
	Örneğin
	
	aaa yazısı içerisinde aa dan 2(iki) tane vardır
	
	bbaaa
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		CountStringTest.run();
	}
}

class CountStringTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan %d adet var%n", count);
			count = StringUtil.countStringIgnoreCase(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan büyük küçük harf duyarsız olarak %d adet var%n", count);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static int countString(String s1, String s2)
	{
		int count = 0;
	
		for(int i = 0; (i = s1.indexOf(s2, i)) != -1; ++i, ++count)
			;
		
		return count;
	}
	
	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisinden kaç tane olduğunu döndüren 
	countString isimli metodu ve büyük küçük harf duyarsız olarak çalışan countStringIgnore isimli metodu yazınız ve
	aşağıdaki kod ile test ediniz.
	
	Örneğin
	
	aaa yazısı içerisinde aa dan 2(iki) tane vardır
	
	bbaaa
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		CountStringTest.run();
	}
}

class CountStringTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan %d adet var%n", count);
			count = StringUtil.countStringIgnoreCase(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan büyük küçük harf duyarsız olarak %d adet var%n", count);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static int countString(String s1, String s2)
	{
		int count = 0;
	
		for(int i = -1; (i = s1.indexOf(s2, i + 1)) != -1; ++count)
			;
		
		return count;
	}
	
	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	İçerisinde hiçbir karakter bulunmayan yani length bilgisi sıfır olan String'lere boş string denir	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = ""; //empty string
		
		System.out.printf("Length : %d%n", s.length());
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir String'in boş olup olmadığının test edilmesi (kötü yöntem)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;) {
			System.out.print("Bir yazi giriniz:");
			String s = kb.nextLine();
			
			if("elma".equals(s))
				break;
			
			System.out.println("".equals(s) ? "Boş string" : "Boş string değil");
		}
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir String'in boş olup olmadığının test edilmesi (kötü yöntem)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;) {
			System.out.print("Bir yazi giriniz:");
			String s = kb.nextLine();
			
			if("elma".equals(s))
				break;
			
			System.out.println(s.length() == 0 ? "Boş string" : "Boş string değil");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	BBir String'in boş olup olmadığının test edilmesinin isEmpty metodu ile yapılaması en iyi tekniktir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;) {
			System.out.print("Bir yazi giriniz:");
			String s = kb.nextLine();
			
			if("elma".equals(s))
				break;
			
			System.out.println(s.isEmpty() ? "Boş string" : "Boş string değil");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının trim metodu baştaki ve sondaki boşluk (whitespace) karakterlerinin atılmış olduğu yeni bir string
	referansına geri döner. Aradaki boşluklara dokunmaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;) {
			System.out.print("Bir yazi giriniz:");
			String s = kb.nextLine();
			
			if("elma".equals(s))
				break;
			
			System.out.printf("[%s]%n", s);
			System.out.printf("[%s]%n", s.trim());
		}
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden kullanıcı adı ve şifre isteyen basit bir ATM uygulamasının bir parçasını aşağıdaki
	açıklmalara göre yazınız.
	Açıklamalar:
	- Kullanıcı ad ve şifresi en fazla 3(üç) kez denenebilecektir.
	
	- Denemeler sırasında doğru giriş yapılırsa "Giriş başarılı", başarısız denemeler "Giriş başarız" yazısı basılacaktır
	
	- En fazla 3 deneme sonucunde başarısız olunmuşsa "Giriş başarısız. Artık deneme hakkınız biti!..." yazısı basılacaktır
	
	- Uygulama adı ve şifrenin doğruluğu program içerisinde belirlene bir kullanıcı adı ve şifre ile yapılacaktır.
	
	- Uygulama genel düşünerek yazılmalıdır
	
	- ATM uygulamasının sürekli çalıştığı varsayımıyla yazılması önerilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		AtmApp.run(3);
	}
}

class AtmApp{
	
	public static void doSucces(AtmCard atmCard, java.util.Scanner kb)
	{
		System.out.println("-----------------------------------");
		System.out.println("Giriş başarılı");
		System.out.println("-----------------------------------");
	}
	
	public static void doFail(AtmCard atmCard, java.util.Scanner kb)
	{
		System.out.println("-----------------------------------");
		System.out.println("Giriş başarısız. Artık deneme hakkınız bitti!....");
		System.out.println("-----------------------------------");
	}
	
	public static void doWorkForCard(AtmCard atmCard, int tryNum, java.util.Scanner kb)
	{
		int i = 0;
		
		for (;  i < tryNum; ++i) {
			System.out.print("Kullanıcı adını giriniz : ");
			String username = kb.nextLine();
			System.out.print("Şifrenizi giriniz : ");
			String password = kb.nextLine();
			
			if(atmCard.isvalid(username, password))
				break;
			
			if(i != tryNum - 1)
				System.out.printf("Giriş başarısız. %d giriş hakkınız kaldı!...%n", tryNum -1 - i);
			
		}
		
		if(i != tryNum)
			doSucces(atmCard, kb);
		else
			doFail(atmCard, kb);
		
	}
	
	public static void run(int tryNum)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.println("Hoş geldiniz!...");
			AtmCard atmCard = new AtmCard();
			
			doWorkForCard(atmCard, tryNum, kb);
		}
	}
}


class AtmCard{
	public String username;
	public String password;
	
	public AtmCard()
	{
		username = "orhan";
		password = "2023";
	}
	
	public boolean isvalid(String uname, String passwd)
	{
		return uname.equals(username) && passwd.equals(password);
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

09.02.2023 Perşembe - 20.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Yukarıdaki uygulamanın kullanıcı adını karttan okuyan sadece şifre isteyen versiyonu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		AtmApp.run(3);
	}
}

class AtmApp{
	
	public static void doSucces(AtmCard atmCard, java.util.Scanner kb)
	{
		System.out.println("-----------------------------------");
		System.out.println("Giriş başarılı");
		System.out.println("-----------------------------------");
	}
	
	public static void doFail(AtmCard atmCard, java.util.Scanner kb)
	{
		System.out.println("-----------------------------------");
		System.out.println("Giriş başarısız. Artık deneme hakkınız bitti!....");
		System.out.println("-----------------------------------");
	}
	
	public static void doWorkForCard(AtmCard atmCard, int tryNum, java.util.Scanner kb)
	{
		int i = 0;
		
		for (;  i < tryNum; ++i) {
			System.out.print("Şifrenizi giriniz : ");
			String password = kb.nextLine();
			
			if(atmCard.isvalid(password))
				break;
			
			if(i != tryNum - 1)
				System.out.printf("Giriş başarısız. %d giriş hakkınız kaldı!...%n", tryNum -1 - i);
			
		}
		
		if(i != tryNum)
			doSucces(atmCard, kb);
		else
			doFail(atmCard, kb);
		
	}
	
	public static void run(int tryNum)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.println("Hoş geldiniz!...");
			AtmCard atmCard = new AtmCard();
			
			doWorkForCard(atmCard, tryNum, kb);
		}
	}
}


class AtmCard{
	public String username;
	public String password;
	
	public AtmCard()
	{
		username = "orhan";
		password = "2023";
	}
	
	public boolean isvalid(String passwd)
	{
		return passwd.equals(password);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının concat metodu ile yazı birleştirmesi (concatenation) yapılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String firstName = "Orhan";
		String lastName = "ÖZTÜRK";
		
		String fullName;
		
		fullName = firstName.concat(" ").concat(lastName);
		
		System.out.println(fullName);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının concat metodu ile yazı birleştirmesi (concatenation) yapılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String firstName = "Orhan";
		String lastName = "Öztürk";
		
		String fullName;
		
		fullName = firstName.concat(" ").concat(lastName.toUpperCase());
		
		System.out.println(fullName);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	+ operatörünün iki operandı da String türündense, bu durumda bu operatör operandlara ilişkin yazıların birleştirilmiş
	olduğu yeni bir String referansını üretir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String firstName = "Orhan";
		String lastName = "Öztürk";
		
		String fullName;
		
		fullName = firstName +  " " + lastName;
		
		System.out.println(fullName);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	+ operatörünün iki operandı da String türündense, bu durumda bu operatör operandlara ilişkin yazıların birleştirilmiş
	olduğu yeni bir String referansını üretir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s1 = "ankara";
		String s2 = "istanbul";
		

		s1 += "-"; //s1 = (String)(s1 + "-");
		s1 += s2;
		
		System.out.println(s1);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	+ operatörünün operandlarından biri String türündense diğer operandın String karşılığı elde edilerek birleştirme
	yapılır. Bu durumda derleyici bir kod üretir. Dönüşümün detayları ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bugün hava kac derece?");
		int degree = Integer.parseInt(kb.nextLine());
		
		String prefix = "Bugün hava ";
		String suffix = " derece";
		
		String message = prefix + degree + suffix;
		
		System.out.println(message);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte println metodu birleştirilmiş yazıyı argüman olarak alır ve ekrana basar. Şüphesiz birleştirme
	işlemini println yapmaz. Çünkü metot çağrılmadan önce argüman ilişkin ifade hesaplanıri elde edilen değer ile
	metot çağrılır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bugün hava kac derece?");
		int degree = Integer.parseInt(kb.nextLine());
				
		System.out.println("Bugün hava " + degree + " derece");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir yazının tersini döndüren reverse isimli metodu StringUtil sınıfı
	içerisinde yazınız ve aşağıdaki kod ile test ediniz.
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		ReverseTest.run();
	}
}

class ReverseTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String str = kb.nextLine();
			
			if ("elma".equals(str))
				break;
			
			System.out.printf("Yazının tersi:%s%n", StringUtil.reverse(str));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static String reverse(String str)
	{
		String s = "";
		
		for (int i = str.length() - 1; i >= 0; --i)
			s += str.charAt(i);
		
		return s;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının substring metotları
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "ankara";
		System.out.println(s.substring(2));
		System.out.println(s.substring(2, 5));
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının substring metoduna beginIndex olarak yazının uzunluğu verilirse boş string referansına geri döner.
	Yazının uzunluğundan büyük indeks numarası verildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "ankara";
		System.out.println( s.substring(s.length()).isEmpty() ? "Boş string" : "Boş string değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının substring metoduna beginIndex ve endIndex değerleri sınırlar içerisinde olması koşuluyla (length dahil)
	aynı değer verilirse boş string referansına geri döner
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "ankara";
		System.out.println( s.substring(3, 3).isEmpty() ? "Boş string" : "Boş string değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		System.out.println("Java" + 10 + 20);
		System.out.println("Java" + (10 + 20));
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden elma girilene kadar alınan yazıların arasında - karakteri olacak birleştirilmiş bir
	String oluşturan programı yazınız.
	Örneğin ankara istanbul izmir girilirse -> ankara-istanbul-izmir
	Örneğin: ankara girilirse -> ankara
	Açıklamalar:
	- Tamamı whitespace karakterlerden oluşan ve boş string yazıya eklenmeyecektir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		ConcatWithHyphenApp.run();
	}
}

class ConcatWithHyphenApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Yazıları girmeye baslayınız:");
		String str = "";
		String s;
		
		while (!(s = kb.nextLine()).equals("elma")) {
			if(s.trim().isEmpty())
				continue;
			
			str += s + "-";
		}
		
		if(!str.isEmpty())
			str = str.substring(0, str.length() - 1);
		
		System.out.println(str);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden elma girilene kadar alınan yazıların arasında - karakteri olacak birleştirilmiş bir
	String oluşturan programı yazınız.
	Örneğin ankara istanbul izmir girilirse -> ankara-istanbul-izmir
	Örneğin: ankara girilirse -> ankara
	Açıklamalar:
	- Tamamı whitespace karakterlerden oluşan ve boş string yazıya eklenmeyecektir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		ConcatWithHyphenApp.run();
	}
}

class ConcatWithHyphenApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Yazıları girmeye baslayınız:");
		String str = "";
		
		for (;;) {
			String s = kb.nextLine();
			
			if(s.trim().isEmpty())
				continue;
			
			if("elma".equals(s))
				break;
			
			if(!str.isEmpty())
				str += "-";
			
			str += s;
		}
		
		System.out.println(str);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden elma girilene kadar alınan yazıların arasında - karakteri olacak birleştirilmiş bir
	String oluşturan programı yazınız.
	Örneğin ankara istanbul izmir girilirse -> ankara-istanbul-izmir
	Örneğin: ankara girilirse -> ankara
	Açıklamalar:
	- Tamamı whitespace karakterlerden oluşan ve boş string yazıya eklenmeyecektir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		ConcatWithHyphenApp.run();
	}
}

class ConcatWithHyphenApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Yazıları girmeye baslayınız:");
		String str = "";
		
		for (;;) {
			String s = kb.nextLine();
			
			if(s.trim().isEmpty())
				continue;
			
			if("elma".equals(s))
				break;
			
			str += s + "-";
		}
		
		if(!str.isEmpty())
			str = str.substring(0, str.length() - 1);
			
		System.out.println(str);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının startsWith metodu 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Web adresini giriniz : ");
		String url = kb.nextLine();
		
		if(!url.startsWith("http://"))
			url = "http://" + url;
		
		System.out.println(url);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının endsWith metodu 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Web adresini giriniz : ");
		String url = kb.nextLine();
		
		if(!url.startsWith(".com"))
			url = url + ".com";
		
		System.out.println(url);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Email adresini giriniz : ");
		String email = kb.nextLine();
		
		int atIdx = email.indexOf('@');
		
		if(atIdx != -1 && atIdx != email.length() - 1) {
			if(email.substring(atIdx + 1).lastIndexOf('.') == -1)
				email += ".com";
			System.out.println(email);
		} 
		else
			System.out.println("Geçersiz email");
	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Character sınıfının isXXX metotları
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		int whitespaceCount = 0, letterCount = 0, digitCount = 0;
		
		int len = s.length();
		
		for (int i = 0; i < len; i++) {
			char c = s.charAt(i);
			
			if(Character.isWhitespace(c))
				++whitespaceCount;
			else if(Character.isLetter(c))
				++letterCount;
			else if(Character.isDigit(c))
				++digitCount;
			else
				System.out.printf("%c", c);
		}
		
		System.out.println();
		System.out.printf("Bosluk sayisi: %d%n", whitespaceCount);
		System.out.printf("Harf sayisi: %d%n", letterCount);
		System.out.printf("Rakam sayisi: %d%n", digitCount);
	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Character sınıfının toXXX metotları
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		int len = s.length();
		
		for (int i = 0; i < len; i++) {
			char c = s.charAt(i);
			
			if(!Character.isLetter(c))
				continue;
			
			c = Character.isLowerCase(c) ? Character.toUpperCase(c) : Character.toLowerCase(c);
			
			System.out.printf("%c", c);
			
		}
		
		System.out.println();
	
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir yazının ilk harfi büyük geri kalan harfleri küçük olacak şekilde ve
 	harf dışı karakterler de aynı kalacak şekilde bir yazı döndüren capitalize isimli metodu StringUtil sınıfı 
 	içerisinde yazınız ve aşağıdaki kod ile test ediniz.
 	Örnek: jAVA Programcısı ÇOK çalışmalıdır -> Java programcısı çok çalışmalıdır 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		CapitalizeTest.run();
	}
}

class CapitalizeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();		
			
			
			System.out.printf("(%s)%n", StringUtil.capitalize(s));
			
			if ("elma".equals(s))
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static String capitalize(String str)
	{
		return str.isEmpty() ? "": Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase();
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir yazının ilk harfi büyük geri kalan harfleri küçük olacak şekilde ve
 	harf dışı karakterler de aynı kalacak şekilde bir yazı döndüren capitalizeWS isimli metodu StringUtil sınıfı 
 	içerisinde yazınız ve aşağıdaki kod ile test ediniz. Metot yazının başında boşluk karakterleri olsa bile ilk 
 	boşluk olmayan harfi büyütecek şekilde yazılacaktır
 	Örnek:   jAVA Programcısı ÇOK çalışmalıdır ->   Java programcısı çok çalışmalıdır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		CapitalizeTest.run();
	}
}

class CapitalizeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();		
			
			
			System.out.printf("(%s)%n", StringUtil.capitalizeWS(s));
			
			if ("elma".equals(s))
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static String capitalizeWS(String str)
	{
		int i;
		int len = str.length();
		
		for (i = 0; i < len && Character.isWhitespace(str.charAt(i)); i++) 
			;
		
		return i == len ? str : str.substring(0, i) + Character.toUpperCase(str.charAt(i)) + str.substring(i + 1).toLowerCase();
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir yazının sadece başındaki boşluk karakterlerini atan trimLeading ve
 	sadece sonundaki boşluk karakterlerini atan trimTrailing isimli metotları StringUtil sınıfı içerisinde yazınız ve 
 	aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		TrimLeadingTrailingTest.run();
	}
}

class TrimLeadingTrailingTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();		
			
			if ("elma".equals(s))
				break;
			
			System.out.printf("(%s)%n", StringUtil.trimLeading(s));			
			System.out.printf("(%s)%n", StringUtil.trimTrailing(s));			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static String trimLeading(String str)
	{
		int i;
		int len = str.length();
		
		for (i = 0; i < len && Character.isWhitespace(str.charAt(i)); i++) 
			;

		return str.substring(i);
	}
	
	public static String trimTrailing(String str)
	{
		int i;
		
		for (i = str.length() - 1; i >= 0 && Character.isWhitespace(str.charAt(i)); --i) 
			;

		return str.substring(0, i + 1);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

12.02.2023 Pazar - 21.Ders


/*----------------------------------------------------------------------------------------------------------------------	 
	Java 11 ile birlikte String sınıfına strip, stripLeading ve stripTrailing metotları eklenmiştir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		StripMethodsTest.run();
	}
}

class StripMethodsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();		
			
			if ("elma".equals(s))
				break;
			
			System.out.printf("(%s)%n", s.strip());			
			System.out.printf("(%s)%n", s.stripLeading());
			System.out.printf("(%s)%n", s.stripTrailing());
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Java 11 ile birlikte String sınıfına isBlank metodu eklenmiştir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		IsBlankTest.run();
	}
}

class IsBlankTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();		
			
			if ("elma".equals(s))
				break;
			
			System.out.println(s.isBlank() ? "Yazı boş geçilemez" : "Yazı : (" + s +")");			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Java 11 ile birlikte String sınıfına repeat metodu eklenmiştir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		RepeatTest.run();
	}
}

class RepeatTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();		
			
			if ("elma".equals(s))
				break;
			
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());	
			
			System.out.println(s.repeat(count));			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının repeat metodu ile bir karakterin çoklanması
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		char ch = '*';
		
		System.out.println((ch + "").repeat(5));
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Aşağıda açıklanan metotları StringUtil yazınız ve aşağıdaki kod ile test ediniz
 	
 	public static String padLeading(String s, int len, char ch);
 	public static String padLeading(String s, int len);
 	public static String padTrailing(String s, int len, char ch);
 	public static String padTrailing(String s, int len);
 	
 	Açıklamalar:
 	- padLeading metodunun 3 parametreli overload'u ikinci parametresi ile aldığı len, birinci parametresi ile
 	aldığı yazının uzunluğundan büyükse yazıyı soldan (baştan) üçüncü parametresi ile aldığı karakter ile doldurulmuş
 	yeni bir String referansına geri dönecektir. Örneğin:
 		padLeading("ankara", 11, 'x'); çağrısı
 		
 		xxxxxankara
 	yazısını döndürecektir
 	
 	- len uzunluğu yazının uzunluğundan küçük veye eişitse aynı referansa geri dönecektir
 	
 	- padLeading metodunun 2 parametreli overload'u yazıyı soldan (baştan) space karakteri ile doduracaktır  
 	 
 	- padTrailing metotları benzer şekilde sağdan (sondan) dolduracak şekilde yazılacaktır
 	
 	- Örneği Java 11+ için yazınız
----------------------------------------------------------------------------------------------------------------------*/

package orhn;


class App {	
	public static void main(String [] args)
	{		
		PadLeadingTrailingTest.run();				
	}
}

class PadLeadingTrailingTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();		
			
			if ("elma".equals(s))
				break;
			
			System.out.print("Bir sayı giriniz:");
			int newLen = Integer.parseInt(kb.nextLine());
			
			
			System.out.printf("(%s)%n", StringUtil.padLeading(s, newLen, 'x'));			
			System.out.printf("(%s)%n", StringUtil.padLeading(s, newLen));			
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, newLen, 'x'));			
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, newLen));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil {
	public static String padLeading(String s, int len, char ch)
	{
		int length = s.length();
		
		return len <= length ? s : (ch + "").repeat(len - length) + s;
	}
	
 	public static String padLeading(String s, int len)
 	{
 		return padLeading(s, len, ' ');
 	}
 	
 	public static String padTrailing(String s, int len, char ch)
 	{
 		int length = s.length();
		
		return len <= length ? s : s + (ch + "").repeat(len - length);
 	}
 	
 	public static String padTrailing(String s, int len)
 	{
 		return padTrailing(s, len, ' ');
 	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Aşağıda açıklanan metotları StringUtil yazınız ve aşağıdaki kod ile test ediniz
 	
 	public static String padLeading(String s, int len, char ch);
 	public static String padLeading(String s, int len);
 	public static String padTrailing(String s, int len, char ch);
 	public static String padTrailing(String s, int len);
 	
 	Açıklamalar:
 	- padLeading metodunun 3 parametreli overload'u ikinci parametresi ile aldığı len, birinci parametresi ile
 	aldığı yazının uzunluğundan büyükse yazıyı soldan (baştan) üçüncü parametresi ile aldığı karakter ile doldurulmuş
 	yeni bir String referansına geri dönecektir. Örneğin:
 		padLeading("ankara", 11, 'x'); çağrısı
 		
 		xxxxxankara
 	yazısını döndürecektir
 	
 	- len uzunluğu yazının uzunluğundan küçük veye eişitse aynı referansa geri dönecektir
 	
 	- padLeading metodunun 2 parametreli overload'u yazıyı soldan (baştan) space karakteri ile doduracaktır  
 	 
 	- padTrailing metotları benzer şekilde sağdan (sondan) dolduracak şekilde yazılacaktır
 	
 	- repeat metodu ileride daha iyisi yazılacak
 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		PadLeadingTrailingTest.run();				
	}
}

class PadLeadingTrailingTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();		
			
			if ("elma".equals(s))
				break;
			
			System.out.print("Bir sayı giriniz:");
			int newLen = Integer.parseInt(kb.nextLine());
			
			
			System.out.printf("(%s)%n", StringUtil.padLeading(s, newLen, 'x'));			
			System.out.printf("(%s)%n", StringUtil.padLeading(s, newLen));			
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, newLen, 'x'));			
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, newLen));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil {
	public static String padLeading(String s, int len, char ch)
	{
		int length = s.length();
		
		return len <= length ? s : repeat(len - length, ch) + s;
	}
	
 	public static String padLeading(String s, int len)
 	{
 		return padLeading(s, len, ' ');
 	}
 	
 	public static String padTrailing(String s, int len, char ch)
 	{
 		int length = s.length();
		
		return len <= length ? s : s + repeat(len - length, ch);
 	}
 	
 	public static String padTrailing(String s, int len)
 	{
 		return padTrailing(s, len, ' ');
 	}
 	
 	public static String repeat(int count, String s)
 	{
 		String str = "";
 		
 		for(int i = 0; i < count; ++i)
 			str += s;
 		
 		return str;
 	}
 	
 	public static String repeat(int count, char ch)
 	{
 		return repeat(count, ch + "");
 	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının compareTo metodu 
		s1.compareTo(s2); 
	çağrısı için 
	1. Geri dönüş değeri negatif ise s1 yazısı, s2 yazısından önce gelir
	2. Geri dönüş değeri pozitif ise s2 yazısı, s1 yazısından önce gelir
	3. Geri dönüş değeri sıfır ise s1 ve s2 aynı yazılardır
	
	Karşılaştırma default olarak karakter tablosunda sıra numaraları kullanılarak, "lexicographically" olarak yapılır
 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s1 = kb.nextLine();		
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazı giriniz:");
			String s2 = kb.nextLine();
			
			int result = s1.compareTo(s2);
			
			System.out.printf("Result: %d%n", result);
			
			if(result < 0)
				System.out.printf("'%s', '%s' yazısından önce gelir%n", s1, s2);
			else if (result > 0)
				System.out.printf("'%s', '%s' yazısından önce gelir%n", s2, s1);
			else
				System.out.printf("'%s', '%s' aynı yazıdır%n", s1, s2);
		}
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının compareTo metodu 
		s1.compareTo(s2); 
	çağrısı için 
	1. Geri dönüş değeri negatif ise s1 yazısı, s2 yazısından önce gelir
	2. Geri dönüş değeri pozitif ise s2 yazısı, s1 yazısından önce gelir
	3. Geri dönüş değeri sıfır ise s1 ve s2 aynı yazılardır
	
	Karşılaştırma default olarak karakter tablosunda sıra numaraları kullanılarak, "lexicographically" olarak yapılır
 	compareTo metodu "case sensitive" olarak karşılaştırma yapar
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s1 = kb.nextLine();		
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazı giriniz:");
			String s2 = kb.nextLine();
			
			int result = s1.compareTo(s2);
			
			System.out.printf("Result: %d%n", result);
			
			if(result < 0)
				System.out.printf("'%s', '%s' yazısından önce gelir%n", s1, s2);
			else if (result > 0)
				System.out.printf("'%s', '%s' yazısından önce gelir%n", s2, s1);
			else
				System.out.printf("'%s', '%s' aynı yazıdır%n", s1, s2);
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının compareTo metodu 
		s1.compareTo(s2); 
	çağrısı için 
	1. Geri dönüş değeri negatif ise s1 yazısı, s2 yazısından önce gelir
	2. Geri dönüş değeri pozitif ise s2 yazısı, s1 yazısından önce gelir
	3. Geri dönüş değeri sıfır ise s1 ve s2 aynı yazılardır
	
	Karşılaştırma default olarak karakter tablosunda sıra numaraları kullanılarak, "lexicographically" olarak yapılır
 	compareTo metodu "case sensitive" olarak karşılaştırma yapar
 	Eğer "case sensitive" özelliğini devre dışı bırakacak isek compareToIgnoreCase metodunu kullanırız
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s1 = kb.nextLine();		
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazı giriniz:");
			String s2 = kb.nextLine();
			
			int result = s1.compareToIgnoreCase(s2);
			
			System.out.printf("Result: %d%n", result);
			
			if(result < 0)
				System.out.printf("'%s', '%s' yazısından önce gelir%n", s1, s2);
			else if (result > 0)
				System.out.printf("'%s', '%s' yazısından önce gelir%n", s2, s1);
			else
				System.out.printf("'%s', '%s' aynı yazıdır%n", s1, s2);
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının contains metodu. Bu metot case sensitive olarak çalışır. Aşağıdaki örnekte case insensitive olarak
	kontrol için yazının tamamı küçük harfe çevrilmiştir	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s1 = kb.nextLine();		
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazı giriniz:");
			String s2 = kb.nextLine();
						
			if(s1.toLowerCase().contains(s2.toLowerCase()))
				System.out.println("Yazı bulundu");
			else
				System.out.println("Yazı bulunamadı");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Genel olarak söylemek gerekirse Scanner'ın çalışma sistematiği dolayısıyla nextInt, nextLong ve nextDouble gibi
	metotlar aynı Scanner nesnesine ilişkin nextLine metodu aynı akışta çağrılmamalıdır. Bu yüzden klavye işlemlerinde 
	nextLine metodu dışındakileri gerekmedikçe kullanmıyor. Aşağıdaki programı çalıştırarak sonucu gözlemleyiniz. Daha 
	sonra no değerinin Integer sınıfının parseInt metodu çağrısı ile nextLine kullarak alıp yine sonucu gözlemleyiniz		
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Cihaz numarası giriniz");
			int no = kb.nextInt(); //Integer.parseInt(kb.nextLine());		
			
			if (no == 0)
				break;
			
			System.out.print("Cihaz adını giriniz");
			String name = kb.nextLine();
			
			System.out.printf("%d, %s%n", no, name);
		}
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir yazının Türkçe pangram olup olmadığını test eden isPangramTR ve İngilizce
	pangram olup olmadığını test eden isPangramEN metotlarını StringUtil sınıfı içerisinde yazınız ve aşağıdaki kod
	ile test ediniz.
	
	Pangram: İçerisinde özel isim olmayan ve ilgili dilin alfabesinin tüm karakterlerini içeren cümlelere denir
	
	Programda özel isim ve anlamlı olması durumu dikkate alınmayacaktır
	
	İngilizce: The quick brown fox jumps over the lazy dog.
	Türkçe: Pijamalı hasta yağız şoföre çabucak güvendi.		
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		IsPangramTest.run();
	}
}

class IsPangramTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		IsPangramTestTR.run(kb);
		IsPangramTestEN.run(kb);		
	}
}

class IsPangramTestEN {
	public static void run(java.util.Scanner kb)
	{		
		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();
			
			if ("exit".equals(s))
				break;
			
			System.out.println(StringUtil.isPangramEN(s) ? "is pangram" : "is not a pangram");						
		}				
	}
}

class IsPangramTestTR {
	public static void run(java.util.Scanner kb)
	{		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.println(StringUtil.isPangramTR(s) ? "Pangram" : "Pangram değil");						
		}				
	}
}

class StringUtil{
	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}
	
	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}
	
	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();
		
		for (int i = 0; i < len; i++)
			if(s.indexOf(alphabet.charAt(i)) == -1)
				return false;
		
		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir yazının Türkçe pangram olup olmadığını test eden isPangramTR ve İngilizce
	pangram olup olmadığını test eden isPangramEN metotlarını StringUtil sınıfı içerisinde yazınız ve aşağıdaki kod
	ile test ediniz.
	
	Pangram: İçerisinde özel isim olmayan ve ilgili dilin alfabesinin tüm karakterlerini içeren cümlelere denir
	
	Programda özel isim ve anlamlı olması durumu dikkate alınmayacaktır
	
	İngilizce: The quick brown fox jumps over the lazy dog.
	Türkçe: Pijamalı hasta yağız şoföre çabucak güvendi.	
	
	contains cözüm	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		IsPangramTest.run();
	}
}

class IsPangramTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		IsPangramTestTR.run(kb);
		IsPangramTestEN.run(kb);		
	}
}

class IsPangramTestEN {
	public static void run(java.util.Scanner kb)
	{		
		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();
			
			if ("exit".equals(s))
				break;
			
			System.out.println(StringUtil.isPangramEN(s) ? "is pangram" : "is not a pangram");						
		}				
	}
}

class IsPangramTestTR {
	public static void run(java.util.Scanner kb)
	{		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.println(StringUtil.isPangramTR(s) ? "Pangram" : "Pangram değil");						
		}				
	}
}

class StringUtil{
	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}
	
	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuwxvyz");
	}
	
	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();
		
		for (int i = 0; i < len; i++)
			if(!s.contains(alphabet.charAt(i) + ""))
				return false;
		
		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki örnek için İngilizce alfabedeki karakterler karakter tablosunda sıralı olduğundan isPangramEN metodu
	aşağıdaki gibi de yazılabilir. Şüphesiz yukarıdaki yaklaşım daha geneldir 			
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		IsPangramTestEN.run();
	}
}

class IsPangramTestEN {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		for (;;) {
			System.out.print("Input a text:");
			String s = kb.nextLine();
			
			if ("exit".equals(s))
				break;
			
			System.out.println(StringUtil.isPangramEN(s) ? "is pangram" : "is not a pangram");						
		}				
	}
}

class StringUtil{
	public static boolean isPangramEN(String s)
	{
		s = s.toLowerCase();
		
		for (char c = 'a'; c < 'z'; ++c) 
			if(!s.contains(c + ""))
				return false;
		
		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n tane rasgele üretilmiş Türkçe alfabedeki
	karakterlerden oluşan bir yazı döndüren getRandomTextTR ile n tane rasgele üretilmiş İngilizce alfabedeki
	karakterlerden oluşan bir yazı döndüren getRandomTextEN metotlarını StringUtil sınıfı içerisinde yazınız ve 
	aşağıdaki kod ile test ediniz  		
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		GetRandomTextTRENTest.run();
	}
}

class GetRandomTextTRENTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = kb.nextInt();
			
			if (n <= 0)
				break;
			
			System.out.printf("Şifre:%s%n", StringUtil.getRandomTextTR(r, n));
			System.out.printf("Password:%s%n", StringUtil.getRandomTextEN(r, n));
			
			
			System.out.printf("Şifre:%s%n", StringUtil.getRandomTextTR(n));
			System.out.printf("Password:%s%n", StringUtil.getRandomTextEN(n));
		}				
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static String getRandomTextTR(java.util.Random r, int n)
	{
		return getRandomText(r, n, "abcçdefgğhıijklmnoöprsştuüvyzABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ");	
	}
	
	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new java.util.Random(), n);
	}
	
	public static String getRandomTextEN(java.util.Random r, int n)
	{
		return getRandomText(r, n, "abcdefghijklmnopqrstuwxvyzABCDEFGHIJKLMNOPQRSTUWXVYZ");
	}
	
	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new java.util.Random(), n);
	}
	
	public static String getRandomText(java.util.Random r, int n, String sourceText)
	{
		String str = "";
		int len = sourceText.length();
		
		for(int i = 0; i < n; ++i)
			str += sourceText.charAt(r.nextInt(len));
		
		return str;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

14.02.2023 - Salı  22.Ders


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir yazının palindrom olup olmadığını test eden isPalindrome metodunu
	yazınız ve aşağıdaki kod ile test ediniz.
	Palindrom: Yalnızca alfabetik karakterleri tersten okunduğunda aynı olan yazılara palindrom denir. Detayların gözardı
	edilmesi koşuluyla bu tanım yazılabilir.
	
	Örnek:
	Ey Edip Adana'da pide ye!	-> eyedipadanadapideye
	Anastas mum satsana			-> anastasmumsatsana
	Ali Papila 					-> alipapila	   		
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		IsPalindromeTest.run();
	}
}

class IsPalindromeTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.println(StringUtil.isPalindrome(s) ? "Palindrom" : "Palindrom değil");
		}				
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		
		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));
			
			if(!Character.isLetter(cLeft)) {
				++left;
				continue;
			}
			
			char cRight = Character.toLowerCase(s.charAt(right));
			
			if(!Character.isLetter(cRight)) {
				--right;
				continue;
			}
			
			if(cLeft != cRight)
				return false;
			
			++left;
			--right;
		}
		
		return true;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir yazının palindrom olup olmadığını test eden isPalindrome metodunu
	yazınız ve aşağıdaki kod ile test ediniz.
	Palindrom: Yalnızca alfabetik karakterleri tersten okunduğunda aynı olan yazılara palindrom denir. Detayların gözardı
	edilmesi koşuluyla bu tanım yazılabilir.
	
	Örnek:
	Ey Edip Adana'da pide ye!	-> eyedipadanadapideye
	Anastas mum satsana			-> anastasmumsatsana
	Ali Papila 					-> alipapila	   		
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		IsPalindromeTest.run();
	}
}

class IsPalindromeTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.println(StringUtil.isPalindrome(s) ? "Palindrom" : "Palindrom değil");
		}				
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		boolean cLeftSelected = false, cRightSelected = false;
		char cLeft = '\0', cRight = '\0';
		
		while (left < right) {
			
			if(!cLeftSelected) {
				cLeft = Character.toLowerCase(s.charAt(left));
				
				if(!Character.isLetter(cLeft)) {
					++left;
					continue;
				}
				
				cLeftSelected = true;
			}
			
			if(!cRightSelected) {
				cRight = Character.toLowerCase(s.charAt(right));
				
				if(!Character.isLetter(cRight)) {
					--right;
					continue;
				}
				
				if(cLeft != cRight)
					return false;
				
				cRightSelected = true;
			
			}
			
			++left;
			--right;
			cRightSelected = cLeftSelected = false;
		}
		
		return true;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir yazının içerisindeki sondan ilk en uzun palindromu döndüren getLastLongestPalindrome
	isimli metodu yazınız ve aşağıdaki kod ile test ediniz. Yazı palindrom içermiyorsa metot boş String'e geri dönecektir.
	Örnek: adaeyedipadanadapideyeecealipapilaanastasmumsatsana
	Örnek: abcadaeyedipadanadapideyeecealipapilaanastasmumsatsanaaxyztuabc   		
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		GetLongestPalindromeTest.run();
	}
}

class GetLongestPalindromeTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			String str = StringUtil.getLastLongestPalindrome(s);
			
			if (!str.isEmpty()) {
				System.out.println("En uzun palindrom:");
				System.out.println(StringUtil.getLastLongestPalindrome(s));
			}
			else 
				System.out.println("Palindrom yok");
		}				
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static String getLastLongestPalindrome(String s)
	{
		String result = "";
		
		int end = s.length();
		
		while (end != 0) {
			int begin = 0;
			
			while (begin != end) {
				String str = s.substring(begin++, end);
				
				if(str.length() > 1 && isPalindrome(str) && result.length() < str.length())
					result = str;
			}
			
			--end;
		}
		
		return result;
		
	}
	
	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;
		
		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));
			
			if(!Character.isLetter(cLeft)) {
				++left;
				continue;
			}
			
			char cRight = Character.toLowerCase(s.charAt(right));
			
			if(!Character.isLetter(cRight)) {
				--right;
				continue;
			}
			
			if(cLeft != cRight)
				return false;
			
			++left;
			--right;
		}
		
		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: Java'da her temel türe karşılık gelen bir sınıf vardır. Bu sınıflara "sarmalayan sınıflar (wrapper classes)"
	denir. Sarmalayan sınıflar ileride detaylı olarak incelenecektir. Buna göre her temel tür için sarmalayan sınıflar
	şunlardır:	
	Tür				Sarmalayan Sınıf
	short				Short
	int					Integer
	long				Long
	byte				Byte	
	float				Float
	double				Double
	boolean 			Boolean
	char				Character
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Character sınıfı hariç sarmalayan sınıfların parseXXX static metotları ile yazılar ilgikli türden değerlere çevrilebilir.
	Bu metotlar genel olarak yazı sayıya çevrilemeyorsa exception fırlatırlar
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz:");
		String str = kb.nextLine();
		int a = Integer.parseInt(str);
		
		System.out.printf("%d * %d = %d%n", a, a, a * a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Integer sınıfının sayı sistemi (radix) parametreli parseInt metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		for (;;) {
			System.out.print("Sayi sistemini giriniz:");
			int radix = Integer.parseInt(kb.nextLine());
			
			if(radix <= 0)
				break;
			
			System.out.print("Bir sayi giriniz:");
			String str = kb.nextLine();
			
			int a = Integer.parseInt(str, radix);
			
			System.out.printf("%d * %d = %d%n", a, a, a * a);	
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının format metodu ile formatlanmış bir yazı elde edilebilir. Bu metodun kullanımı printf ile aynıdır.
	Yalnızca printf gibi ekrana basmak yerine formatlanmış yazıya ilişkin String referansına ger döner
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir tamsayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("Bir gerçek sayı giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		
		String str = String.format("a = %02d, b = %.20f", a, b);
		
		System.out.println(str);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Point sınıfının toString metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Point p1, p2, p3;
		
		p1 = new Point(100, 100);
		p2 = new Point();
		p3 = new Point(400);
		
		System.out.println(p1.toString());
		System.out.println(p2.toString());
		System.out.println(p3.toString());
		
	}
}

class Point{
	public int x;
	public int y;
	
	public Point()
	{
	}
	
	public Point(int a)
	{
		x = a;
	}
	
	public Point(int a, int b)
	{
		x = a;
		y = b;
	}
	
	public double distance() 
	{
		return distance(0, 0);
	}
	
	public double distance(Point other) 
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b) 
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
	
	public String toString()
	{
		return String.format("(%d, %d)", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfının toString metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Complex z = new Complex(3, 4);
		
		System.out.println(z.toString());
		
	}
}

class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public static Complex multiply(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return new Complex(a1 * a2 - b1 * b2, a1 * b2 + a2 * b1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	public double getLength()
	{
		return getNorm();
	}
	
	public Complex getComjugate()
	{
		return  new Complex(real, -imag);
	}
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public static Complex multiply(double value, Complex z)
	{
		return multiply(value, 0, z.real, z.imag);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex multiply(double value)
	{
		return multiply(real, imag, value, 0);
	}
	
	public void inc(double value)
	{
		real += value;
	}
	
	public void inc()
	{
		inc(1);
	}
	
	public void dec(double value)
	{
		inc(-value);
	}
	
	public void dec()
	{
		dec(1);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
	public String toString()
	{
		return String.format("|%.2f, %.2f| = %f", real, imag, getNorm());
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının valueOf metotları ile temel türlerin yazı karşılığı elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10;
		String s = String.valueOf(a); 
		
		System.out.println(s);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının replace metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		String str = "Bugün hava çok güzel. Bu çok güzel havada dolaşabilirler";
		
		str = str.replace("güzel", "kötü");
		
		System.out.println(str);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının replace metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		String str = "Java";
		
		str = str.replace('a', 'b');
		
		System.out.println(str);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 Sınıf Çalışması: Aşağıda açıklanan metotları StringUtil yazınız ve aşağıdaki kod ile test ediniz
 	
 	public static String padLeading(String s, int len, char ch);
 	public static String padLeading(String s, int len);
 	public static String padTrailing(String s, int len, char ch);
 	public static String padTrailing(String s, int len);
 	
 	Açıklamalar:
 	- padLeading metodunun 3 parametreli overload'u ikinci parametresi ile aldığı len, birinci parametresi ile
 	aldığı yazının uzunluğundan büyükse yazıyı soldan (baştan) üçüncü parametresi ile aldığı karakter ile doldurulmuş
 	yeni bir String referansına geri dönecektir. Örneğin:
 		padLeading("ankara", 11, 'x'); çağrısı
 		
 		xxxxxankara
 	yazısını döndürecektir
 	
 	- len uzunluğu yazının uzunluğundan küçük veye eişitse aynı referansa geri dönecektir
 	
 	- padLeading metodunun 2 parametreli overload'u yazıyı soldan (baştan) space karakteri ile doduracaktır  
 	 
 	- padTrailing metotları benzer şekilde sağdan (sondan) dolduracak şekilde yazılacaktır
 	
 	- Örneği Java 11 öncesi için yazınız
 	
 	- repeat metodunu döngü kullanmadan, String sınıfının Java 11 ile eklenen repeat metodunu da kullanmadan yazınız
---------------------------------------------------------------------------------------------------------------------*/


package orhn;

class App {	
	public static void main(String [] args)
	{		
		PadLeadingTrailingTest.run();				
	}
}

class PadLeadingTrailingTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();		
			
			if ("elma".equals(s))
				break;
			
			System.out.print("Bir sayı giriniz:");
			int newLen = Integer.parseInt(kb.nextLine());
			
			
			System.out.printf("(%s)%n", StringUtil.padLeading(s, newLen, 'x'));			
			System.out.printf("(%s)%n", StringUtil.padLeading(s, newLen));			
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, newLen, 'x'));			
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, newLen));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil {
	public static String padLeading(String s, int len, char ch)
	{
		int length = s.length();
		
		return len <= length ? s : repeat(len - length, ch) + s;
	}
	
 	public static String padLeading(String s, int len)
 	{
 		return padLeading(s, len, ' ');
 	}
 	
 	public static String padTrailing(String s, int len, char ch)
 	{
 		int length = s.length();
		
		return len <= length ? s : s + repeat(len - length, ch);
 	}
 	
 	public static String padTrailing(String s, int len)
 	{
 		return padTrailing(s, len, ' ');
 	}
 	 	
 	public static String repeat(int count, char ch)
 	{
 		return String.format("%" + count + "c", ' ').replace(' ', ch);
 	}
}

/*----------------------------------------------------------------------------------------------------------------------
 Java7 ile birlikte switch deyiminde String de kullanılabilmektedir. Bu durumda case bölümlerinin "String literal" 
 	olması gerekir. String sınıfı switch deyimi ile kullanıldığında karşılaştırma equals metodu ile yapılır
---------------------------------------------------------------------------------------------------------------------*/


package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Şehir ismini giriniz:");
		String name = kb.nextLine();
		
		switch (name.toLowerCase()) {
		case "istanbul":
		case "edirne":
		case "kocaeli":
			System.out.println("Marmara Bölgesi");
			break;
		case "kastamonu":
		case "bartın":
		case "zonguldak:":
				System.out.println("Batı karadeniz bölgesi");
				break;
		default:
			System.out.println("Geçersiz isim");
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	Benzer şekilde String "switch expression statement" ile de kullanılabilir
---------------------------------------------------------------------------------------------------------------------*/


package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Şehir ismini giriniz:");
		String name = kb.nextLine();
		
		switch (name.toLowerCase()) {
		case "istanbul", "edirne", "kocaeli" ->	System.out.println("Marmara Bölgesi");
		case "kastamonu", "bartın", "zonguldak:" -> System.out.println("Batı karadeniz bölgesi");
		default ->	System.out.println("Geçersiz isim");
		}
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
16.02.2023 Perşembe - 23.Ders

/*----------------------------------------------------------------------------------------------------------------------
  	Paketler (packages) ve isim arama (name lookup):
	
	Aşağıdaki maddelerde aksi belirtilmediği sürece "sınıf" kavramı aslında "user defined type" olarak kullanılacaktır.
	"User defined type" olarak yalnızca sınıflar yoktur. İleride ele alacağımız yine referans türleri olan "user defined
	type"'lar için de aksi belirtilmediği sürece maddeler geçerli olacaktır
	
	Anahtar Notlar: Java kaynak kodlarını içeren ve genellikle ".java" uzantılı bir dosyaya (derlenen dosyaya)
	"derleme birimi (compilation/translation unit)" denir. Eğer Java dosyasında birden fazla sınıf söz konusu ise herbir 
	sınıf bir derleme birimi gibi düşünülebilir
	
	Paketler:
		- javac her sınıf için ayrı bir ".class" uzantılı dosya (byte code) üretir. Bu işlem sınıflar aynı Java dosyasında 
	olsa bile bu şekilde yapılır
	
	- Bir sınıf herhangi bir pakette olabilir. Bir proje içerisinde kullanılan sınıfların aynı pakette olma zorunluluğu
	yoktur
	
	- Bir ".class" dosyasının ait olduğu pakete ilişkin bir dizinde (directory) bulunması gerekir. Aslında java dosyaları
	için böyle bir zorunluluk yoktur. Ancak birçok IDE bunu kendi içinde zorunlu tutar	
	
	- Bir sınıf bulunduğu paket dışında (başka bir paketin içerisinde), paket ismi ve nokta operatörü ile kullanılabilir.
	
	- Bir paket içerisinde bildirilen bir sınıfın farklı bir paketten kullanılabilmesi için public olarak bildirilmesi
	gerekir. public olarak bildirilmeyen bir sınıf ancak aynı paketteki diğer sınıflar tarafından kullanılabilir (friendly/internal)
	
	- Farklı paketteki sınıflar için byte kodların da uygun yerde olması gerekir. Uygulamanın başlatıldığı dizin tüm
	paketlere ilişkin dizinlerin olması gereken dizindir. Ancak bu durumun da ayrıntıları ve istisnaları vardır
	
	- Uygulamada kullanılan sınıflar içerisinde bir tane main metodu olmak zorunda değildir. Ancak şüphesiz "java" 
	programına verilen byte koda ilişkin sınıfta (bu kesinlikle sınıf olmalıdır) uygun main metodunun olması gerekir.
	main metodunun aşağıdaki yapıya sahip olması gerekir:
		public static void main(String [] args)
	java programına verilen main metoduna "giriş noktası (entry point)" denir
	
	- public olarak bildirilen bir sınıfın kendi ismiyle aynı isimde bir ".java" uzantılı dosyada olması zorunludur. Bu
	durumda bir ".java" uzantılı dosyada yalnızca dosya ismiyle aynı isimde olan bir sınıf public olarak bildirilebilir
	
	-  Bir java dosyası içerisinde public sınıf olmak zorunda değildir. public sınıf olacaksa dosya ismi ile aynı 
	isimde olan sınıf ancak olabilir
	
	- Bir java dosyası içerisinde dosya ismi ile aynı isimde sınıf olmak zorunda değildir.
	
	- Bir java dosyası içerisinde public olmayan istenildiği kadar sınıf yazılabilir. Bu sınıflar aynı pakette bildirilmiş
	olur
	
	- Aynı paket içerisinde aynı isimde birden fazla sınıf bildirimi geçersizdir.
	
	- Farklı paketler içerisinde aynı isimde sınıflar olabilir
	
	- Bir java dosyası içerisindeki sınıflar o java dosyasının başında bildirilen paket içerisinde olurlar.
	
	- Bir java dosyasında farklı paket bildirimleri yapılamaz
	
	- Hiç bir paket bildirimi olmayan java dosyalarında bildirilen sınıflar "isimsiz paket (unnamed package)" denilen
	bir paket içerisinde kabul edilirler. Ancak projelerde isimsiz paket içerisinde sınıf bildirimi yapılmamalıdır
	
	- Bir paket içerisinde alt paketler (sub package) olabilir. Alt paketler
	
		package <paket ismi>.<alt paket ismi>.<alt paket ismi> ...
				
	biçiminde bildirilir. Alt paketlerde bulunan sınıfların .class dosyaları paket hiyerarşisine ilişkin uygun alt dizinlerde
	bulunmalıdır
	
	- Paketler içiçe bile olsa farklı paketlerdir. Yani örneğin org.mali.util.numeric paketi içerisinde NumberUtil isimli
	bir sınıf varsa org.mali içerisinde de NumberUtil isimli bir sınıf olabilir. Bu isimler çakışmaz.
	
	- Paket isimleri genelde fimaya ilişkin tekil (unique) bir bilgi olan domain isimlerinden üretilir. Örneğin
	ORHN firmasının paketleri ve sınıfları domain ismi "orhn.org" olduğundan "org.orhn" paketi altında yazılabilir.
	Bu şekildeki yaklaşıma uyulmalıdır
	
	- Java'nın standart tüm paketleri java isimli bir paket altında toplanmıştır. java paketi altındaki paketler içerisinde
	başka paketler ve başka sınıflar bildirilmiştir
	
	- java.lang isimli paketi altında bulunan tüm sınıflar görülebilirdir (visible). Yani buradaki isimleri paket ismi
	ile kombine etmeye gerek yoktur (import bildirimi olmadan da doğrudan kullanılabilir)
	
	 
	com.orhn.app
	
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.math.geometry.Point;
import com.orhn.math.geometry.PointF;

class App {	
	public static void main(String [] args)
	{		
		Point p = new Point(2, 4);
		
		p.print();
		
		PointF pf = new PointF(2.3f, 3.4f);
		
		pf.print();
		
		pf.distance();
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

21.02.2023 Salı - 24.Ders


/*----------------------------------------------------------------------------------------------------------------------	 
	İsim arama (name lookup): Derleyici kullanılan bir ismi önce arar. Eğer bulursa erişim kontrolünü yapar yani doğru bir 
	biçimde kullanılıp kullanılmadığına bakar. Derleyici isim aramayı belirli kurallara göre yapar. Burada anlatılacak
	genel kurallar dışında başka detaylar da vardır. Bu detaylar da isim aramanın bir parçasıdır. Özel durumlar olarak
	düşünülebilir. Yani önce genel kurallar sonra da özel durumlar için kurallar anlatılacaktır  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Derleyici bildirimi yapılan isimleri bildirim noktasında aramaz
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;


class App {	
	public static void main(String [] args)
	{		
		int a = 50; //a aranmaz
		
		
	}
}

class Sample { //Sample aranamaz
	public static void foo() //foo aranmaz
	{
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Bir isim kod içerisinde iki şekilde kullanılabilir: nitelikli (qualified), niteliksiz (unqualified)
	Bir isim nokta operatörünün sağında kalıyorsa nitelikli, kalmıyorsa niteliksiz kullanılmış olur	
	
	Niteliksiz kullanılan isimler "niteliksiz isim arama (unqualified name lookup)" kurallarına göre, nitelikli
	kullanılan isimler de "nitelikli isim arama (qualified name lookup)" kurallarına göre aranır 
	
	Anahtar Notlar: Yukarıdaki tanımlarda nitelikli ve niteliksiz olmak olumlu veya olumsuz bir etki anlamında 
	düşünülmemelidir
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;


class App {	
	public static void main(String [] args)
	{		
		
		Sample s; //Sample niteliksiz aranır
		
		s = new Sample(); //s niteliksiz aranır, Sample niteliksiz aranır
		s.foo(12); //s niteliksiz aranır, foo nitelikli aranır 
		
		System.out.printf("s.x = %d%n", s.x); //s niteliksiz aranır, x nitelikli aranır
		
	}
}

class Sample { 
	public int x;
	
	public void foo(int a) 
	{
		x = a; //x ve a niteliksiz aranır
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Derleyici bir ismi bulduktan sonra erişim kontrolünü yapar.
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;


class App {	
	public static void main(String [] args)
	{		
		int a;
		
		a = 4.2; //error
		
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	1. Bir isim metot içerisinde kullanılmışsa, kullanıldığı yerden yukarıya doğru metot içerisinde aranır. Burada 
	kullanılan isimden önce bildirilen yerel değişkenler ile parametre değişken isimlerine bakılır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;


class App {	
	public static void main(String [] args)
	{		
		int a;
		
		a = 4;
	}
}

class Sample {
	public void foo(int x)
	{
		int a;
		
		a = x;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	2. İsim metodun ait olduğu sınıfın tamamında ancak tüm metotların dışında aranır. Burada sınıf içerisinde 
	bulunamazsa sırasıyla "doğrudan taban sınıfa (direct super class) ve dolaylı taban sınıflara (indirect super class)"
	da bakılır. Taban sınıf kavramı ileride detaylı bir biçimde ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;


class App {	
	public static void main(String [] args)
	{		
		Sample s = new Sample();
		
		s.foo(22);
		
		System.out.printf("s.a = %d%n", s.a);
	}
}

class Sample {
	public void foo(int x)
	{
		a = x;
	}
	
	public int a;
	
	public void bar(int a)
	{
		//....
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki iki kurala göre bir sınıfın veri elemanı ile aynı isimde metot parametre değişkeni veya yerel değişken
	bildirimi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;


class App {	
	public static void main(String [] args)
	{		
		Sample s = new Sample();
		
		s.foo(22);
		
		System.out.printf("s.a = %d%n", s.a);
	}
}

class Sample {
	public void foo(int x)
	{
		int a; //shadowing, masking, hiding
				
		a = x;
		
		System.out.printf("a = %d%n", a);
	}
	
	public int a;
	
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3. İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt ya da üst paketlere bakılmaz. Sadece ait olduğu 
	pakete bakılır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;


class App {	
	public static void main(String [] args)
	{		
		Sample s = new Sample();
		
		s.foo(22);
		
		System.out.printf("s.a = %d%n", s.a);
	}
}

class Sample {
	public int a;
	
	public void foo(int x)
	{
		a = x;
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3. İsim sınıfın ait olduğu paket içerisinde aranır. Burada alt ya da üst paketlere bakılmaz. Sadece ait olduğu 
	pakete bakılır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {	
	public static void main(String [] args)
	{		
		Sample s = new Sample(); //error
		
		s.foo(22);
		
		System.out.printf("s.a = %d%n", s.a);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Niteliksiz isim arama genel kuralları (else if biçiminde değerlendiriniz):
	4. "import on demand declaration" varsa o paketlere de bakar. Bu konu ileride ele alınacaktır
	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki kurallara göre isimsiz paket altında bulunan bir sınıfa başka bir paket içerisinden erişilemez. Nitelikli
	olarak da erişilemez. Yalnızca bu sebepten bile bir projede isimsiz paket altında sınıf bildirilmemelidir 
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {	
	public static void main(String [] args)
	{		
		Sample s = new Sample(); //error
		
		s.foo(22);
		
		System.out.printf("s.a = %d%n", s.a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	1. Aranacak ismin solunda sınıf ismi varsa isim ilgili sınıf içerisinde aranır. Bulunamazsa taban sınıflara da
	bakılır 	
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {	
	public static void main(String [] args)
	{		
		Sample.x = 23;
		Sample.foo();
		
		System.out.println(Sample.x);
	}
}

class Sample {
	public static int x;
	
	public static void foo()
	{
		System.out.println("foo");
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	2. Aranacak ismin solunda referans ismi varsa, isim referansa ilişkin sınıf içerisinde aranır. Bulunamazsa taban
	sınıflara da bakılır	
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {	
	public static void main(String [] args)
	{		
		Sample s = new Sample();
		
		s.x = 23;
		s.foo();
		
		System.out.println(s.x);
	}
}

class Sample {
	public int x;
	
	public void foo()
	{
		System.out.println("foo");
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Nitelikli isim arama genel kuralları (else if biçiminde değerlendiriniz):
	3. Aranacak ismin solunda paket ismi varsa, isim o paket içerisinde aranır. Alt ya da üst paketlere bakılmaz
		
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {	
	public static void main(String [] args)
	{		
		test.mest.Sample s;
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Alt paket isimleri niteliksiz isim aramaya dahil değildir. Yani aşağıdaki örnekte test ismi aranırken com.orhn.app
	içerisinde test paket ismi dikkate alınmaz. Niteliksiz kullanılan bir ismin paket ismi olarak bulunabilmesi için
	"source folder" içerisinde bir paket olarak bulunması gerekir. Ya da diğer bir deyişle üst paketinin olmaması gerekir
	
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {	
	public static void main(String [] args)
	{		
		test.Sample s;
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	import bildirimi genel olarak niteliklendirmeyi azaltmak için, dolayısıyla daha yalın ve açık (clean) kod yazımı 
	kullanılır. 
	
	Anahtar Notlar: import bildirimi bir kütüphaneyi "import etmek" anlamına GELMEZ.
	
	import bildirimleri iki şekilde kullanılabilir:
	1. Yıldızlı import bildirimi (import on demand declaration)
	2. Yıldızsız import bildirimi (import single type declaration)
	
	import bildirimleri ".java" dosyasında (compilation unit) paket bildiriminden sonra diğer bildirimlerden önce 
	yazılmalıdır. import bildirimleri birden fazla olabilir ve yazılış sırasının önemi yoktur. import bildirimi
	bildirildiği ".java" dosyasına özgüdür. Diğer derleme birimlerini etkilemez. import bildirimleri niteliksiz
	isim arama kurallarına ilişkindir. Nitelikli isim arama kurallarına dahil değildir
	
	
	Anahtar Notlar: "Yıldızlı ve Yıldızsız import bildirimi" tercümeleri kolay anlatmak için Oğuz Karan tarafından 
	uydurulmuştur. Teknik olarak "import with asterisk" ve "import without asterisk" DENİLMEMELİDİR.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Yıldızlı import bildiriminin (import on demand declaration) genel biçimi:
	import <paket ismi>[.alt paketler].*;
	
	Bu bildirim niteliksiz isim arama genel kurallarına göre aranan ismin içerisinde de bulunamaması durumunda arama için
	bakılacak paketi temsil eder. Yani adeta bir paketin başka bir paket içerisine isim arama anlamında enjekte edilmesidir.
	
	Daha açık olarak yıldızlı import bildirimleri derleyiciye "eğer niteliksiz bir ismi pakette bulamazsan yıldızlı
	import bildirimlerine ilişkin paketlere de bak" demektir	
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

import java.util.*;
import com.orhn.math.*;
import com.orhn.math.geometry.*;

class App {	
	public static void main(String [] args)
	{		
		Random r = new Random();
		Scanner kb = new Scanner(System.in);
		
		Complex z = new Complex(2, 1);
		Point p = new Point(100, 100);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Yıldızlı import bildirimlerine ilişkin paketlerin hepsine bakılır. Birden fazla paket içerisinde isim bulunursa
	error oluşur (ambiguity)	
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

import java.util.*;
import com.orhn.math.*;
import com.orhn.math.geometry.*;
import com.orhn.util.*;

class App {	
	public static void main(String [] args)
	{		
		Random r = new Random();
		Scanner kb = new Scanner(System.in);
		
		Complex z = new Complex(2, 1);
		Point p = new Point(100, 100);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Yıldızlı import bildiriminin kullanımı. Örnekte isimler için niteliklendirmenin azaltıldığına dikkat ediniz	
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

import java.util.*;
import com.orhn.math.geometry.*;

class App {	
	public static void main(String [] args)
	{		
		Scanner kb = new Scanner(System.in);
		Random r = new Random();
		
		System.out.print("Bir sayi giriniz : ");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; i++) {
			Point p = new Point(r.nextInt(-100, 100), r.nextInt(-100, 100));
			
			System.out.println(p.toString());
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Yıldızsız import bildiriminin (import single type declaration) genel biçimi:
	import <paket ismi>[.alt paketler].<sınıf ismi>;
	Burada sınıf ismi bir "user defined type" ismidir.
	
	Bu bildirim sınıf isminin doğrudan kullanılabileceğini belirtir. Bu bildirimin yazılabildiği durumda bu sınıf ismi
	için niteliksiz arama genel kuralları uygulanmaz. Programcı mümkün olduğunca bu import bildirimini tercih etmelidir.
	Zaten bir çok IDE program da programcıyı mümkün olduğunca bu bildirime yönlendirir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte 
		import java.util.Random;
	bildirimi "bu derleme biriminde Random ismi doğrudan kullanılabilir ve bu isim java.util.Random sınıfıdır"
	anlamına gelir	
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import com.orhn.math.geometry.Point;

class App {	
	public static void main(String [] args)
	{		
		Scanner kb = new Scanner(System.in);
		Random r = new Random();
		
		System.out.print("Bir sayi giriniz : ");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; i++) {
			Point p = new Point(r.nextInt(-100, 100), r.nextInt(-100, 100));
			
			System.out.println(p.toString());
		}
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte Sample sınıfının niteliksiz kullanımına ilişkin birden fazla yıldızsız import bildirimi yapılamaya
	çalışıldığından error oluşur. Örneke Sample ismi kullanılmasa bile import bildirimlerinde error oluşur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import test.Sample;
import mest.Sample; //error

class App {	
	public static void main(String [] args)
	{		
		Sample s;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte Sample ismi niteliksiz isim arama genel kuralları dolayısıyla com.orhn.app paketindekini bulur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import test.*;

class App {	
	public static void main(String [] args)
	{		
		Sample.foo();
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte Sample ismi yıldızsız import bildirimi ile yazıldığından test.Sample.foo metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import test.Sample;

class App {	
	public static void main(String [] args)
	{		
		Sample.foo();
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte import bildirimine ilişkin java dosyasında Sample isminde bir sınıf bildirimi olduğundan 
	yıldızsız import bildirimi geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import test.Sample; //error

class App {	
	public static void main(String [] args)
	{		
		Sample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("com.orhn.app.Sample.foo");
	}

}


/*----------------------------------------------------------------------------------------------------------------------	 
	Java 5 ile birlikte import static bildirimleri eklenmiştir. import static bildirimlerinin de iki biçimi vardır:
	
	1. Yıldızlı import static bildirimi (import static on demand declaration)
	2. Yıldızsız import static bildirimi (import static single type declaration)
	
	import static bildirimleri okunabilirliği etkilemedikten sonra kodu yalınlaştırır. Okunabilirliği etkilememesine
	dikkat edilmelidir. import static bildirimleri de diğer import bildirimleriyle aynı yere yazılı ve yine sıranın
	önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	
	Yıldızlı import static bildiriminin (import static on demand declaration) genel biçimi
	import static <paket ismi>.[alt paketler].<tür ismi>.*;
	
	Bu bildirim ile bildirimin yapıldığı derleme biriminde bildirime ilişkin türün tüm static elemanları doğrudan
	kullanılabilir duruma gelir.  Yani niteliksiz isim arama genel kurallarına göre eğer pakette bulunamazsa bu bildirime
	ilişkin tür içerisinde de aranır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;
import static java.lang.Math.*;

class App {	
	public static void main(String [] args)
	{		
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a));
		System.out.printf("log10(%f) = %f%n", a, log10(a));
	}
}


/*----------------------------------------------------------------------------------------------------------------------	
	Yıldızsız import static bildiriminin (import static single type declaration) genel biçimi
	import static <paket ismi>.[alt paketler].<tür ismi>.<static eleman ismi>;
	
	Bu bildirim ile belirtilen static eleman ilgili derleme biriminde doğrudan kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;
import static java.lang.Math.sqrt;
import static java.lang.Math.log10;

class App {	
	public static void main(String [] args)
	{		
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a));
		System.out.printf("log10(%f) = %f%n", a, log10(a));
	}
}


/*----------------------------------------------------------------------------------------------------------------------	
	Aşağıdaki örnekte doğrudan sqrt çağrısı için sınıfın int parametreli sqrt metodunun ismi bulunur. Bu durumda uygun
	metot bulunamayacağı için error oluşur. Anımsanacağı gibi isim bulunduktan sonra erişim kontrolü yapılır 
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;
import static java.lang.Math.sqrt;
import static java.lang.Math.log10;

class App {	
	public static void main(String [] args)
	{		
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a));
		System.out.printf("log10(%f) = %f%n", a, log10(a));
	}
	
	public static double sqrt(int a)
	{
		return Math.sqrt(a);
	}
	
}



-----------------------------------------------------------
-----------------------------------------------------------
23.02.2023 Perşembe - 25.Ders

/*----------------------------------------------------------------------------------------------------------------------
	Diziler (Arrays): Elemanları aynı türden olan ve elemanların bellekte peşpeşe olacak şekilde tutulduğu veri yapılarıdır.
	Java'da diziler sınıfsal olarak temsil edilir. Diziler bir referans türüdür. Öyleyse dizi türünden bir değişken bir
	referans değişkendir. Diziler heap'de yaratılırlar. Şüphesiz dizi referansı da stack'te olabilir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	T bir tür ismi olmak üzere T türden bir dizi referansı bildirimi Java'da iki şekilde yapılabilir:

	1. T [] a;
	2. T a[];

	Biz birinci biçimi tercih edeceğiz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String[] args) {
		int [] a; //Dizi referansı bildirimi
		double b[]; //Dizi referansı bildirimi
		boolean [] c; //Dizi referansı bildirimi
	}

}


/*----------------------------------------------------------------------------------------------------------------------
	[]'in referans bildiriminde bulunduğu yere göre farkı
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String[] args) {
		int [] a, b, c;
		int d[], e, f;

		a = 10; //error
		b = 12; //error
		c = 15; //error

		d = 12; //error
		e = 11;
		f = 56;
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Dizi yaratmak için new operatörü kullanılır. Dizi yaratmanın genel biçimi:
	new <tür>[<negatif olmayan int türüne dönüşebilen türden eleman sayısı>];
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String[] args) {
		int [] a;

		a = new int[10];

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Dizinin eleman sayısı sabit ifadesi olmak zorunda değildir. Dizinin eleman sayısı negatif değer olarak verildiğinde
	exception oluşur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayi giriniz:");
		int n = kb.nextInt();

		int [] a;

		a = new int[n];

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Dizinin eleman sayısı length isimli veri elemanı ile elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayi giriniz:");
		int n = kb.nextInt();

		int [] a;

		a = new int[n];

		System.out.printf("Dizinin eleman sayisi: %d%n", a.length);

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Dizinin length veri elemanı değiştitilemez. Aslında yaratılmış bir dizinin eleman sayısı değiştirilemediğinden
	length veri elemanı da değiştirilemez
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayi giriniz:");
		int n = kb.nextInt();

		int [] a;

		a = new int[n];

		System.out.printf("Dizinin eleman sayisi: %d%n", a.length);

		a.length = 40; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizinin elemanlarına [] operatörü ile erişilir. Bu operatör özel amaçlı, iki operandlı (binary) ve araek (infix)
	durumunda bir operatördür. Operatör birinci parametresi ile aldığı dizi referansın gösterdiği dizi nesnesinin, ikinci
	operandına ilişkin indeks numarasında bulunan elemana ilişkin değişkeni üretir. Index numarası int türüne dönüşebilen
	türden olmalıdır ve sıfırdan başlar
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayi giriniz:");
		int n = kb.nextInt();
		int [] a = new int[n];

		for (int i = 0; i < a.length; ++i)
			a[i] = i + 10;

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Dizinin elemanlarına erişim
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayi giriniz:");
		int n = kb.nextInt();
		int [] a = new int[n];

		for (int i = 0; i < a.length; ++i)
			a[i] = r.nextInt(100);

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%02d ", a[i]);

		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	[] operatörüne pozitif ya da negatif bakımdan sınırlar dışında bir indeks numarası verildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayi giriniz:");
		int n = kb.nextInt();
		int [] a = new int[n];

		for (int i = 0; i < a.length; ++i)
			a[i] = r.nextInt(100);

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%02d ", a[i]);

		System.out.println();

		System.out.printf("a[15] = %d%n", a[-2]);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir dizi yaratığında tüm elemanlarına default değerler atanır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayi giriniz:");
		int n = kb.nextInt();
		int [] a = new int[n];
		boolean [] b = new boolean[n];

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%02d ", a[i]);

		System.out.println();

		for (int i = 0; i < b.length; ++i)
			System.out.printf("%b ", b[i]);

		System.out.println();

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Dizilere ilkdeğer verilmesi (initialization) küme parantezi ile yapılır. Burada [] içerisindein boş bırakılması
	zorunludur. Dikkat edilirse aşağıdaki örnekte diziye ilkdeğer verilmiştir ancak diziyi gösteren referansa ilkdeğer
	verilmemiştir. Atama yapılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args) {
		int [] a = new int[]{1, 2, 3, 4, 5, 6};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Diziye ilkdeğer verilirken adresini tutan referansa da ilkdeğer veriliyorsa new operatörü kullanılması gerekmez
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args) {
		int [] a = {1, 2, 3, 4, 5, 6};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte diziye ilkdeğer verilirken referansa ilkdeğer verilmediği için new operatörü zorunludur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args) {
		int [] a;
		//a = new int[]{1, 2, 3, 4, 5, 6}; //geçerli
		a = {1, 2, 3, 4, 5, 6}; //error

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Diziye ilkdeğerler olarak verilen elemanlar sabit ifadesi olmak zorunda değildir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayi giriniz:");
		int val = kb.nextInt();

		int [] a = {val, val + 1, val + 3, 4, 5, 6};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametresi bir dizi referansı olabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.array.ArrayUtil;

class App {
	public static void main(String[] args) {
		int [] a = {1, 2, 3, 4, 5, 6};
		int [] b = {10, 20, 30, 40, 50};

		ArrayUtil.print(a);
		ArrayUtil.print(b);

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametresi bir dizi referansı olabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.array.ArrayUtil;

class App {
	public static void main(String[] args) {
		int [] a = {1, 2, 3, 4, 5, 6};
		int [] b = {10, 20, 30, 40, 50};

		ArrayUtil.print(a);
		ArrayUtil.swap(a, 2, 5);
		ArrayUtil.print(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametresi bir dizi referansı olabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import static com.orhn.util.array.ArrayUtil.*;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		Random r = new Random();
		System.out.print("Bir sayi giriniz : ");
		int [] a = new int[kb.nextInt()];

		fillRandomArray(r, a, 0, 99);
		print(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bir dizi referansı olabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import static com.orhn.util.array.ArrayUtil.*;

class App {
	public static void main(String[] args) {
		Scanner kb = new Scanner(System.in);
		Random r = new Random();
		System.out.print("Bir sayi giriniz : ");

		int [] a = getRandomArray(r, kb.nextInt(), 0, 99);

		print(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanlarının toplamına geri dönen sum isimli metodu
	ArrayUtil sınıfı içersinde yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import static com.orhn.util.array.ArrayUtil.*;

class App {
	public static void main(String[] args) {
		SumIntArrayTest.run();
	}
}

class SumIntArrayTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Birinci sayıyı giriniz:");
		int a = kb.nextInt();

		System.out.print("İkinci sayıyı giriniz:");
		int b = kb.nextInt();

		for (;;) {
			System.out.print("Dizinin eleman sayısını giriniz:");
			int count = kb.nextInt();

			if (count <= 0)
				break;

			int [] numbers = getRandomArray(r, count, a, b);

			print(numbers);
			System.out.printf("Toplam:%d%n", sum(numbers));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanları ters yüz eden reverse isimli metodu
	başka bir dizi kullanmadan yazınız ve aşağıdaki kod ile tes ediniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import static com.orhn.util.array.ArrayUtil.*;

class App {
	public static void main(String[] args) {
		ReverseArrayTest.run();
	}
}

class ReverseArrayTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;) {
			System.out.print("Dizinin eleman sayısını giriniz:");
			int count = kb.nextInt();

			if (count <= 0)
				break;

			int [] a = getRandomArray(r, count, 0, 99);

			print(2, a);
			reverse(a);
			print(2, a);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizinin elemanları ters yüz eden reverse isimli metodu
	başka bir dizi kullanmadan yazınız ve aşağıdaki kod ile tes ediniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import static com.orhn.util.array.ArrayUtil.*;

class App {
	public static void main(String[] args) {
		ReverseArrayTest.run();
	}
}

class ReverseArrayTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;) {
			System.out.print("Dizinin eleman sayısını giriniz:");
			int count = kb.nextInt();

			if (count <= 0)
				break;

			int [] a = getRandomArray(r, count, 0, 99);

			print(2, a);
			Util.reverse(a);
			print(2, a);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void reverse(int [] a)
	{
		int left = 0;
		int right = a.length - 1;

		while (left < right)
			swap(a, left++, right--);
	}

	public static void swap(int [] a, int i, int k)
	{
		int temp = a[i];
		a[i] = a[k];
		a[k] = temp;
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Java length bilgisi sıfır olan bir dizi yaratılablir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String[] args) {
		int [] a = new int[0];
		int [] b = {};
		int [] c;

		c = new int[]{};

		System.out.printf("Length: %d%n", a.length);
		System.out.printf("Length: %d%n", b.length);
		System.out.printf("Length: %d%n", c.length);
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının basamaklarından oluşan diziyi döndüren getDigits isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import static com.orhn.util.array.ArrayUtil.*;
import static com.orhn.util.NumberUtil.*;

class App {
	public static void main(String[] args) {
		GetDigitsTest.run();
	}
}

class GetDigitsTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();5

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		while (count-- > 0) {
			long a = r.nextLong();
			System.out.printf("a = %d%n", a);
			print(getDigits(a));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı iki tane int türden dizinin birleşiminden oluşan yeni bir dizi referansına
	geri dönen join isimli metodu yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import static com.orhn.util.array.ArrayUtil.*;
import static com.orhn.util.NumberUtil.*;

class App {
	public static void main(String[] args) {
		JoinArraysTest.run();
	}
}

class JoinArraysTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;) {
			System.out.print("Dizilerin eleman sayısını giriniz:");
			int count1 = kb.nextInt();
			int count2 = kb.nextInt();

			if (count1 <= 0 && count2 <= 0)
				break;

			int [] a = getRandomArray(r, count1, 0, 99);
			int [] b = getRandomArray(r, count2, 0, 99);

			print(2, a);
			print(2, b);
			int[] c = join(a, b);
			print(2, c);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
02.03.2023 Perşembe - 27.Ders

/*----------------------------------------------------------------------------------------------------------------------
	Dizilerin sıraya dizilmesi (sorting):
	Dizilerin sıraya dizilmesine yönelik pek çok algoritma vardır. Sıralama işleminin küçükten büyüğe yani artan
	sırada (ascending order) yapılmasına doğal sıralama (natural sort order) denir. Biz burada kabarcık sıralama (bubble sort)
	ve seçerek sıralama (selection sort) algoritmalarını kodlayacağız. Algoritmaların doğal sıralama olacak şekilde
	anlatılacaktır. Ancak her iki sıralama da (ascending ve descending) kodlanacaktır


	Anahtar Notlar: Algoritmaların karşılaştırılmasına yönelik iki ölçit vardır: hız (speed), kaynak kullanımı (resource usage)
	Burada baskın ölçüt hızdır. Biz kabarcık sıralama ve seçerek sıralama algoritmalarını bu bölümde karşılaştırmayacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Kabarcık sıralama algoritmasında dizinin yan yana iki elemanı karşılaştırılır duruma göre yer değiştirilir. Her yinelemede
	en büyük eleman daraltılmış dizinin sonuna gider. Bçöylece her yinelemede eskisinden bir geriye kadar gitmek
	yeterli olur
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import static com.orhn.util.array.ArrayUtil.*;

class App {
	public static void main(String[] args) {
		BubbleSortTest.run();
	}
}

class BubbleSortTest{
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;){
			System.out.print("Dizinini eleman sayısını giriniz : ");
			int n = Integer.parseInt(kb.nextLine());

			if(n <= 0)
				break;

			int [] a = getRandomArray(r, n, 0, 99);

			print(2, a);

			boolean desc = false;

			bubbleSort(a, desc);

			System.out.printf("%s sıralanmış dizi : %n", desc ? "Büyükten küçüğe" :  "Küçükten büyüğe");

			print(2, a);

		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Seçerek sıralama algoritmasında en küçük eleman bulunur, ilk eleman ile yer değiştirilir. Dizi bir daraltılır, aynı
	şey daraltılmış dizi için de yapılır. Böylece ilerlenir
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import static com.orhn.util.array.ArrayUtil.*;

class App {
	public static void main(String[] args) {
		SelectionSortTest.run();
	}
}

class SelectionSortTest{
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;){
			System.out.print("Dizinini eleman sayısını giriniz : ");
			int n = Integer.parseInt(kb.nextLine());

			if(n <= 0)
				break;

			int [] a = getRandomArray(r, n, 0, 99);

			print(2, a);

			boolean desc = true;

			selectionSort(a, desc);

			System.out.printf("%s sıralanmış dizi : %n", desc ? "Büyükten küçüğe" :  "Küçükten büyüğe");

			print(2, a);

		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Partition algoritması ve ArrayUtil sınıfının partition metodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.app.lottery.NumericLotteryApp;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args) {
		PartitionTest.run();
	}
}
class PartitionTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());

			if (count <= 0)
				break;

			System.out.print("Eşik değerini giriniz:");
			int threshold = Integer.parseInt(kb.nextLine());

			int [] a = ArrayUtil.getRandomArray(r, count, 0, 99);
			System.out.println("---------------------------------------------------------");
			ArrayUtil.print(2, a);
			int partitionPoint = ArrayUtil.partition(a, threshold);

			System.out.printf("Bölümleme Noktası:%d%n", partitionPoint);
			ArrayUtil.print(2, a);
			System.out.println("---------------------------------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

07.03.2023 Salı - 28.Ders

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre getHistogramData isimli metodu ArrayUtil sınıfı içerisinde yazınız ve
	test ediniz:
	Açıklamalar:
		- Metot int türden bir dizi ve int türden bir n sayısı alacaktır
			int [] getHistogramData(int [] a, int n)
		- Metot a dizisi içerisinde [0, n] arasındaki sayılardan hangisinin kaç tane olduğunu içeren bir sayaç
		dizisine geri dönecektir

		- Sayaç dizisinin her bir indeks numarsı [0, n] aralığındaki sayıyı temsil edecektir. Yani örneğin sıfır numaralı
		 indeksteki değer sıfır sayısının kaç tane olduğu bilgisini içerecektir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		GetHistogramTest.run();
	}
}

class GetHistogramTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());

			if (n <= 0)
				break;

			System.out.println("--------------------------------------------");
			int [] a = ArrayUtil.getRandomArray(r, n, 0, 10);
			ArrayUtil.print(a);
			int [] data = ArrayUtil.getHistogramData(a, 10);
			ArrayUtil.print(data);
			System.out.println("--------------------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	char türden diziler String sınıfına benzetilebilse de örneğin dizinin elemanları değiştitilebildiğinden String'den
	farklıdır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5};
		char [] c = {'a', 'n', 'k', 'a', 'r', 'a'};

		c[0] = Character.toUpperCase(c[0]);

		for (int i = 0; i < c.length; ++i)
			System.out.printf("%c", c[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının char türden dizi parametreli ctor'u ile char türden dizi içerisindeki karakterlerden oluşan bir String
	elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		char [] c = {'a', 'n', 'k', 'a', 'r', 'a'};

		String s = new String(c);
		//String s = new String(c, 2, 3);

		System.out.println(s);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının char türden dizi parametreli valueOf metodu ile char türden dizi içerisindeki karakterlerden oluşan
	bir String elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		char [] c = {'a', 'n', 'k', 'a', 'r', 'a'};

		String s = String.valueOf(c);

		System.out.println(s);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının char türden dizi parametreli valueOf metodu ile char türden dizi içerisindeki karakterlerden oluşan
	bir String elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		char [] c = {'a', 'n', 'k', 'a', 'r', 'a'};

		String s = String.valueOf(c, 2, 3);

		System.out.println(s);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının toCharArray metodu ile bir String'in karakterlerinden oluşan char türden bir dizi elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		String s = "ankara";

		char [] c = s.toCharArray();

		for (int i = 0; i < c.length; ++i)
			System.out.printf("%c ", c[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfının changeCase metodu ve test kodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.util.StringUtil;

class App {
	public static void main(String [] args)
	{
		ChangeCaseTest.run();
	}
}

class ChangeCaseTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();

			System.out.println(StringUtil.changeCase(s));

			if ("elma".equals(s))
				break;
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfının squeeze metodu ve test kodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.util.StringUtil;

class App {
	public static void main(String [] args)
	{
		SqueezeTest.run();
	}
}

class SqueezeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();

			if ("elma".equals(s1))
				break;

			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();

			System.out.println(StringUtil.squeeze(s1, s2));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Referans dizileri: Referans dizisinin yaratılması dizinin elemanlarıona ilişkin referansların gösterdiği nesnelerin
	de yaratılması anlamına gelmez. Bu durumda programcının referans dizisinin elemanları olan referanslara da uygun
	nesnelerin adreslerini vermesi gerekir. Aksi durumda nesne varmış gibi erişilmesi exception oluşturur. Aşağıdaki
	örnekte referans dizi yaratılmıştır. Ancak referansların gösterdiği nesneler olmadığı için ya da başka bir
	deyişle referansların içerisinde nesne göstermeyen adres bulunduğu için exception oluşur

	Anahtar Notlar: Programlamada kullanılmayan bir adresi temsil eden "null adres" denilen bir adres vardır. Java'da
	referansların default değerleri null değeridir. null adres "null" sabiti ile temsil edilir. null adres kavramı
	ileride daha detaylı olarak ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample [] samples = new Sample[10];

		//Sample s1 = new Sample(2);
		//s1.a;

		System.out.println("Dizi yaratildi:");

		for (int i = 0; i < samples.length; ++i)
			samples[i].a = i * 10;

		System.out.println("Dizinin elemanlarına ilişkin degerler yazdırılıyor:");

		for (int i = 0; i < samples.length; ++i)
			System.out.printf("%d", samples[i].a);

		System.out.println();

	}
}

class Sample{
	public int a;

	public Sample(int x)
	{
		a = x;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	yukarıdaki problemin bir çözümü aşağıdaki gibi olabilir.
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample [] samples = new Sample[10];

		//samples[0]; s0
		//samples[1]; s1

		//Sample s1 = new Sample(2);
		//s1.a;

		System.out.println("Dizi yaratildi:");

		for (int i = 0; i < samples.length; ++i)
			samples[i] = new Sample(i * 10);

		System.out.println("Dizinin elemanlarına ilişkin degerler yazdırılıyor:");

		for (int i = 0; i < samples.length; ++i)
			System.out.printf("%d ", samples[i].a);

		System.out.println();

	}
}

class Sample{
	public int a;

	public Sample(int x)
	{
		a = x;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Referans dizilerine ilkdeğer verilmesi
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(30);
        Sample p = new Sample(70);

		Sample []samples = {new Sample(20), s, p, new Sample(11), new Sample(15)}; //ilk deger verme

		System.out.println("Dizinin elemanlarına ilişkin degerler yazdırılıyor : ");
		for (int i = 0; i < samples.length; ++i)
			System.out.printf("%d ", samples[i].a);

		System.out.println();

	}
}

class Sample{
	public int a;

	public Sample(int x)
	{
		a = x;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Strimg dizileri pratikte çok karşılaştığımız referans dizilerindendir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String []cities = {"ankara", "istanbul", "izmir", "zonguldak"};

		for (int i = 0; i < cities.length; ++i)
			System.out.println(cities[i].toUpperCase());
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

16.03.2023 Perşembe - 29. Ders

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli metodu yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden
		elde edilen kalan ile belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ..., 6 ise "cumartesi"
		günlerine karşılık gelir

		- 1.1.1900 öncesindeki tarihler geçersiz sayılacaktır
		- getDayOfWeek metodu ile birlikte

		- İleride daha iyisi yazılacaktır parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin
		hafta sonu olup olmadığınıu test eden isWeekend ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız.
		Bu iki metot tarih geçerlilik kontrolü yapmayacaktır


----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.app.samples.dateapp.DateUtilApp;
import com.orhn.app.samples.dateapp.test.PrintRandomDateTest;

class App {
	public static void main(String [] args)
	{
		PrintRandomDateTest.run();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı en fazla üç basamaklı bir sayının Türkçe okunuşunu döndüren numToText3DigitsTR
	isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot 3 basamaktan büyük sayı kontrolü yapmayacaktır
		- Örnekler:
				123		-> yüzyirmiüç
				-123	-> eksiyüzyirmiüç
				203		-> ikiyüzüç
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import com.orhn.util.NumberUtil;

class App {
	public static void main(String [] args)
	{
		NumToText3DigitsTRTest.run();
	}
}

class NumToText3DigitsTRTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = Integer.parseInt(kb.nextLine());

		for (int i = 0; i < count; ++i) {
			int val = r.nextInt(-999, 1000);
			String fmt = (val < 0 ? "-%03d " : " %03d ") +  " -> %s%n";
			System.out.printf(fmt, Math.abs(val), NumberUtil.numToText3DigitsTR(val));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının en fazla üç basamaklı ayrılmış sayılarından
	oluşan diziyi döndüren getDigitsInThrees metodunu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test
	ediniz
	Örnekler:
	1234567 -> 1 234 567
	3456	-> 3 456
	567		-> 576

	21:37
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import com.orhn.util.NumberUtil;
import com.orhn.util.array.ArrayUtil;

class App {
	public static void main(String [] args)
	{
		GetDigitsTest.run();
	}
}

class GetDigitsTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = Integer.parseInt(kb.nextLine());

		for (int i = 0; i < count; ++i) {
			long a = r.nextLong();

			System.out.println("-----------------------------------------");
			System.out.println(a);
			ArrayUtil.print(NumberUtil.getDigits(a));
			ArrayUtil.print(NumberUtil.getDigitsInTwos(a));
			ArrayUtil.print(NumberUtil.getDigitsInThrees(a));
			System.out.println("-----------------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden int türden bir n sayısı için değer isteyiniz. n elemanlı bir String dizisi
	yaratınız. Bu dizinin her bir elemanını rasgele uzunlukta üretilmiş Türkçe karakterlerden oluşan yazılarla
	doldurunuz. Bu işlemden sonra StringUtil sınıfı içerisinde yazacağınız parametresi ile aldığı int türden bir String
	dizisinin elemanlarını, yine parametresi ile aldığı bir ayraç ile birleştirilmiş bir String'e geri dönen join isimli
	metodu çağırarak sonucu ekrana yazdırınız
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import com.orhn.util.StringUtil;
import com.orhn.util.array.ArrayUtil;

class App {
	public static void main(String [] args)
	{
		JoinWithDelimiterApp.run();
	}
}

class JoinWithDelimiterApp {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());

			if (count <= 0)
				break;


			String [] s = StringUtil.getRandomTextsTR(r, count, 5, 10);

			System.out.println("----------------------------------------------------");
			ArrayUtil.print(s);
			System.out.println(StringUtil.join(s, '-'));
			System.out.println("----------------------------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte split metodu space karakterini ayraç olarak kabul ederek yazıyı ayrıştırmıştır. Ancak split metodu
	regex (regular expression) kullandığından bu şekilde bir kullanım her karakter için aynı sonucu vermez. Ayraç tek bir
	karakterden oluşsa bile bu tarz bir kullanım tavsiye edilmez. Örneği split metoduna "." argümanını geçerek ve yazıda
	space yerine . koyarak çalıştırıp sonucu gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String str = "Bugün hava çok güzel";
		String []words = str.split(" ");

		for (int i = 0; i < words.length; ++i)
			System.out.printf("(%s)%n", words[i]);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	split metodunda kullanılacak ayraç(lar) [ ile ] arasında yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String str = "Bugün hava çok güzel.Bu güzel havada Ne çalışsak daha güzel olur.";
		String []words = str.split("[ .]");

		for (int i = 0; i < words.length; ++i)
			System.out.printf("(%s)%n", words[i]);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	split metodunda kullanılacak ayraç(lar) [ ile ] arasında yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String str = "Bugün hava çok güzel.Bu güzel havada Ne çalışsak daha güzel olur.";
		String []words = str.split("[.]");

		for (int i = 0; i < words.length; ++i)
			System.out.printf("(%s)%n", words[i]);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	split metodunda aşağıdaki kullanımda birden fazla ayraç yanyana geldiğinde aralarında kalan boş string de diziye
	eklenir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String str = "Bugün hava çok güzel. Bu güzel havada Ne çalışsak daha güzel olur. İyi bir java programcısı bu havada çalışır";
		String []words = str.split("[ .]");

		for (int i = 0; i < words.length; ++i)
			System.out.printf("(%s)%n", words[i]);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	split metodunda aşağıdaki kullanımda birden fazla ayraç yanyana geldiğinde aralarında kalan boş string de diziye
	eklenir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String str = "Bugün hava çok güzel. Bu güzel havada Ne çalışsak daha güzel olur. İyi bir java programcısı bu havada çalışır";
		String []words = str.split("[ .]+");

		for (int i = 0; i < words.length; ++i)
			System.out.printf("(%s)%n", words[i]);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	[ ve ] karakterlerinin ayraç olarak verilebilmesi için ters bölü ile yazılması gerekir. Anımsanacağı gibi bir
	String literal içerisinde ters bölü karakteri iki ters bölü ile yazılabilir. Aşağıdaki örneği inceleyiniz--------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String str = "Bugün hava çok güzel. Bu [[güzel]] havada Ne çalışsak daha güzel olur. İyi bir java programcısı bu havada çalışır";
		String []words = str.split("[\\]\\[.]+");

		for (int i = 0; i < words.length; ++i)
			System.out.printf("(%s)%n", words[i]);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
21.03.2023 Salı - 30.Ders

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden aşağıdaki formatta girilen bilgiyi ayrıştırarak ekrana sonuçları yazdıran programı
	yazınız:
	<ad soyad>:<ders adı>:<gg-aa-yyyy>:<gg-aa-yyyy>:<arasınav>:<final>
	Oğuz Karan:Matematik:04/04/2022:01/07/2022:78:67
	Barış Er:Radyo Haberleşmesi:03/04/2022:02/07/2022:89:100
	Ziya ÇAYLAN:PLC Programlama:10/04/2022:13/06/2022:90:98
	Emirhan Kabal:Fizik:07/03/2022:03/07/2022:85:75
	Ozan Yiğit:İstatistik:07/04/2017:19/06/2017:90:100
	Yunus Emre Uslu:Yazlım Geliştirme:28/04/2022:28/06/2022:60:70

	Açıklamalar:
		- Format geçerlilik kontrolü yapılmayacaktır
		- Formatta vize ve final notlarına göre vize * 0.4 + final * 0.6 formülü ile geçme notu hesaplanacak ve sınav
		tarihleri hangi güne geldiği de belirlenerek ekrana yazdırılacaktır
		- Ekran çıktısında "Geçti" ya da "Kaldı" bilgisi de olacaktır. Geçme notu 50 ve üstünde ise öğrenci geçmiş
		sayılacaktır.
		- Geçme notu round işlemi ile tamsayı olarak elde edilecektir
		- İleride daha iyisi yazılacaktır

		Örnek çıktı:
		-------------------------------------------
		Ad Soyad: Oğuz Karan
		Ders Adı: Matematik
		Arasınav Tarihi: 4 Nisan 2022 Pazartesi
		Final Tarihi: 1 Temmuz 2022 Cuma
		Arasınav Notu: 78
		Final Notu: 67
		Geçme Notu: 71
		Sonuç: Geçti
		-------------------------------------------
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;
import com.orhn.app.school.LectureInfoParserTest;

class App {
	public static void main(String [] args)
	{
		LectureInfoParserTest.run();
	}
}




/*----------------------------------------------------------------------------------------------------------------------
	Mademki, "T bir tür olmak üzere T[] a ifadesi a'nın gösterdiği dizinin herbir elemanının T olduğu" anlamına geliyorsa
	örneğin "int[][] a ifadesi a'nın gösterdiği dizinin herbir elemanının int türden bir dizi referansı" olduğu anlamına
	gelir. Bu durumda mantıksal bu referansın göstersiği dizi bir "dizi dizisidir".

	Dizi dizisi yaratılırken kullanılan operatörüne ilişkin ifadede tür isminden sıonra referans bildiriminde kullanılan
	[] kadar [] yazılmalıdır. Bu köşeli parantezlerin ilki ana dizinin uzunluğudur. Bu sebeple boş bırakılamaz. int [][]
	türden bir dizinin herbir elemanı olan dizi referanslarının gösterdiği dizilerin herbiri eşit uzunlukta ise bu durumda
	bu dizi mantıksal olarak int türden değerler içerern bir matrisi temsil eder. Bu anlamda bu tarz bir diziye "matris"
	denebilir. Yani ana dizinin uzunluğu matrisin satıur sayısı, uzunlukları aynı olan dizilerin uzunluğu da sütun sayısını
	temsil eder. Dizi dizisinde en az bir dizinin uzunluğu diğerlerinden farklı ise artık matris belirtmez. Java'da çok
	bıoyutlu dizi (multi dimensional array) yoktur. Bu sebeple "iki boyutlu bir dizi matris belirtir" cümleri Java için
	yanlış bir cümledir. Aslında matrtis'ler de bir dizi dizisidir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte m * n'lik bir matris (şüphesiz mantıksal olarak) yaratılmıştır. Elemanlarına rasgele değerler
	atanmıştır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("MAtrisin satır ve sütun sayılarını giriniz : ");
		int m = kb.nextInt();
		int n = kb.nextInt();

		int [][]a = new int[m][];

		for (int i = 0; i < a.length; ++i)
			a[i] = new int[n];

		for(int i = 0; i < a.length; ++i)
			for(int j = 0; j < a[i].length; ++j)
				a[i][j] = r.nextInt(100);

		for(int i = 0; i < a.length; ++i) {
			for (int j = 0; j < a[i].length; ++j)
				System.out.printf("%02d ", a[i][j]);
			System.out.println();
		}
	}
}




/*----------------------------------------------------------------------------------------------------------------------
	Java 5 ile birlikte aşağıdaki gibi ikinci köşeli parantez içerisinde yazılan uzunluk matrisin sütun sayısı anlamına
	gelir. Yani dizi dizisinin herbir elemanının gösterdiği diziler de o uzunlukta otomatik olarak yaratılır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("MAtrisin satır ve sütun sayılarını giriniz : ");
		int m = kb.nextInt();
		int n = kb.nextInt();

		int [][]a = new int[m][n];

		for(int i = 0; i < a.length; ++i)
			for(int j = 0; j < a[i].length; ++j)
				a[i][j] = r.nextInt(100);

		for(int i = 0; i < a.length; ++i) {
			for (int j = 0; j < a[i].length; ++j)
				System.out.printf("%02d ", a[i][j]);
			System.out.println();
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişkeni bir dizi dizisi olabilir. Bir metot dizi dizisi referansına dönebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("MAtrisin satır ve sütun sayılarını giriniz : ");
		int m = kb.nextInt();
		int n = kb.nextInt();

		int [][]a;

		a = ArrayUtil.getRandomMatrix(r, m, n, 0, 99);

		ArrayUtil.print(2, a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Dizi dizilerine ilk değer verilmesi
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		int [][]a;

		a = new int[][]{{1, 2, 3}, {4, 5, 6}};

		ArrayUtil.print(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Dizi dizilerine ilk değer verilmesi
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		int [][]a = {{1, 2, 3}, {4, 5, 6}};

		ArrayUtil.print(a);
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Dizi dizilerine ilk değer verilmesi
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		int [][]a = {{1, 2, 3}, {4, 5}, {1}};

		ArrayUtil.print(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizi dizilerine ilkdeğer verilirken içteki diziler için new operatörünün kullanımı geçerli olsa da hiçbir zaman
    	kullanım zorunluluğu olmaz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		int [][]a = {new int[]{1, 2, 3}, new int[]{4, 5}, {1, 7 ,7}};

		ArrayUtil.print(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizi dizisinin bir matris olup olmadığını test eden isMatrix ve
	kare matris olup olmadığını test eden isSquareMatrix metotlarını ArrayUtil sınıfı içerisinde yazınız ve aşağıdaki
	kod ile test ediniz.
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		MatrixTest.run();
	}
}

class MatrixTest {
	public static void run()
	{
		IsMatrixTest.run();
		IsSquareMatrixTest.run();
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class IsMatrixTest {
	public static void run()
	{
		int [][] a = {{1, 2}, {3, 4, 5}, {6, 7, 8}};
		int [][] b = {{1, 2}, {3, 4}, {5, 6}};

		System.out.println(ArrayUtil.isMatrix(a) ? "Matris" : "Matris değil");
		System.out.println(ArrayUtil.isMatrix(b) ? "Matris" : "Matris değil");
	}
}

class IsSquareMatrixTest {
	public static int [][] getArray(Random r, int m, int n)
	{
		return r.nextBoolean() ? ArrayUtil.getRandomMatrix(r, m, n, 0, 99) : ArrayUtil.getRandomSquareMatrix(r, m, 0, 99);
	}

	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;) {
			System.out.print("Satır ve sütun sayılarını giriniz:");
			int m = kb.nextInt();
			int n = kb.nextInt();

			if (m <= 0)
				return;

			int [][] a = getArray(r, m, n);

			ArrayUtil.print(2, a);
			System.out.println("-----------------------------------");
			System.out.println(ArrayUtil.isSquareMatrix(a) ? "Kare matris" : "Kare matris değil");
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sayısal loto kupon üreten program
    	(Not: İleride daha iyisi yazılacaktır)
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.app.lottery.NumericLotteryApp;

class App {
	public static void main(String [] args)
	{
		NumericLotteryApp.run();
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Dizi dizilerine ilişkin karmaşık durumlar
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int [][][]a;

		a = new int[3][4][5];

		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < a[i].length; j++) {
				for (int k = 0; k < a[i][j].length; k++) {
					a[i][j][k] = i + j + k;
				}
			}
		}

	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir kare matrisin esas köşegeni (diagonal) üzerindeki sayıların
	toplamını döndüren sumDiagonal isimli metodu ArrayUtil sınıfı içerisinde yazınız ve test ediniz.
	Açıklamalar:
	 - Metot karematris kontrolü yapmayacaktır
	 - Bir kare matrisin esas köşegeni üzerindeki sayılar, örneğin:

	 1 2 3
	 4 5 6
	 7 8 9

	 matrisi için 1, 5 ve 9 sayılarıdır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		SumDiagonalTest.run();

	}
}

class SumDiagonalTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();


		for (int i = 0; i < count; ++i) {
			int [][] a = ArrayUtil.getRandomSquareMatrix(r, r.nextInt(3, 8), 0, 99);
			ArrayUtil.print(2, a);

			System.out.printf("Esas köşegen üzerindeki elemanların toplamı:%d%n", ArrayUtil.sumDiagonal(a));
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}






-----------------------------------------------------------
-----------------------------------------------------------
23.03.2023 Perşembe - 31.Ders

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir matrisin devriğini (transpose) döndüren transpose isimli metodu
	ArrayUtil sınıfı içerisinde yazınız ve test ediniz.
	Açıklamalar
	- Metot matris olup olmama kontrolü yapmayacaktır
	- Matrisin devriği satırların sütun sütunların da satır olduğu matristir. Örneğin:
	1 2 3
	4 5 6

	matrisinin devriği
	1 4
	2 5
	3 6

	20:40
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		TransPoseTest.run();
	}
}

class TransPoseTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			int [][] a = ArrayUtil.getRandomMatrix(r, r.nextInt(3, 8), r.nextInt(3, 8), 0, 99);
			System.out.println("-----------------------------------------------");
			ArrayUtil.print(2, a);
			System.out.println("matrisinin devriği:");
			ArrayUtil.print(2, ArrayUtil.transpose(a));
			System.out.println("-----------------------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir okulda Matematik sınavı ortak olarak yapılıyor olsun. Kaç şube ve herbir şubede kaç öğrenci olduğu
	bilgisi klavyeden alınsın: Öğrencilerin notları rasgele belirlensin. Tüm bu işlemlerden sonra Matamatik sınavı için
	herbir şubenin ayrı ayrı not ortalamaları ile okulun not ortalamasını bulan simülasyonu yazınız.
	Açıklamalar:
		- Notlar int türü ile tutulacaktır
		- Programı mümkün olduğunca nesne yönelimli ve genel düşünerek yazınız
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.simulation.exam.ExamSimulationApp;

class App {
	public static void main(String [] args)
	{
		ExamSimulationApp.run();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminin genel biçimi:
	for (<tür> <değişken> : <dolaşılabilir türe ilişkin referans>)
		<deyim>
	Dolaşılabilir (iterable) tür kavramının detayları "Java ile Uygulama Geliştirme 1" kursunda ele alınacaktır. Diziler
	de dolaşılabilir türler olduğundan for-each döngü deyimi ile kullanılabilirler.

	for-each deyimi ile kod daha yalın hale gelir. Bu durumda for-each döngü deyimi yalınlığı ve okunabirliliği bozmadıktan
	sonra kesinlikle kullanılmalıdır.

	for-each döngü deyimi okunabililiği/algılanabililiği artırır. Kodu okuyan kişi klasik for döngüsü görürse
	"for-each ile yazmamasının bir gereksi vardır. Aksi durumda for-each döngüsü ile yazardı" biçiminde anlar. Yani
	programcının for-each döngü deyimini kullanmamasının bir gerekçesi olmalıdır
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
		for-each döngü deyiminin dizi ile kullanımında döngü değişkenine her adımda o anki elemanın değeri atanır. Bu atama
		dizinin başından sonuna kadar yinelenir. Aşağıda for-each döngü deyiminin yaklaşık karşılığı şu şekildedir:

		{
			int val;

			for (int i = 0; i < a.length; ++i) {
				val = a[i];
				System.out.printf("%d ", val);
			}
		}
		----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int a[] = {1, 2, 3, 4, 5, 6, 7, 8};

		for ( int val: a) {
			System.out.printf("%d ", val);
		}
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenine atama doğrudan (implicit) yapılır. Aşağıdaki for-each döngü deyimi
	geçerlidir
----------------------------------------------------------------------------------------------------------------------*/



package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int a[] = {1, 2, 3, 4, 5, 6, 7, 8};

		for (long val: a) {
			System.out.printf("%d ", val);
		}
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenine atama doğrudan (implicit) yapılır. Aşağıdaki for-each döngü deyimi
	geçersizdir
----------------------------------------------------------------------------------------------------------------------*/



package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int a[] = {1, 2, 3, 4, 5, 6, 7, 8};

		for (short val: a) {
			System.out.printf("%d ", val);
		}
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenininin faaliyet alanı (scope) döngü deyimi boyuncadır
----------------------------------------------------------------------------------------------------------------------*/



package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int a[] = {1, 2, 3, 4, 5, 6, 7, 8};

		for (int val: a)
			System.out.printf("%d ", val);

		System.out.printf("val = %d%n", val); //error
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde :'den sonraki ifade bir kez yapılır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		for (int val: Sample.getArray())
			System.out.printf("%d ", val);

		System.out.println();
	}
}

class Sample {
	public static  int[] getArray()
	{
		System.out.println("getArray");
		return new int[]{1, 2, 3, 4, 5, 6, 7, 8};
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
24.03.2023 Cumar - 32.Ders

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenininin dğeri değiştirilebilir. Şüphesiz döngü değişkenini değiştirmek
	dizi elemanlarını değiştirmez. Bu durumun pratikte çok anlamı yoktur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5, 6, 7, 8};

		for ( int val: a) {
			++val;
			System.out.printf("%d ", val);
		}

		System.out.println();

		for (int val: a) {
			System.out.printf("%d ", val);
		}

		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte dizinin elemanları değiştirilirken for-each kullanılmış olsa da kod okunabilir olmaz. Bu durumda
	programcının klasik for döngü deyimini kullanması daha uygundur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5, 6, 7, 8};

		int idx = 0;

		for ( int val: a)
			++a[idx++];

		for (int val: a) {
			System.out.printf("%d ", val);
		}

		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte dizinin yarısına kadar dolaşılması for-each döngü deyimiyle yapılmış olsa da kod okunabilir olmaz.
	Bu durumda programcının klasik for döngü deyimini kullanması daha uygundur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5, 6, 7, 8};

		int count = 0;

		for (int val: a) {
			System.out.printf("%d ", val);
			if(++count == a.length / 2)
				break;
		}

		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Genel olarak, dizi dolaşılırken indeks numarasının gerektiği durumlarda ve dizinin baştan sona dolaşılmadığı
	durumlarda klasik for döngüsü seçilmesi daha uygundur. Diğer durumlar için for-each döngü deyimi seçilmelidir.
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfı for-each döngü deyimi ile kullanılamaz. Teknik olarak söylersek: String sınıfı "iterable" yazılmamıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String s = "ankara";

		for (char c : s) { //error
			System.out.println(c);
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İstenirse toCharArray metodu ile tüm karakterler yine for-each döngü deyimi ile dolaşılabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String s = "ankara";

		for (char c : s.toCharArray()) {
			System.out.println(c);
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyimi ile dizi dizilerinin dolaşılması
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int [][]a = {{1,2,3}, {3, 4, 5}, {6, 7, 8}, {9, 10, 11}};

		for (int []array : a) {
			for (int val: array) {
				System.out.printf("%02d ", val);
			}
			System.out.println();
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte her bir adımda String dizisinin elemanı olan String referansları elde edilmiştir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String []cities = {"ankara", "edirne", "istanbul", "kastamonu"};

		for (String city: cities) {
			System.out.println(city);
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Elemanlarının Temel Erişim Belirleyicileri:
	Sınıf elemanlarının (metotlar, veri elemanları, ctor'lar vs.) erişim belirleyicileri 4 tanedir ve bir eleman bunlardan
	yalnızca biri ile bildirilebilir: public, protected, no-modifier, private

	Erişim belirleyici anlamında sınıf 4 bölüme ayrılmıştır. Yani örneğin sınıfın public bir elemanı sınıfın public
	bölümüne ait olur. Erişim belirleyiciler sınıf dışından erişimde enlamlıdır. Sınıfın dışı başka bir sınıfın içi
	demektir. Sınıfın içinde erişim belirleyici anlamında bir kısıt yoktur. Yani sınıf içerisinde her bölüme erişilebilir.

	Anahtar Notlar: Sınıfın no-modifier nölümü (hiçibir erişim belirleyici yazılmamış elemanı) Java'da erişim belirleyici
	anlamında public, protected ve private bölümlerden farklıdır. Bazı dillerde olduğu gibi no-modifier bölüm diğerlerinden
	biri anlamına GELMEZ. Bu durumun bir tek "enum class"'larda istisnası vardır. İleride ele alınacaktır

	Sınıfın protected ve no-modifier bölümlerinin anlamları erişen sınıfların aynı pakette veya farklı pakette olmasına göre
	değişmektedir. private ve public bölümlerin anlamları erişen sınıfların aynı pakette veya farklı pakette olmasına
	göre değişmemektedir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
		Sınıfın public bölümüne sınıf dışından erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class B {
	public void bar()
	{
		A a = new A();
		a.foo();
		a.x = 10;
	}
}

class A {
	public  int x;
	public A()
	{
		//
	}
	public void foo()
	{

	}
}


*----------------------------------------------------------------------------------------------------------------------
	Sınıfın public bölümüne sınıf dışından erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class A {
    public  int x;
    public A()
    {
        //
    }
    public void foo()
    {

    }
}

package ozturk;

import orhn.A;

public class B {
    public void bar()
    {
        A a = new A();
        a.foo();
        a.x = 10;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
		Sınıfın private bölümüne sınıf dışından erişilemez
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}
class B{
	public void bar()
	{
		A a =  new A(); //error
		a.x = 11; //error
		a.foo(); //error
	}
}

class A{
	private int x;
	private A()
	{

	}

	private void foo()
	{

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın private bölümüne sınıf dışından erişilemez
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

public class A {
    private   int x;
    private A()
    {
        //
    }
    private void foo()
    {

    }
}

package ozturk;

import orhn.A;

public class B {
    public void bar()
    {
        A a = new A();
        a.foo();
        a.x = 10;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Görüldüğü gibi sınıfın public ve private bölümlerinin anlamları aynı pakette olan (friendly) sınıflar ve farklı
    pakette olan sınıflar açısından değişiklik göstermemektedir
---------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
		Sınıfın no-modifier bölümü aynı paketteki diğer sınıflar için public anlamındadır (friendly)
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}
class B{
	public void bar()
	{
		A a =  new A();
		a.x = 11;
		a.foo();
	}
}

class A{
	int x;
	A()
	{

	}

	void foo()
	{

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın no-modifier bölümü farklı paketteki diğer sınıflar için private anlamındadır
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

public class A {
    int x;
    A()
    {
        //
    }
    void foo()
    {

    }
}

package ozturk;

import orhn.A;

public class B {
    public void bar()
    {
        A a = new A(); //error
        a.foo(); //error
        a.x = 10; //error
    }
}


/*----------------------------------------------------------------------------------------------------------------------
		Sınıfın protected bölümü aynı paketteki diğer sınıflar için public anlamındadır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}
class B{
	public void bar()
	{
		A a =  new A();
		a.x = 11;
		a.foo();
	}
}

class A{
	protected int x;
	protected A()
	{

	}

	protected void foo()
	{

	}
}




/*----------------------------------------------------------------------------------------------------------------------
    Sınıfın protected bölümü farklı paketteki diğer sınıflar içim "türetme/kalıtım (inheritance)" söz konusu değilse
    private anlamındadır. Farklı pakette ancak "türemiş sınıf (derived/sub class)" kendisine ait protected bölüme
    erişebilir. Türetme ve protected bölümün anlamı detaylı olarak ileride ele alınacaktır
---------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class A {
    protected int x;
    protected A()
    {
        //
    }
    protected void foo()
    {

    }
}
package ozturk;

import orhn.A;

public class B {
    public void bar()
    {
        A a = new A(); //error
        a.foo(); //error
        a.x = 10; //error
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın bölümlerine erişim tablosu

	Erişim Belirleyici		Kendisi			Friendly sınıflar		Farklı paketteki sınıflar			Türemiş sınıflar
	public					   T 					T 						  T 								T
	protected				   T 					T 						  F 								T
	no-modifier				   T 					T 						  F 								F
	private					   T 					F 						  F 								F
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfların özellikle veri elemanlarının gizlenmesine (yani diğer sınıflardan erişilebilmesinin engellenmesine)
	nesne yönelimli programlama tekniğinde "kapsülleme/sınıfsal temsil (encapsulation)" denir. Bu kavramın geneline
	"veri/bilgi gizleme (data/information hiding)" denir. Burada temel amaç dışarıyı sınıf dışını ilgilendirmeyecek
	verilerin/bilgilerin dışarıya verilmemesidir. Bu kavram gerçek hayattan programlamaya aktarılmıştır. Örneğin araba
	kullanırken arabanın vites değişimlerinin içsel olarak nasıl yapıldığının bilinmesi gerekmez.

	Bu anlamda sınıf yazan (server) ve sınıfı kullanan (client) bakış açısı farklıdır. Şüphesiz sınıfı yazan için iki
	bakış açısı da düşünülmelidir. Sınıfı  kullanan bakış açısı için (müşteri kodlar) içsel detayların önemi yoktur

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlamada isimlendirmede bazı teknikler kullanılabilmektedir. Bu teknikler dışında da isimlendirme
	yapılabilir. Bunlar çok kullanılan ve bilinen tekniklerdir:

	1. Unix stili (snake case): Bu isimlendirmede karakterlerin tamamı küçük harfle yazılır ve birden fazla kelime için
	aralarına alttire karakteri konur. Örneğin:
		number_of_students, serial_port
	Bu isimlendirme Java'da doğrudan tercih edilmez.

	2. Camel case (lower camel case): Bu isimlendirmede kelimeler bitişik yazılır. İlk kelimenin baş harfi küçük diğer
	kelimelerin baş harflari büyük olarak yazılır. Geri kalan karakterler küçük harfle yazılır. Bu isimlendirme Java'da
	genel olarak yerel değişken isimleri, metot isimleri ve parametre değişken isimlerinde tercih edilir. Örneğin:
		parseInt, nextLine, nextBoolean, isArmstrong

	3. Pascal case (upper camel case): Bu isimlendirmede kelimeler bitişik yazılır. Tüm kelimelerin baş hafleri büyük,
	geri kalan karakterler küçük harf olarak yazılır. Bu isimlendirme Java'da genel olarak sınıf ve benzeri tür isimlerinde
	(user defined type) tercih edilir. Örneğin:
		Random, String, FileOutputStream, NumberUtil, TimeUnit

	İsimlendirmede bunlardan biri ya da birden fazlası kullanılabilir. Kullanılmak zorunda da değildir. Örneğin Java'da
	paket isimlerinin tamamı küçük harf olacak şekilde ve birden fazla kelimeden oluşanlar da bitişik olarak yazılır.
	Örneğin:
		java.util, org.csystem.app, com.springframework
	Yukarıda anlatılan teknikler tamamen geneldir. Hatta bazen bir ya da birden fazla teknik biraz değiştirilerek de
	kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Nesne yönelimli programlamada sınıfın özellikle private bölümündeki veri elemanlarının isimlerilmesine yönelik
	bazı teknilkler kullanılabilmektedir. Örneğin baz programcılar private veri elemanları için "m_", "d_", "_", "m"
	gibi önekler kullanabilir. Biz sınıfın private ve non-static veri elemanları için "m_" önekini kullanacağız. Veri
	elemanı private ve static ise genel olarak "ms_" önekinin kullanacağız. Bazı programcılar sınıfın private bölümündeki
	veri elemanları için hiçbir önek (ya da sonek) kullanmazlar. Bu da bir tekniktir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir veri elemanı gizlendiğinde sınıfın müşteri kodlarının bu elemanın değerini değiştirmesi veya bu elemanın değerini
	elde etmesi gerekebilir. Bu durumda sınıfın bu veri elemanlarına erişen public metotlar yazılır. Veri elemanlarına
	erişip değerini elde etmek için yazılan metotlara "get metotları (getters)" denir. Veri elemanlarına erişip değerini
	değiştirmeye yarayan metotlara "set metotları (setters)" denir. Sınıfın bu şekildeki metotlarına "accessors" denir.
	Tersine get veya set metotlarının bir veri elemanına karşılık gelmesi gerekmez. Her ne şekilde olursa olsun bu metotlar
	müşteri kodlar için "accessor" metotlardır. Bu durum ileride ele alınacaktır

	Sınıfın set metotlarının isimleri genel olarak "set" ile başlatılır. get metotları ise "get" ile başlatılır. Eğer
	bir get metodu boolean bir değere geri dönecekse ismi genel olarak "is" ile başlatılır. Sınıfı yazan programcı
	özel durumlar dışında bu isimlendirmeye dikkat etmelidir. Uygulamada kullanılan bazı ortamlar (framework) ve
	kütüphaneler (libraries) programcı tarafından yazılmış sınıflar için bu metotları bu isimlendirme ile beklerler
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Date birthDate = new Date(11, 7, 1985);
		System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());

		birthDate.setDay(24);
		birthDate.setMonth(10);
		birthDate.setYear(1997);
		System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());

	}
}

class Date{
	private int m_day, m_month, m_year;

	public Date(int day, int month, int year)
	{
		m_day = day;
		m_month = month;
		m_year = year;
	}

	public int getDay()
	{
		return m_day;
	}

	public  void setDay(int day)
	{
		m_day = day;
	}

	public int getMonth()
	{
		return m_month;
	}

	public void setMonth(int month)
	{
		m_month = month;
	}

	public int getYear()
	{
		return m_year;
	}

	public void setYear(int year)
	{
		m_year = year;
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Device sınıfının m_open veri elemanı için get metodu "is" ile başlatılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class Device{
	private String m_name;
	private String m_host;
	private boolean m_open;

	public String getName()
	{
		return m_name;
	}

	public  void setName(String name)
	{
		m_name = name;
	}

	public  String getHost()
	{
		return m_host;
	}

	public void setHost(String host)
	{
		m_host = host;
	}

	public boolean isOpen()
	{
		return  m_open;
	}

	public void  setOpen(boolean open)
	{
		m_open = open;
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Date sınıfının içsel tasarımı ve algoritması değişmesine rağmen daha önce yazılmış müşteri kodlar
	bundan etkilenmemiştir. Datayları gözardı ederek sadece değiştikten sonra müşteri kodların etkilenmemesine odaklanınız
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Date birthDate = new Date(11, 7, 1985);
		System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());

		birthDate.setDay(24);
		birthDate.setMonth(10);
		birthDate.setYear(1997);
		System.out.printf("%02d/%02d/%04d%n", birthDate.getDay(), birthDate.getMonth(), birthDate.getYear());
	}
}

class Date{
	private  String m_dateStr;
	private  int m_dayOfWeek;

	public Date(int day, int month, int  year)
	{
		m_dateStr = String.format("%02d/%02d/%04d", day, month, year);
	}

	public int getDay()
	{
		return Integer.parseInt(m_dateStr.substring(0, 2));
	}

	public void setDay(int day)
	{
		m_dateStr = String.format("%02d/%02d/%04d", day, getMonth(), getYear());
	}

	public int getMonth()
	{
		return Integer.parseInt(m_dateStr.substring(3,5));
	}

	public void setMonth(int month)
	{
		m_dateStr = String.format("%02d/%02d/%04d", getDay(), month, getYear());
	}

	public int getYear()
	{
		return Integer.parseInt(m_dateStr.substring(6));
	}

	public void setYear(int year)
	{
		m_dateStr = String.format("%02d/%02d/%04d", getDay(), getMonth(), year);
	}

	public int getDayOfWeek()
	{
		return m_dayOfWeek;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Circle sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.math.geometry.Circle;

class App {
	public static void main(String [] args)
	{
		Circle c = new Circle(-3.2);

		System.out.printf("Radius : %f%n", c.getRadius());
		System.out.printf("Area : %f%n", c.getArea());
		System.out.printf("Circumference : %f%n", c.getCircumference());

		c.setRadius(6.7);
		System.out.printf("Radius : %f%n", c.getRadius());
		System.out.printf("Area : %f%n", c.getArea());
		System.out.printf("Circumference : %f%n", c.getCircumference());
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
28.03.2023 Salı - 33.Ders


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Line sınıfının noktalarının değişimi engellenmemiştir. Çünkü sınıf içerisinde tutulan Point
    	nesnelerinin referansları getPoint1 ve getPoint2 metotları dışarıya verilmiştir. Bu durumda gizlenen m_p1 ve m_p2
    	referanslarıdır. Bu referansların gösterdiği nesnelerin içeriği client kodlar tarafından dolaylı da olsa değiştirilebilir.
    	Bu durumda Line sınıfı noktaları değiştirilemeyecek şekilde yani immutable olarak yazılmamıştır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.math.geometry.Point;

class App {
	public static void main(String [] args)
	{
		Line line = new Line(10, 45, 100, 75);

		System.out.println(line.toString());

		Point p1 = line.getPoint1();

		p1.setX(222);
		p1.setY(555);

		//line.getPoint1().setX(553);
		//line.getPoint1().setY(1233);

		System.out.println(line.toString());
	}
}

class Line{

	private  Point m_p1;
	private  Point m_p2;


	public Line(int x1, int y1, int x2, int y2)
	{
		m_p1 = new Point(x1, y1);
		m_p2 = new Point(x2, y2);
	}

	public Point getPoint1()
	{
		return m_p1;
	}

	public Point getPoint2()
	{
		return m_p2;
	}

	public int getX1()
	{
		return m_p1.getX();
	}

	public int getY1()
	{
		return m_p1.getY();
	}

	public int getX2()
	{
		return m_p2.getX();
	}

	public int getY2()
	{
		return m_p2.getY();
	}

	public  String toString()
	{
		return String.format("%s, %s", m_p1.toString(), m_p2.toString());
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	 Yukarıdaki örnekte noktaların değişimini engellemek için ya referanslar dışarıya verilmemelidir. Ya da verilecekse bile
    Point nesnelerinin kopyaları yani yeni Point nesnelerinin referansları verilmelidir. Şüphesiz bu sınıfın dökumantasyonunda
    belirtilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.math.geometry.Point;

class App {
	public static void main(String [] args)
	{
		Line line = new Line(10, 45, 100, 75);

		System.out.println(line.toString());

		Point p1 = line.getPoint1();

		p1.setX(222);
		p1.setY(555);

		System.out.println(line.toString());

		System.out.println(p1.getX());
		System.out.println(p1.getY());
	}
}

class Line{

	private  Point m_p1;
	private  Point m_p2;


	public Line(int x1, int y1, int x2, int y2)
	{
		m_p1 = new Point(x1, y1);
		m_p2 = new Point(x2, y2);
	}

	public Point getPoint1()
	{
		return new Point(m_p1.getX(), m_p1.getY());
	}

	public Point getPoint2()
	{
		return new Point(m_p2.getX(), m_p2.getY());
	}

	public int getX1()
	{
		return m_p1.getX();
	}

	public int getY1()
	{
		return m_p1.getY();
	}

	public int getX2()
	{
		return m_p2.getX();
	}

	public int getY2()
	{
		return m_p2.getY();
	}

	public  String toString()
	{
		return String.format("%s, %s", m_p1.toString(), m_p2.toString());
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte getNumbers metodu içsel olarak tutulan dizinin elemanlarından oluşan yeni bir dizi döndürmektedir.
    Bu durumda içsel olarak dizinin elemanları dışarıdan değpiştirilemez.

    Anahtar Notlar: java.util.Arrays sınıfının copyOf metotları birinci parametresi ile aldığı dizinin, ikinci parametresi
    ile aldığı uzunluk kadar elemanlarından oluşan yeni bir dizinin referansına geri döner. Bu durumda ikinci parametre
    için dizinin uzunluğu argüman olarak geçilirse, dizinin tamamının kopyası çıkartılmış olur
 ----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
		RandomIntArrayGenerator randomIntArrayGenerator = new RandomIntArrayGenerator(new Random(), 10, 0, 101);
		int [] a = randomIntArrayGenerator.getNumbers();

		ArrayUtil.print(a);
		ArrayUtil.print(2,a);


		ArrayUtil.addBy(a, 5);

		ArrayUtil.print(randomIntArrayGenerator.getNumbers());
	}
}

class RandomIntArrayGenerator{
	private int[] m_numbers;

	public RandomIntArrayGenerator(Random random, int count, int min, int max)
	{
		m_numbers = ArrayUtil.getRandomArray(random, count, min, max);
	}

	public int[] getNumbers()
	{
		return m_numbers;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tüm elemanları static olarak bildirilmiş sınıflar türünden nesnelerin anlamı yoktur. Bu tarz sınıflara genel olarak
	"utility class" denir. Utility class'ların ctor'ları okunabilirlik açısından private yapılır. Bu şekildeki sınıflar
	için bu tasarıma kesinlikle uyulmalıdır
 ----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.array.ArrayUtil;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
		Math n = new Math(); //error
		ArrayUtil aUtil = new ArrayUtil(); //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	BallFall Sınıfı
 ----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.app.game.ballfall.BallFallGameApp;
import com.orhn.util.ArrayUtil;

class App {
	public static void main(String [] args)
	{
		BallFallGameApp.run();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	CrapsSimulation Sınıfı
 ----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.app.simulation.craps.CrapsSimulationApp;

class App {
	public static void main(String [] args)
	{
		CrapsSimulationApp.run();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Özellikle Nesne yönelimli programlama tekniğine ilişkin bazı ilkeler söz konusudur. Bu ilkelere
	bir programcı özel bir durum yoksa mutlaka uyar. Bu ilkelere genel olarak "Object Oriented Design Principles" denir.
	Bu ilkeler kısaca "SOLID" olarak bilinir:
	Single Responsibility Principle (SRP)
	Open Closed Principle (OCP)
	Liskov Substitution Principle (LSP)
	Interface Segregation Principle (ISP)
	Dependency Inversion Principle (DIP)

	Bu ilkeler bu kurs ve uygulama kurslarında zaman içerisinde anlaşılacaktır.
	Bu ilkeler birbirlerinden ayrı düşünülmemelidir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Nesne yönelimli programlama tekniği ilerledikçe bir takım genel problemlere yine bir takım genel
	çözümleri öneren ve 4 kişi tarafından hazırlanan kalıplar vardır. Bu problemlere ve çözümlerine  "design patterns"
	denir. Bu anlamnda bu 4 kişiyi temsil etmek amacıyla bu kalıplara "Gof (Gang of Four) patterns" de denir. Gof kalıplarından
	önce ve sonra da bir çok kalıp önerilmiştir. Ancak Gof kalıpları bu anlamda en çok kullanları biçiminde düşünülebilir.

	Anahtar Notlar: Tasarım kalıplarının hepsi heme öğrenilmeli midir? Bu anlamda tasarım kalıplarını çalışmak belli
	bir uygulama geliştirme becerisine sahip olduktan sonra daha verimli olur. Biz bu kursta ve uygulama kurslarında
	bu kalıpların bir çoğunu öğreneceğiz.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlamada çalışma zamanında herhangi bir nesne ya da değişken için ayrılmayan genel olarak 1 byte'lık
	bölgenin adresine "null address" denir. Java'da bu adres "null" sabiti ile temsil edilir. Bir referansa null atanabilir.
	Bu durumda referansın içerisinde bir adres vardır ancak bu adreste bir nesne yoktur. Ya da daha genel anlatımla null
	adres çalışma zamnında yer ayırma anlamında kullanılmayan bir adrestir. Modern sistemlerde heme hepsinde "null adress"
	sıfır numaralı gözeneğin adresidir. Ancak böyle olmak zorunda değildir. Java programcısı açısından bu adresin sayısal
	değerinin ne olduğunun bir önemi yoktur. Zaten "null" sabiti bu adresi temsil eder. Bir refansın default değeri null'dır.
	null adres (referans) kavramı daha detaylı olarak ileride ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Singleton: Öyle bir sınıf olsun ki bu sınıf türünden program boyunca yalnızca bir tane nesne yaratılabilsin ve
	bu nesnenin referansı elde edilebilsin

	Anahtar Notlar: Singleton sınıfı'ın bir çok "gerçekleştirimi (implementation)" yapılabilir.

	Anahtar Notlar: Bu kursta Singleton kalıbının hangi durumlarda kullanılacağı ele alınmayacaktır. Yalnızca çeşitli
	implementasyonları yapılacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Singleton kalıbının "lazy" implementasyonu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();

		System.out.println(s1 == s2 ? "Aynı nesne " : "Farklı nesneler");
	}
}

class Singleton{
	private static Singleton ms_instance;

	private int m_valeu;

	private Singleton()
	{}

	public static Singleton getInstance()
	{
		if(ms_instance == null)
			ms_instance = new Singleton();

		return ms_instance;
	}

	public int getValue()
	{
		return m_valeu;
	}

	public void setValue(int value)
	{
		m_valeu = value;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
30.03.2023 Perşem - 34.Ders

/*----------------------------------------------------------------------------------------------------------------------
	final değişkenler:
	Bir değişkenin final olarak bildirilmesi durumunda o değişken bir kez değer alır ve bir daha değeri değiştirilemez.
	Değiştirilmeye çalışılması error oluşturur. Java 8'den itibaren yerel değişkenlerin ve parametre değişkenlerinin final
	olması durumununb artık bir anlamı kalmamıştır. Java 8 öncesinde yerel değişkenlerin ve parametre değişkenlerinin
	final olarak bildirilmesinin zorunlu olduğu durumlar vardı. Fakat veri elemanları için bu durum söz konusu değildir.
	Yani veri elemanları final yapılabiliyor ise yapılması iyi bir tekniktir.

	final veri elemanları için genel olarak şu kural iyi bir programlama açısından benimsenmelidir:
	"Veri elemanın final yapılması algoritmik olarak geçerliyse kesinlikle final yapılmalıdır"
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	final bir yerel değişkene faaliyet alanı (scope) boyunca bir kez değer verilebilir. Genel olarak ilkdeğer verilse de (initialization)
	faaliyet alanı boyunca bir kez olması koşunuyla istenildiği yerde atama yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		final double pi = 3.14;
		final double e;

		//pi = 3.15; //error
		e = 2.71; //gecerli
		++e; //error artık

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişkenleri olabilir. Bu durumda metodun final olan parametre değişkenlerinin değerleri
	metot içerisinde değiştirilemez
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{


	}
}

class Sample{
	public  static void foo(final int x, int y)
	{
		++y;
		--x; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static ve final olarak bildirilmiş veri elemanlarına default değerler atanmaz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{


	}
}

class Sample{
	public final int x; //error
	//public final int x = 34;
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static ve final bir veri elemanına üç yerden birinde değer verilebilir:
	1. Bildirim noktasında (initialization)
	2. Sınıfın tüm ctor'ları içerisinde
	3. Sınıfın "non-static bloğu (non-static initializer)" içerisinde: Bu konu ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{


	}
}

class Sample{
	public final int x;

	public Sample()
	{
		x = 0;
	}

	public Sample(int a)
	{
		x = a;
	}
}

class Mample{
	public final int x = 10;
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static ve final veri elemanınının sabit ifadesi ile ilkdeğerlenmesi gerekmez
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
			Sample s = new Sample();
			Sample k = new Sample();

		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
	}
}

class Sample{
	private int randValue()
	{
		return new Random().nextInt();
	}

	public final int x = randValue();
}
/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static ve final veri elemanlarına default değer atanmaz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;

class App {
	public static void main(String [] args)
	{

	}
}

class Sample{
	public static final int DEFAULT_VALUE; //error
}


/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Sınıcın static ve final ve özellikle public veri elemanlarının isimlendirilmesinde tamamen büyük
    harfler ve birden fazla kelimeden oluşuyorsa kelimeleri alttire karakteri ile ayırma biçimi kullanılır. Bu durum
    private veri elemanları esnek olarak düşünülebilir. Ancak özellikle public veri elemanları için bu "convention"'a
    uyulmalıdır
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
		Sınıfın static ve final veri elemanlarına iki yerden birinde değer atanabilir:
	1. Bildirim noktasında (initialization)
	2. Sınıfın "static bloğu (static initializer)" içerisinde: Bu konu ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;

class App {
	public static void main(String [] args)
	{

	}
}

class Sample{
	public static final int DEFAULT_VALUE = 20;
}

/*----------------------------------------------------------------------------------------------------------------------
	Singleton kalıbının "eager" implementasyonu
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
		Singleton s1 = Singleton.INSTANCE;
		Singleton s2 = Singleton.INSTANCE;

		System.out.println(s1 == s2 ? "Aynı nesne" : "Farklı nesneler");
	}
}

class Singleton{
	public static final Singleton INSTANCE = new Singleton();

	private int m_value;
	private Singleton()
	{}

	public int getValue()
	{
		return m_value;
	}

	public void setValue(int value)
	{
		m_value = value;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	final ve static veri elemanlarının bir kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
		System.out.println(Sample.AVOGADRO_NUMBER);
	}
}

class Sample{
	public static final double AVOGADRO_NUMBER = 6.02E23;
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte DEBUG veri elemanı final yapılırsa derleyici false olduğundan ** ile belirtilen if deyimini
	arakoda eklemez. Eğer final yapılmazsa ekler, dolayısıyla gereksiz bir kod eklenmiş olur. Yani derleyici optimizasyon
	yapma imkanına sahip olur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();

		s.bar(-10);
	}
}
class Sample{
	public static final boolean DEBUG = false;

	private void foo(int a)
	{
		if(DEBUG){ //**
			if(a < 0)
				System.out.printf("%d can not be negative!...%n", a);

			System.out.println("girdi");
		}

		System.out.println("foo");
	}

	public void bar(int a)
	{
		System.out.println("bar");
		a = Math.abs(a);
		foo(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte y veri elemanı x veri elemanından önce yaratılacağından error oluşur. Bu veri elemanları final
	olmasa durum aynıdır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
	}
}
class Sample{
	public static final int y = x + 1; //error
	public static final int x = 10;
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
	}
}
class Sample{
	public static final int x = 10;
	public static final int y = x + 1; //error

}

-----------------------------------------------------------
-----------------------------------------------------------

18.05.2023 Perşembe - 35.Ders

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir okulda Matematik sınavı ortak olarak yapılıyor olsun. Kaç şube ve herbir şubede kaç öğrenci olduğu
	bilgisi klavyeden alınsın: Öğrencilerin notları rasgele belirlensin. Tüm bu işlemlerden sonra Matamatik sınavı için
	herbir şubenin ayrı ayrı not ortalamaları ile okulun not ortalamasını bulan simülasyonu yazınız.
	Açıklamalar:
		- Notlar int türü ile tutulacaktır
		- Programı mümkün olduğunca nesne yönelimli ve genel düşünerek yazınız
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.school.LectureInfoParserTest;
import com.orhn.app.simulation.lotto.LottoProbabilitySimulationApp;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
		LectureInfoParserTest.run();
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Bir referansın final olması o referansa bir daha değer atanamayacağını belirtir. Referansın gösterdiği nesnenin
	içeriğinin değiştirilip değiştirilemeyeceği o nesneye ilişkin sınıfın immutable olup olmamsı ile ilgilidir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.school.LectureInfoParserTest;
class App {
	public static void main(String [] args)
	{
		final Sample s = new Sample();

		s.x  = 10;

		s = new Sample(); //error
	}
}

class Sample{
	public int x;
}

/*----------------------------------------------------------------------------------------------------------------------
	Soru: Aşağıda açıklanan sınıfı yazınız
	Açıklamalar:
		- Sınıfın ismi IntValue olacaktır
		- Sınıfı immutable olarak yazılacaktır.
		- Sınıf int türden bir değeri sarmalayacaktır (wrapper). Yani int türden bir değeri tutacaktır.
		- Sınıf [-128, 127] aralığındaki değerlere ilişkin sarmalanan nesneleri ilk kez istendiğinde yaratacak sonraki
		isteklerde aynı nesnenin referansını verecektir. Bu kavrama önbellek (cache) denir
	Not: Java'da böyle bir sınıf vardır ve çok sık kuıllanılır. Burada böyle bir sınıfın nasıl yazılması gerektiğine
	odaklanmalısınız

----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.wrapper.IntValue;
class App {
	public static void main(String [] args)
	{
		IntValue iVal1 = IntValue.of(100);
		IntValue iVal2 = IntValue.of(100);
		IntValue iVal3 = IntValue.of(145);
		IntValue iVal4 = IntValue.of(145);

		System.out.println(iVal1 == iVal2 ? "Aynı nesne" : "Farklı Nesne");
		System.out.println(iVal3 == iVal4 ? "Aynı nesne" : "Farklı Nesne");

		System.out.println(iVal1.getValue());
		System.out.println(iVal2.getValue());
		System.out.println(iVal3.getValue());
		System.out.println(iVal4.getValue());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	IntValue

----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.wrapper.IntValue;
class App {
	public static void main(String [] args)
	{
		IntValue hundred = IntValue.of(100);

		for (IntValue i = IntValue.ZERO; i.compareTo(hundred) < 0; i = i.add(2))
			System.out.printf("%s ", i.toString());

		System.out.println();
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	IntValue

----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.wrapper.IntValue;
class App {
	public static void main(String [] args)
	{
		IntValue hundred = IntValue.of(100);

		for (IntValue i = IntValue.ZERO; i.compareTo(hundred) < 0; i = i.inc())
			System.out.printf("%s ", i.toString());

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	IntValue

----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.wrapper.IntValue;
class App {
	public static void main(String [] args)
	{
		IntValue hundred = IntValue.of(100);

		for (IntValue i = IntValue.TEN; i.compareTo(IntValue.ZERO) >= 0; i = i.dec())
			System.out.printf("%s ", i.toString());

		System.out.println();
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	IntValue

----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.wrapper.IntValue;
class App {
	public static void main(String [] args)
	{
		IntValue ten = IntValue.TEN;
		IntValue result;

		result = ten.divide(IntValue.of(3));

		System.out.println(result.toString());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	IntValue

----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;
import com.orhn.util.wrapper.IntValue;
class App {
	public static void main(String [] args)
	{
		IntValue ten = IntValue.TEN;
		IntValue [] result;

		result = ten.divideAndRemainder(3);

		System.out.printf("Result:%d%n", result[0].getValue());
		System.out.printf("Remainder:%d%n", result[1].getValue());
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
19.05.2023 - 36.Ders

/*----------------------------------------------------------------------------------------------------------------------
	Date sınıfı

----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;


import com.orhn.util.datetime.Date;

class App {
	public static void main(String [] args)
	{
		Date d = new Date(18, 5, 2023);
		System.out.println(d.toLongDateStringEN());
		System.out.println(d.toLongDateStringTR());

		d.setDay(19);
		System.out.println(d.toLongDateStringEN());
		System.out.println(d.toLongDateStringTR());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Date sınıfı

----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;


import com.orhn.util.datetime.Date;

class App {
	public static void main(String [] args)
	{
		Date d = new Date(18, 5, 2023);
		System.out.println(d.toString());
		System.out.println(d.toString('.'));

		d.setDay(19);

		System.out.println(d.toString());
		System.out.println(d.toString('.'));
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli metodu yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden
		elde edilen kalan ile belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ..., 6 ise "cumartesi"
		günlerine karşılık gelir

		- 1.1.1900 öncesindeki tarihler geçersiz sayılacaktır
		- getDayOfWeek metodu ile birlikte

		- İleride daha iyisi yazılacaktır parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin
		hafta sonu olup olmadığınıu test eden isWeekend ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız.
		Bu iki metot tarih geçerlilik kontrolü yapmayacaktır

----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;


import com.orhn.util.datetime.Date;
import com.orhn.util.datetime.DateApp;

class App {
	public static void main(String [] args)
	{
		DateApp.run();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden aşağıdaki formatta girilen bilgiyi ayrıştırarak ekrana sonuçları yazdıran programı
	yazınız:
	<ad soyad>:<ders adı>:<gg-aa-yyyy>:<gg-aa-yyyy>:<arasınav>:<final>
	Oğuz Karan:Matematik:04/04/2022:01/07/2022:78:67
	Barış Er:Radyo Haberleşmesi:03/04/2022:02/07/2022:89:100
	Ziya ÇAYLAN:PLC Programlama:10/04/2022:13/06/2022:90:98
	Emirhan Kabal:Fizik:07/03/2022:03/07/2022:85:75
	Ozan Yiğit:İstatistik:07/04/2017:19/06/2017:90:100
	Yunus Emre Uslu:Yazlım Geliştirme:28/04/2022:28/06/2022:60:70

	Açıklamalar:
		- Format geçerlilik kontrolü yapılmayacaktır
		- Formatta vize ve final notlarına göre vize * 0.4 + final * 0.6 formülü ile geçme notu hesaplanacak ve sınav
		tarihleri hangi güne geldiği de belirlenerek ekrana yazdırılacaktır
		- Ekran çıktısında "Geçti" ya da "Kaldı" bilgisi de olacaktır. Geçme notu 50 ve üstünde ise öğrenci geçmiş
		sayılacaktır.
		- Geçme notu round işlemi ile tamsayı olarak elde edilecektir
		- İleride daha iyisi yazılacaktır

		Örnek çıktı:
		-------------------------------------------
		Ad Soyad: Oğuz Karan
		Ders Adı: Matematik
		Arasınav Tarihi: 4 Nisan 2022 Pazartesi
		Final Tarihi: 1 Temmuz 2022 Cuma
		Arasınav Notu: 78
		Final Notu: 67
		Geçme Notu: 71
		Sonuç: Geçti
		-------------------------------------------
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;


import com.orhn.app.school.LectureInfoParserTest;
import com.orhn.util.datetime.Date;
import com.orhn.util.datetime.DateApp;

class App {
	public static void main(String [] args)
	{
		LectureInfoParserTest.run();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte move metodunun parametresi int türden olduğundan parametre değişken ismi ne olduğu hakkında bilgi
	verse de ona geçilebilecek argümanlar anlaşılamamaktadır. Ayrıca çağırma sırasında geçilen argümanlar da ne anlama
	geldikleri hakkında bilgi vermemektedir. Yani bu yaklaşım okunabilir/algılanabilir değildir. Şüphesiz metotlar
	argüman kontrolü yapacaktır. Ancak yine programcının yanlış argüman geçme olasılığı da vardır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.samples.dateapp.test.PrintRandomDateTest;

class App {
	public static void main(String [] args)
	{
		GameApp.run();
	}
}

class GameApp{
	public static void run()
	{
		GameObject go = new GameObject();

		go.move(0);//right
		go.move(1);//top
		go.move(2);//left
		go.move(3);//bottom
	}
}

class GameObject{
	public void move(int direction)
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte move metodunun parametresi yine bir fikir vermemektedir. Argümanlar açısından okunabilirlik/algılanabilirlik
	artırılmıştır. ASncak programcının çağırma sırasında argümanı yanlış olasılığı vardır. Üstelik String karşılaştırması
	göreceli olarak tamsayı karşılaştırmasına göre yavaştır. Dolayısıyla bu yaklaşım da iyi sayılmaz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.samples.dateapp.test.PrintRandomDateTest;

class App {
	public static void main(String [] args)
	{
		GameApp.run();
	}
}

class GameApp{
	public static void run()
	{
		GameObject go = new GameObject();

		go.move("right");//right
		go.move("top");//top
		go.move("left");//left
		go.move("bottom");//bottom
	}
}

class GameObject{
	public void move(String direction)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek için aşağıdaki yaklaşım programcının yanlış yazma olasılığını gidermiştir. Ancak diğer problemler
	hala devam etmektedir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.samples.dateapp.test.PrintRandomDateTest;

class App {
	public static void main(String [] args)
	{
		GameApp.run();
	}
}

class GameApp{
	public static void run()
	{
		GameObject go = new GameObject();

		go.move(GameObject.RIGHT);//right
		go.move(GameObject.TOP);//top
		go.move(GameObject.LEFT);//left
		go.move(GameObject.BOTTOM);//bottom
	}
}

class GameObject{

	public static final String RIGHT = "right";
	public static final String TOP = "top";
	public static final String LEFT = "left";
	public static final String BOTTOM = "bottom";
	public void move(String direction)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte metot çağrısında okunabilirlik/algılanabilirlik artırılmıştır ve int kullanıldığı için de görece
	yazı karşılaştırma maliyeti ortadan kaldırılmıştır. Ancak hala metodun parametresi geçilebilecek argümanlarla ilgili
	bir fikir vermemektedir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.samples.dateapp.test.PrintRandomDateTest;

class App {
	public static void main(String [] args)
	{
		GameApp.run();
	}
}

class GameApp{
	public static void run()
	{
		GameObject go = new GameObject();

		go.move(GameObject.RIGHT);//right
		go.move(GameObject.TOP);//top
		go.move(GameObject.LEFT);//left
		go.move(GameObject.BOTTOM);//bottom
	}
}

class GameObject{

	public static final int RIGHT = 0;
	public static final int TOP = 1;
	public static final int LEFT = 2;
	public static final int BOTTOM = 3;
	public void move(int direction)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıda anlatılan problemlerin hepsi aşağıdaki gibi bir yaklaşılma çözülebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.samples.dateapp.test.PrintRandomDateTest;

class App {
	public static void main(String [] args)
	{
		GameApp.run();
	}
}

class GameApp{
	public static void run()
	{
		GameObject go = new GameObject();

		go.move(Direction.RIGHT);//right
		go.move(Direction.TOP);//top
		go.move(Direction.LEFT);//left
		go.move(Direction.BOTTOM);//bottom
	}
}

class Direction{
	private Direction(){}
	public static final Direction RIGHT = new Direction();
	public static final Direction TOP = new Direction();
	public static final Direction LEFT = new Direction();
	public static final Direction BOTTOM = new Direction();
}

class GameObject{
	public void move(Direction direction)
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problemlere ilişkin sınıflar Java 5 ile eklenen ve detayları ileride açıklanacak olan "enum sınıflar (enum classes)"
	kullanılarak daha yalın hale getirilebilir. Üstelik enum class'lar yukarıdaki Direction gibi sınıflardan daha fazla
	özelliğe sahiptir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.samples.dateapp.test.PrintRandomDateTest;

class App {
	public static void main(String [] args)
	{
		GameApp.run();
	}
}

class GameApp{
	public static void run()
	{
		GameObject go = new GameObject();

		go.move(Direction.RIGHT);//right
		go.move(Direction.TOP);//top
		go.move(Direction.LEFT);//left
		go.move(Direction.BOTTOM);//bottom
	}
}

enum Direction{
	RIGHT, TOP, LEFT, BOTTOM
}

class GameObject{
	public void move(Direction direction)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	enum anahtar sözcüğü ile bir enum sınıf (enum class) bildirilebilir. enum sınıfı içerisinde ilk noktalı virgülden
	önce (noktalı virgülü zorunlu olmadıkça koymayacağız) bildirilen isimlere "enum sabitler (enum constants)" denir.
	Bu isimler public static olarak bildirilmiş o enum sınıfı türünden referanslardır. Bu referansların herbiri ilgili
	enum türünden yaratılmış olan bir nesnenin adresini tutar. enum sabitleri için public static, final ve tür bilgisi
	yazılması error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.samples.dateapp.test.PrintRandomDateTest;

class App {
	public static void main(String [] args)
	{

	}
}

enum Color{
	RED, GREEN, BLUE
}

enum MaritalStatus{
	SINGLE, MARRIED, DIVORCED
}

enum DayOfWeek{
	SUN, MON, TUE, WED, THU, FRU, SAT
}

/*----------------------------------------------------------------------------------------------------------------------
	enum sınıfının ordinal isimli non-static metodu referansa ilişkin nesnenin adresini tutan enum sabitinin ordinal
	numarasını döndürür. Ordinal numarası sabitin sıfır değerinden başlamak üzere enum bildirimindeki sıra numarasıdır.
	enum sınıfının static values() isimli metodu ile enum sabitlerine ilişkin referansları sırasyıla tutan ilgili enum
	türünden bir dizi yaratılıp referansı elde edilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		DayOfWeek dow = DayOfWeek.MON;

		System.out.println(dow.toString());
		System.out.printf("Ordinal : %d%n", dow.ordinal());

		DayOfWeek [] dayOfWeeks = DayOfWeek.values();

		int ordinal = 4;

		System.out.println(dayOfWeeks[ordinal].toString());
		System.out.println("---------------");

		for (DayOfWeek dayOfWeek: dayOfWeeks) {
			System.out.printf("%s ", dayOfWeek.toString());
		}

		System.out.println();
	}
}
enum DayOfWeek{
	SUN, MON, TUE, WED, THU, FRU, SAT
}

/*----------------------------------------------------------------------------------------------------------------------
	enum sınıfının static valueOf metodu parametresi ile aldığı yazıya ilişkin sabit ilgili enum sınıfında varsa o sabite
	ilişkin refernsa geri döner. Yoksa exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Gün bilgisini giriniz -> [SUN, MON, TUE, WED, THU, FRI, SAT]: ");
		String s = kb.nextLine().toUpperCase();

		DayOfWeek dow = DayOfWeek.valueOf(s);

		System.out.println(dow.toString());
	}
}
enum DayOfWeek{
	SUN, MON, TUE, WED, THU, FRI, SAT
}

/*----------------------------------------------------------------------------------------------------------------------
	enum sınıfı türünden nesne new opertörü ile hiçbir yerde (sınıf içinde bile) yaratılamaz. Yani bir enum türünden
	nesne sayısı program boyunca enum sabitinin sayısı kadardır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		DayOfWeek dow = new DayOfWeek(); /* error */
	}
}
enum DayOfWeek{
	SUN, MON, TUE, WED, THU, FRI, SAT
}



/*----------------------------------------------------------------------------------------------------------------------
	Bir enum sınıfına sabitler dışında metot, veri elemanı, ctor vb. eklenebilir. Bunun için son bildirilen sabitten
	sonra noktalı virgül konması gerekir. Eğer enum sınıfının hiçbir sabit elemanı yoksa bile (bu durum enum kullanmanın
	hedefine aykırıdır yani anlamsızdır) eklenecek diğer elemanlardab önce yine noktalı virgül konmalıdır. ctor ayrıca
	incelenecektir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{

	}
}

enum Sample{
	;
	private int m_a;

	public void foo()
	{
		//
	}

	static void bar()
	{
		//
	}
}

enum DayOfWeek{
	SUN, MON, TUE, WED, THU, FRI, SAT;

	private int m_a;
	public void foo()
	{
		//
	}

	static void bar()
	{
		//
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durumda içi boş parantezler geçerlidir. Hiç parantez konmaması ile aynı anlamdadır. Aslında aşapıdaki
	kullanım ya da parantezsiz kullanım, sabitlere ilişkin nesneler yaratılırken "default ctor" çağrılsın anlamındadır.
	Anımsanacağı gibi bir sınıfa hiçbir ctor yazılmamışsa, derleyici default ctor'u içi boş ve public olarak yazar.
	enum için içi boş ve erişilemez olarak yazar. Buradaki erişlemez, private anlamında değildir. Daha ötesidir. enum
	sınıfı içerisinde de ctor'lar erişilemez durumdadır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{

	}
}

enum Color{
	RED(), GREEN(), BLUE(), WHITE(), BLACK()
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir enum sınıfında ctor'lar yazılabilir. Ancak bu ctor'lar ya private ya da hiçbir erişim belirleyici olmadan
	bildirilmelidir. Aksi durumda error oluşur. Erişim belirleyici yazılmaması enum sınıfların ctor'ları için klasik
	no-modifier anlamına gelmez. Bu durum yalnızca enum sınıfının ctor'u için geçerlidir. enum sınıfının ctor'ları public
	ya da protected olarak bildirilemez. enum sınıfı türünden bir nesne sınıf içerisinde de yaratılamaz. Yani enum sınıfının
	ctor'ları özeldir. Erişim anlamında private'ın da ötesindedir. Biz bir ctor için erişim belirleyecisi yazmayacağız
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Color c = new Color(); //error
	}
}

enum Color{
	RED(), GREEN(), BLUE(), WHITE(), BLACK();
	Color()
	{
		System.out.println("I am a default ctor");
	}

	public static Color foo()
	{
		return new Color(); //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi bir sınıfın static veri elemanları sınıfın bir elemanı (member) ilk kez kullanıldığında hepsi
	birden olmak üzere yaratılır ve program sonlanana kadar yaşarlar. Aşağıdaki örnekte 5 tane "I am a default ctor"
	yazısı ekrana basılacaktır. Bu yazılar ilk foo çağrısıyla birlikte foo'nun kodlarından önce ekrana basılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Color.foo();
		System.out.println("------------------------");
		Color.foo();
	}
}

class Color{
	public static final Color RED = new Color();
	public static final Color GREEN = new Color();
	public static final Color BLUE = new Color();
	public static final Color WHITE = new Color();
	public static final Color BLACK = new Color();
	Color()
	{
		System.out.println("I am a default ctor");
	}

	public static Color foo()
	{
		return new Color(); //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örneğin enum class ile yapılışı durumunda yine aynı şekilde olacaktır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Color.foo();
		System.out.println("------------------------");
		Color.foo();
	}
}

enum Color{
	RED(), GREEN(), BLUE(), WHITE(), BLACK();
	Color()
	{
		System.out.println("I am a default ctor");
	}

	public static void foo()
	{
		System.out.println("Color foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Color enum sınıfına eklenem ctor ile her bir sabite ilişkin nesne için bilgiler iliştirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb =new Scanner(System.in);
		RandomColorFactory factory = new RandomColorFactory(new Random());

		System.out.println("Bir sayi giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; i++){
			Color color = factory.getColor();

			System.out.println("-------------------------------");
			System.out.printf("%s:{r: %d, g: %d, b: %d}%n", color.toString(), color.r, color.g, color.b);
		}
	}
}

class RandomColorFactory{
	private static final Color [] COLORS = Color.values();
	private final Random m_random;

	public RandomColorFactory(Random m_random)
	{
		this.m_random = m_random;
	}

	public Color getColor()
	{
		return COLORS[m_random.nextInt(COLORS.length)];
	}
}

enum Color{
	RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255), WHITE(255, 255, 255), BLACK(0, 0, 0);

	public final int r, g, b;
	Color(int x, int y, int z)
	{
		r = x;
		g = y;
		b = z;
	}

}




-----------------------------------------------------------
-----------------------------------------------------------
20.05.2023 Cumartesi - 37.Ders

/*----------------------------------------------------------------------------------------------------------------------
	enum class ile Singleton sınıf bildirimi. Lazy implementation gerekmedikçe ve özel bir durum yoksa Singleton
	için en iyi implementasyon enum ile yapılır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Singleton s1 = Singleton.INSTANCE;
		Singleton s2 = Singleton.INSTANCE;

		System.out.println(s1 == s2 ? "Aynı nesne" : "Farklı nesneler");
	}
}

enum Singleton{
	INSTANCE;

	private int m_value;

	private Singleton(){}

	public int getValue()
	{
		return m_value;
	}

	public void setValue(int value)
	{
		m_value = value;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	enum türlerinde eşitlik karşılaştırması yani aynı enum sabitine ilişkin referansın tutulup tutulmadığı == ve !=
    	operatörleri ile test edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb =new Scanner(System.in);
		RandomColorFactory factory = new RandomColorFactory(new Random());

		System.out.println("Bir sayi giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; i++){
			Color color1 = factory.getColor();
			Color color2 = factory.getColor();

			System.out.println("-------------------------------");
			System.out.printf("%s, %s%n", color1.toString(), color2.toString());
			System.out.println(color1 == color2 ? "Ayni nesne": "Farklı nesneler");
			System.out.println(color1 != color2 ? "Farklı nesneler": "Aynı nesneler");
		}
	}
}

class RandomColorFactory{
	private static final Color [] COLORS = Color.values();
	private final Random m_random;

	public RandomColorFactory(Random m_random)
	{
		this.m_random = m_random;
	}

	public Color getColor()
	{
		return COLORS[m_random.nextInt(COLORS.length)];
	}
}

enum Color{
	RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255), WHITE(255, 255, 255), BLACK(0, 0, 0);

	public final int r, g, b;
	Color(int x, int y, int z)
	{
		r = x;
		g = y;
		b = z;
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	enum türlerinde eşitlik karşılaştırması yani aynı enum sabitine ilişkin referansın tutulup tutulmadığı == ve !=
	operatörleri ile test edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb =new Scanner(System.in);
		RandomColorFactory factory = new RandomColorFactory(new Random());

		System.out.println("Bir sayi giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; i++){
			Color color1 = factory.getColor();
			Color color2 = factory.getColor();

			System.out.println("-------------------------------");
			System.out.printf("%s, %s%n", color1.toString(), color2.toString());
			System.out.println(color1.equals(color2) ? "Ayni nesne": "Farklı nesneler");
		}
	}
}

class RandomColorFactory{
	private static final Color [] COLORS = Color.values();
	private final Random m_random;

	public RandomColorFactory(Random m_random)
	{
		this.m_random = m_random;
	}

	public Color getColor()
	{
		return COLORS[m_random.nextInt(COLORS.length)];
	}
}

enum Color{
	RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255), WHITE(255, 255, 255), BLACK(0, 0, 0);

	public final int r, g, b;
	Color(int x, int y, int z)
	{
		r = x;
		g = y;
		b = z;
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	enum türlerinin compareTo metodu:
		a.compareTo(b);
	çağrısı için
		a.ordinal() - b.ordinal()
	sonucunu döndürür
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		RandomDayOfWeekFactory factory = new RandomDayOfWeekFactory(new Random());

		System.out.print("Kac tane uretilsin : ");
		int count = kb.nextInt();

		for (int i = 0; i < count; i++) {
			DayOfWeek dow1 = factory.getDayOfWeek();
			DayOfWeek dow2 = factory.getDayOfWeek();

			int diff = dow1.compareTo(dow2);

			System.out.println("-----------------------------");
			if(diff < 0)
				System.out.printf("%s ile %s arasında %d gün var%n", dow1.toString(), dow2.toString(), -diff);
			else if(diff > 0)
				System.out.printf("%s ile %s arasında %d gün var%n", dow2.toString(), dow1.toString(), diff);
			else
				System.out.printf("Ayni gün:%s%n", dow1.toString());
			System.out.println("-----------------------------");
		}
	}
}

class RandomDayOfWeekFactory{
	private  static final DayOfWeek [] DAY_OF_WEEKS = DayOfWeek.values();
	private final Random m_random;

	public RandomDayOfWeekFactory(Random m_random)
	{
		this.m_random = m_random;
	}

	public DayOfWeek getDayOfWeek()
	{
		return DAY_OF_WEEKS[m_random.nextInt(DAY_OF_WEEKS.length)];
	}
}


enum DayOfWeek{
	SUN, MON, TUE, WED, THU, FRI, SAT;
}


/*----------------------------------------------------------------------------------------------------------------------
	values her çağrıldığında yeni bir dizi yaratılır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		DayOfWeek [] dayOfWeeks1 = DayOfWeek.values();
		DayOfWeek [] dayOfWeeks2 = DayOfWeek.values();

		System.out.println(dayOfWeeks1 == dayOfWeeks2 ? "Ayni dizi":"Farklı diziler");
	}
}

enum DayOfWeek{
	SUN, MON, TUE, WED, THU, FRI, SAT;
}


/*----------------------------------------------------------------------------------------------------------------------
	enum ornek inceleme
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		DayOfWeek [] dayOfWeeks = DayOfWeek.values();

		dayOfWeeks[0] = DayOfWeek.THU;

		for (DayOfWeek dow:dayOfWeeks) {
			System.out.printf("%s ", dow.toString());
		}

		System.out.println();

		for (DayOfWeek dow : DayOfWeek.values()) {
			System.out.printf("%s ", dow.toString());
		}

		System.out.println();
	}
}

enum DayOfWeek{
	SUN, MON, TUE, WED, THU, FRI, SAT;
}


/*----------------------------------------------------------------------------------------------------------------------
	enum türleri switch deyimi ile kullanılabilmektedir. Bu durumda case bölümlerinin enum sabitlerinden olması gerekir.
    	Karşılaştırma işlemi == operatörü ile yapılır. case bölümlerine ilişkin sabitlerde enum ismi kullanımı geçersizdir.
    	Sabit ismi doğrudan kullanılır. Zaten switch deyime ilişkin ifade enum türünden olduğu için case bölümleri için
    	sabit isminin doğrudan kullanımında bir sorun oluşmaz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Input a marital status text as SINGLE, MARRIED or DIVORCED:");
		String maritalStatusStr = kb.nextLine();
		MaritalStatus maritalStatus = MaritalStatus.valueOf(maritalStatusStr.toUpperCase());

		switch (maritalStatus){
			case SINGLE -> System.out.println("Single person");
			case MARRIED -> System.out.println("Married person");
			case DIVORCED -> System.out.println("Divorced person");
		}

		System.out.println();
	}
}

enum MaritalStatus{
	SINGLE, MARRIED, DIVORCED;
}

/*----------------------------------------------------------------------------------------------------------------------
	yukarıdaki ornegin breaklli switch
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Input a marital status text as SINGLE, MARRIED or DIVORCED:");
		String maritalStatusStr = kb.nextLine();
		MaritalStatus maritalStatus = MaritalStatus.valueOf(maritalStatusStr.toUpperCase());

		switch (maritalStatus){
			case SINGLE : System.out.println("Single person"); break;
			case MARRIED : System.out.println("Married person"); break;
			case DIVORCED : System.out.println("Divorced person"); break;
		}

		System.out.println();
	}
}

enum MaritalStatus{
	SINGLE, MARRIED, DIVORCED;
}


/*----------------------------------------------------------------------------------------------------------------------
	Date sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.datetime.DateApp;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		DateApp.run();
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki Color sınıfına enum'la birlikte default olarak gelen bazı yetenekler eklenmiştir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.datetime.DateApp;

class App {
	public static void main(String [] args)
	{

	}
}

class Color{
	private static final Color[] COLORS = {new Color(0), new Color(1), new Color(2), new Color(3), new Color(4)};

	public static final Color RED = COLORS[0];
	public static final Color GREEN = COLORS[1];
	public static final Color BLUE = COLORS[2];
	public static final Color WHITE = COLORS[3];
	public static final Color BLACK = COLORS[4];
	private  final int m_ordinal;
	private Color(int ordinal)
	{
		m_ordinal = ordinal;
	}

	public int ordinal()
	{
		return m_ordinal;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Homework-15 iskeleti
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.game.card.Card;
import com.orhn.util.datetime.DateApp;

class App {
	public static void main(String [] args)
	{
		Card [] deck;

		deck = Card.getShuffledDeck();
		for (Card c : deck) {
			System.out.println(c.toString());
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıflar arası ilişkiler: Sınıflar arası ilişkiler aslında nesneler arasındaki ilişkiler olarak düşünülmeldir. Örneğin,
	uçak ile pilotları arasında bir ilişki vardır. Ya da araba ile motoru arasında da bir ilişki vardır. Burada uçak
	nesnesinin pilot nesneleri arasındaki ilişkiden bahsedilir. Benzer şekilde araba nesnesinin motor nesnesi olan
	ilişkiden bahsedilmiş olur. Ancak şüphesiz bu ilişkilere uygun olarak sınıflar yazılmalıdır.

	Nesne yönelimli programlama tekniği kullanılarak geliştirilecek bir projenin kodlama aşamasına gelindiğinde önce sınıflar
	ve aralarındaki ilişkiler belirlenir. Sonra kodlamaya geçilir. Sınıflar ve aralarındaki ilişkiler belirlenirken, sınıfların
	ve nesnelerin konuya (domain) ilişkin durumları düşünülür.

	Anahtar Notlar: Bir projenin müşteri ile görüşülmesinden (ihtiyaçların belirlenmesi için) teslime (deployment) kadar
	geçen sürecin çeşitli şemalar ile anlatılmasını sağlayan UML (Unified Modeling Language) denilen bir araç bazı
	durumlarda kullanılabilmektedir. Bu aracın önemli ve geliştiriciler ilgilendiren şemalarından birisi
	"sınıf şeması (class diagram)"'dır. Bu şema, kodlamaya yönelik ve kodlamaya başlamadan önce yapılır. Bu şemada sınıfların
	detayları ve aralarındaki ilişkiler çizilir.

	Anahtar Notlar: UML her zaman ve her detayı ile kullanılmalı mıdır? Bunun için verilecek cevap nettir: Hayır.
	Gerektiğinde ve gerektiği kadar kullanılmalıdır.

 	Anahtar Notlar: Kavram ya da kavramlar modellenirken genel durumlar düşünülür. İstisna niteliğinde olabilecek durumlar
 	modelleme yapılırken - genel olarak - göz önünde bulundurulmaz. Aksi durumda hiçbir şey modellenemez. Örneğin,
 	araba ile motoru arasındaki "X" ilişki için şu koşullar olsun ya da tersine aşağıdaki koşullar gerçeklendiğinde araba
 	ile motoru arasındaki ilişki "X" olsun:
 		1. Araba nesnesine ait motor nesnesi başka bir araba nesnesi veya başka bir nesne tarafından kullanılamaz
 		2. Araba nesnesine ait motor nesnesinin ömrü hemen hemen araba ile başlayıp, araba ile son bulacak
	Burada, ikinci madde bazı durumlarda gerçeklenmeyebilir. Ama bu ilişkin genel durumunu bozmaz.

	Bir sınıfın derlenebilmesi için başka bir sınıfın varolması gerektiği duruma "bağımlılık (dependency)" denir. Aslında bu
	kavram sadece sınıflara özgü değildir. Örneğin bir metodun içerisinde başka bir metodun çağrılması durumunda çağrılan
	metodun var olması gerekir. Bu anlamda çağıran metot çağrılan metoda bağımlıdır. Burada bağımlılık terimi sınıflar
	arasında ele alacağız.

	İki sınıf arasında aşağıdaki ilişkilerden ya hiçbirisi yoktur ya da bir tanesi vardır:
	1. İçerme (composition) (has a): A ve B arasındaki "A has a B" ilişkisi için aşağıdaki iki koşulun da gerçeklenmesi
	gerekir, ya da tersine aşağıdaki iki koşulun da gerçeklendiği ilişkidir:
		- A nesnesine ait B nesnesi başka bir nesne tarafından kullanılmayacak
		- A nesnesine ait B nesnesi ömrüne hemen hemen A ile başlayacak ve hemen hemen A ile ömrü son bulacak.
	Bu ilişkide A nesnesi kendisine ait B nesnesini istediği bir durumda (birçok durumda ya da hemen her durumda)
	kullanabilmektedir.

	2. Birleşme (aggregation) (holds a):  A ve B arasındaki "A holds a B" ilişkisi, composition ilişkisinin kurallarının
	en az bir tanesinin gerçeklenmediği bütünsel kullanım ilişkisidir.

	3. Çağrışım (association): A nesnesinin B nesnesini ihtiyacı olduğunda kullanması, saklamaması ilişkisidir. Yani
	bütünsel bir kullanım yoktur. Bu kullanıma "parçalı (partial)" da denir

	4. Türetme/Kalıtım (inheritance) (is a): Biyoloji'den programlamaya aktarılmıştır. Biyoloji'de kalıtım ebeveynin (parent)
	özelliklerinin çocuğuna (child) aktarılmasıdır. Programlamaya ilişkin detayları ileride ele alınacaktır

	Anahtar Notlar: Yukarıdaki ilişkilerden "inheritance dışında kalan ilişkiler için Java'da doğrudan sentaks ve semantic
	kurallar yoktur. Dilin genel sentaks kuralları ve semantik kuralları ile ilişkin kuralları doğrultusunda
	gerçekleştirilebilir (implementation). Ancak "inheritance" için Java'da ayrı sentaks ve semantik kurallar vardır.

	Anahtar Notlar: Bazı sınıfların implementasyonları gereği yukarıdaki ilişkilerden hiçbirisi olmayabilir. Ya da
	bazı özel durumlar dolayısıyla da iki sınıf arasında yukarıdaki ilişkilerden biri olmayabilir. Ama ortada yine bir
	bağımlılık (dependency) söz konusudur. Bu da yine genel durumu bozmaz. Böylesi durumlar ileride ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/



/*----------------------------------------------------------------------------------------------------------------------
	A ile B arasındaki "composition" ilişkisinin genel bir implementasyonu
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {
	public static void main(String [] args)
	{
        A a;

        a = new A();

        a.doWork1();
        a.doWork2();
	}
}

class A{
	private B m_b;

	public A()
	{
		m_b = new B();
	}

	public void doWork1()
	{
		//..
		m_b.doSomething();;
	}

	public void doWork2()
	{
		//..
		m_b.doSomething();;
	}
}

class B {
	//..
	public void doSomething()
	{
		//..
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	A ile B arasındaki "aggregation" ilişkisinin genel bir implementasyonu
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A a;
		a = new A();

		a.doWork1();
		a.doWork2();
	}
}

class A{
	private B m_b;

	public A()
	{
		m_b = new B();
	}

	public void doWork1()
	{
		//..
		m_b.doSomething();
	}

	public void doWork2()
	{
		//..
		m_b.doSomething();
	}
}

class B {
	//..
	public void doSomething()
	{
		//..
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	A ile B arasındaki "aggregation" ilişkisinin genel bir implementasyonu
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A a;
		B b1, b2;

		b1 = new B();
		a = new A(b1);

		a.doWork1();
		a.doWork2();

		b2 = new B();
		a.setB(b2);

		a.doWork1();
		a.doWork2();

	}
}

class A{
	private B m_b;

	public A(B b)
	{
		m_b = b;
	}

	public B getB()
	{
		return m_b;
	}

	public void setB(B b)
	{
		m_b = b;
	}

	public void doWork1()
	{
		//..
		m_b.doSomething();
	}

	public void doWork2()
	{
		//..
		m_b.doSomething();
	}
}

class B {
	//..
	public void doSomething()
	{
		//..
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
24.05.2023 Çarşamba - 38.Ders



/*----------------------------------------------------------------------------------------------------------------------
	Car, Plane, Driver, Pilot, Engine sınıfları ve aralarındaki ilişkiler. Örnekte detaylar göz ardı edilmiştir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Driver driver;
		driver = new Driver();

		driver.setUsername("AMehmet");
		driver.setName("Ali Mehmet Cetinkol");
		driver.setRating(100);

		Car car = new Car(driver);

		car.run();

		System.out.println("**************************************");

		Pilot[] pilots = {new Pilot(1, "Ali Cetinkol", 10000), new Pilot(2, "Orhan ozturk",
				7000), new Pilot(3, "Mahmut Tuncer", 5000)};
		Plane p = new Plane(4, pilots);

		p.fly();
	}
}

class  Plane{
	private Engine[] m_engines;
	private Pilot[] m_pilots;

	private void startEngines()
	{
		for (Engine engine : m_engines) {
			engine.startEngine();
		}
	}
	private void accelerateEngines()
	{
		for (Engine engine : m_engines) {
			engine.acclerateEngine();
		}
	}
	private void slowEngines()
	{
		for (Engine engine : m_engines) {
			engine.slowEngine();
		}
	}
	private void stopEngines()
	{
		for (Engine engine : m_engines) {
			engine.stopEngine();
		}
	}

	public Plane(int engineCount, Pilot [] pilots)
	{
		m_pilots = pilots;
		m_engines = new Engine[engineCount];

		for (int i = 0; i < engineCount; ++i)
			m_engines[i] = new Engine();
	}

	public void fly()
	{
		System.out.println("Pilots:");
		for (Pilot p: m_pilots) {
			System.out.printf("%d. %s, %d%n", p.getTitle(), p.getName(), p.getFlightDuration());
		}

		startEngines();
		accelerateEngines();
		//..

		System.out.println("Flying...");
		//..

		slowEngines();

		//..
		stopEngines();

	}
}

class Pilot{
	private int m_title;
	private String m_name;
	private int m_flightDuration;

	public Pilot(int title, String name, int flightDuration)
	{
		m_title = title;
		m_name = name;
		m_flightDuration = flightDuration;
	}

	public int getTitle() {
		return m_title;
	}

	public void setTitle(int m_title) {
		this.m_title = m_title;
	}

	public String getName() {
		return m_name;
	}

	public void setName(String m_name) {
		this.m_name = m_name;
	}

	public int getFlightDuration() {
		return m_flightDuration;
	}

	public void setFlightDuration(int m_flightDuration) {
		this.m_flightDuration = m_flightDuration;
	}
}

class Car{
	private Engine m_engine;
	private Driver m_driver;

	public Car(Driver driver)
	{
		m_driver = driver;
		m_engine = new Engine();
	}

	public void brake()
	{
		System.out.println("brake");
		m_engine.slowEngine();
	}

	public void run()
	{
		System.out.printf("Driver : %s, %d%n", m_driver.getName(), m_driver.getRating());

		m_engine.startEngine();
		m_engine.acclerateEngine();

		System.out.println("running...");

		brake();
		m_engine.stopEngine();
	}
}

class Driver{
	private String m_username;
	private String m_name;
	private int m_rating;

	public String getUsername() {
		return m_username;
	}

	public void setUsername(String m_username) {
		this.m_username = m_username;
	}

	public String getName() {
		return m_name;
	}

	public void setName(String m_name) {
		this.m_name = m_name;
	}

	public int getRating() {
		return m_rating;
	}

	public void setRating(int m_rating) {
		this.m_rating = m_rating;
	}
}

class Engine{
	//...
	public void startEngine()
	{
		System.out.println("Start Engine");
	}

	public void acclerateEngine()
	{
		System.out.println("Accelerate Engine");
	}

	public void slowEngine()
	{
		System.out.println("Slow Engine");
	}
	public void stopEngine()
	{
		System.out.println("Stop Engine");
	}

}


/*----------------------------------------------------------------------------------------------------------------------
	A ile B arasındaki "association" ilişkisi
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		B b1 =new B();
		B b2 =new B();

		A a = new A();

		a.doWork(b1);
		a.doWork(b2);
	}
}

class A{
	public void doWork(B b)
	{
		b.doSomething();;
	}
}

class B{
	public void doSomething()
	{
		//..
		System.out.println("B class doSomething");
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Taxi, Driver, Client sınıfları ve aralarındaki ilişkiler. Örnekte detaylar göz ardı edilmiştir
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Driver driver = new Driver();

		driver.setName("Ali Mehmet Cetinkol");
		driver.setUsername("AMC");
		driver.setRating(100);

		Taxi taxi = new Taxi(driver);
		Client client1 = new Client();

		client1.setName("Orhan");
		client1.setUsername("ozturk");

		taxi.takeClient(client1);

		Client client2 = new Client();

		client2.setUsername("mahmutTT");
		client2.setName("mahmut");

		taxi.takeClient(client2);
	}
}

class Taxi{
	private Driver m_driver;

	public Taxi(Driver driver)
	{
		m_driver = driver;
	}

	public Driver getDriver()
	{
		return m_driver;
	}

	public void setDriver(Driver driver)
	{
		m_driver = driver;
	}

	public void takeClient(Client client)
	{
		System.out.printf("Client: %s%n", client.getUsername());
		System.out.printf("Driver: %s, %d%n", m_driver.getUsername(), m_driver.getRating());
	}
}

class Client {
	private String m_username;
	private String m_name;

	public String getUsername() {
		return m_username;
	}

	public void setUsername(String m_username) {
		this.m_username = m_username;
	}

	public String getName() {
		return m_name;
	}

	public void setName(String m_name) {
		this.m_name = m_name;
	}
}

class Driver{
	private String m_username;
	private String m_name;
	private int m_rating;

	public String getUsername() {
		return m_username;
	}

	public void setUsername(String m_username) {
		this.m_username = m_username;
	}

	public String getName() {
		return m_name;
	}

	public void setName(String m_name) {
		this.m_name = m_name;
	}

	public int getRating() {
		return m_rating;
	}

	public void setRating(int m_rating) {
		this.m_rating = m_rating;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Türetme/kalıtım (inheritance) kavramı ile programlamada bir sınıf kodlarına dokunmadan veya kodları kopyalanmadan
	genişletilebilir (extension). Burada genişletme var olan özelliklere ekleme olarak düşünülebilir. Bu ilişkide B
	sınıfı A sınıfından türetilmiş ise "B is a A" cümlesi geçerli olur.

	B sınıfı A sınıfından türetilmiş olsun. B sınıfına A sınıfının "türemiş sınıfı (derived class)" denir. A sınıfına da
	B sınıfının "taban sınıfı (base class)" denir. Bu iki terim nesne yönelimli programlama tekniğine ilişkin genel
	terimlerdir. Java'da "base class" yerine "super class", "derived class" yerine de "sub class" terimleri daha çok
	kullanılır.

	Anahtar Notlar: Nesne yönelimli programlamada "base class" yerine Biyoloji'den gelen "parent class", "derived class"
	yerine yine Biyoloji'den gelen "child class" terimleri de kullanılır.

	Bir dizi türetme söz konusu olabilir. Örneğin C sınıfı B sınıfından, B sınıfı da A sınıfından türetilmiş olsun. Bu
	durumda C'nin taban sınıfı (super class) dendiğinde doğrudan taban sınıfı (direct super class) olan B sınıfı anlaşılır.
	Bu hiyerarşide A sınıfı C'nin dolaylı taban sınıfıdır (indirect super class). Örnekte, "C'nin taban sınıfı B ve A'dır"
	cümlesi teknik olarak doğru değildir. Doğrusu "C'nin taban sınıfı B'dir, dolaylı taban sınıflarından biri A'dı"
	şeklinde söylenebilir.

	Java'da bir sınıf birden fazla taban sınıfa sahip olamaz. Yani Java'da "çoklu türetme/kalıtım (multiple inheritance)"
	yoktur. Java'da bir sınıf yalnızca tek bir sınıftan türetilebilir.

	Anahtar Notlar: Java'da çoklu türetmenin gerektiği yerlerde kısmi (parçalı) olarak desteklenmesini sağlayan "interface"
	denilen bir "user defined type" bulunmaktadır. Çok türetmenin pratikteki gerekliliği "interface"'ler ile
	karşılanabilmektedir. "interface" konusu ileride ele alınacaktır.

	Türetme kavramı programlamada "bir sınıfın kodlarına dokunmadan o sınıfı genişletmek" anlamına geldiğinden, nesne
	yönelimli programlama tekiniğine ilişkin ilkelerden "Open Closed Principle (OCP)"'a örnek olabilir. Bu ilkenin
	mottosu "open for extension closed for modification"'dır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da türetme extends anahtar sözcüğü ile yapılır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class E extends B {

}

class D extends  A{
	//..
}
class C extends B{
	//..
}

class B extends A{
	//..
}

class A{
	//..
}



/*----------------------------------------------------------------------------------------------------------------------
	Taban sınıfın metotları türemiş sınıfa aktarılır. Aşağıdaki örnekte foo metodu B sınıfına A'dan, foo ve bar metodu da
	C sınıfına B'den aktarılmıştır. Bu kavrama "davranışsal genişletme (behavioral extension)" de denir. "extension"
	terimi tek başına kullanıldığında genel olarak veri elemanı ekleyerek genişletme anlamına gelir. Şüphesiz metot
	eklemek de bir genişletmedir
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		C c = new C();

		c.foo();
		c.bar();
		c.tar();


	}
}

class C extends B{
	public void tar()
	{
		System.out.println("C.tar");
	}
}

class B extends A{
	public void bar()
	{
		System.out.println("B.bar");
	}
}
class  A{
	public void foo()
	{
		System.out.println("A. foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf nesnesi içerisinde taban sınıf nesnesi kadar alan da bulunur. Yabi türemiş sınıf nesnesi içerisinbde
	taban sınıflın non-static veri elemanları da vardır. Bu durumda bir nesnesel kapsama vardır. Bu durumda türemiş
	sınıf nesnesinin uzunluğu "en az, taban sınıf nesnesinin bellekte kapladığı alan + türemiş sınıfa eklenen non-static
	veri elemanlarının toplam uzunluğu" kadardır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		C x = new C();

		x.a = 10;
		x.b = 20;
		x.c = 30;

		System.out.printf("x.a : %d%n", x.a);
		System.out.printf("x.b : %d%n", x.b);
		System.out.printf("x.c : %d%n", x.c);
	}
}

class C extends B{
	public int c;
}

class B extends A{
	public int b;
}
class  A{
	public int a;
}

/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi bir nesnenin yaratılmış olması için geçilen 3 adımdan sonuncusu olan ctor'un da çağrılıp düzgün
	bir biçimde (exception oluşmadan) sonlanmış olması gerekir. Yani, 3 adımın da düzgün bir biçimde tamamlanmış olması
	gerekir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf nesnesinin yaratılması aşamasında ctor çağrısından önce, taban sınıfın ctor'u çağrılır. Herhangi bir
	ctor belirtilmemişse taban sınıfın default ctor'u çağrılır. Yani derleyici türemiş sınıfın ctor'unun başına gizlice
	taban sınıfın default ctor'unun çağrılmasını sağlayan kodu yazar
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		B x = new B();
		System.out.println("----------------------------------");
		B y = new B(15);
		System.out.println("----------------------------------");
		C z = new C();
		System.out.println("----------------------------------");
		C t = new C(22);
		System.out.println("----------------------------------");
	}
}

class C extends B{
	public C()
	{
		System.out.println("I am a default ctor of C");
	}
	public C(int x)
	{
		System.out.println("I am a ctor of C with parameter int");
	}
}

class B extends A{
	public B()
	{
		System.out.println("I am a default ctor of B");
	}
	public B(int x)
	{
		System.out.println("I am a ctor of B with parameter int");
	}
}
class  A{
	public A()
	{
		System.out.println("I am a default ctor of A");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Türemiş sınıfı yazan programcı "super ctor sentaksı" ile taban sınıfın istenilen ctor'unun çağrılmasını sağlayabilir.
	super ctor sentaksında taban sınıfın hangi ctor'unun çağrılacağı derleyici tarafından "method overload resolution"
	kuralları ile belirlenir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		B x = new B();
		System.out.println("----------------------------------");
		B y = new B(15);
		System.out.println("----------------------------------");
		C z = new C();
		System.out.println("----------------------------------");
		C t = new C(22);
		System.out.println("----------------------------------");
	}
}

class C extends B{
	public C()
	{
		System.out.println("I am a default ctor of C");
	}
	public C(int x)
	{
		super(x);
		System.out.println("I am a ctor of C with parameter int");
	}
}

class B extends A{
	public B()
	{
		System.out.println("I am a default ctor of B");
	}
	public B(int x)
	{
		super(x);
		System.out.println("I am a ctor of B with parameter int");
	}
}
class  A{
	public A()
	{
		System.out.println("I am a default ctor of A");
	}
	public A(int x)
	{
		System.out.println("I am a ctor of A with parameter int");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ve *** ile belirtilen deyim yazılsa da yazılmasa da aynı anlamdadır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		B x = new B();
		System.out.println("----------------------------------");
		B y = new B(15);
		System.out.println("----------------------------------");
		C z = new C();
		System.out.println("----------------------------------");
		C t = new C(22);
		System.out.println("----------------------------------");
	}
}

class C extends B{
	public C()
	{
		super();//**
		System.out.println("I am a default ctor of C");
	}
	public C(int x)
	{
		super(x);
		System.out.println("I am a ctor of C with parameter int");
	}
}

class B extends A{
	public B()
	{
		super();//**
		System.out.println("I am a default ctor of B");
	}
	public B(int x)
	{
		super(x);
		System.out.println("I am a ctor of B with parameter int");
	}
}
class  A{
	public A()
	{
		System.out.println("I am a default ctor of A");
	}
	public A(int x)
	{
		System.out.println("I am a ctor of A with parameter int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	super ctor sentaksı ctor'un ilk deyimi olmak zorundadır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}


class B extends A{
	public B()
	{
		System.out.println("I am a default ctor of B");
	}
	public B(int x)
	{
		System.out.println("I am a ctor of B with parameter int");
		super(x); //error
	}
}
class  A{
	public A()
	{
		System.out.println("I am a default ctor of A");
	}
	public A(int x)
	{
		System.out.println("I am a ctor of A with parameter int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	super ctor sentaksı adından da anlaşılacağı gibi yalnızca ctor içerisinde kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}


class B extends A{
	public B()
	{
		System.out.println("I am a default ctor of B");
	}
	public B(int x)
	{
		super(x);
		System.out.println("I am a ctor of B with parameter int");
	}

	public void foo(int x)
	{
		super(x); //error
	}

}
class  A{
	public A()
	{
		System.out.println("I am a default ctor of A");
	}
	public A(int x)
	{
		System.out.println("I am a ctor of A with parameter int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bazı durumlarda sınıfın bir ctor'u içerisinde sınıfın başka bir ctor'unun çağrılması istenebilir. Bu durumda
	"this ctor sentaksı" kullanılır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A x = new A();
		System.out.println("-----------------------------------");
		A y = new A(4.5, "istanbul");
		System.out.println("-----------------------------------");
		A z = new A(4.5);
		System.out.println("-----------------------------------");
	}
}

class  A{
	public A()
	{
		System.out.println("I am a default ctor of A");
	}
	public A(double a)
	{
		this();
		System.out.println("I am a ctor of A with parameter double");
	}
	public A(String s)
	{
		System.out.println("I am a ctor of A with parameter Stirng");
	}
	public A(double a, String s)
	{
		this(a);
		System.out.println("I am a ctor of A with parameter double, String");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	this ctor sentaksı da ctor'un ilk deyimi olmak zorundadır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A x = new A();
		System.out.println("-----------------------------------");
		A y = new A(4.5, "istanbul");
		System.out.println("-----------------------------------");
		A z = new A(4.5);
		System.out.println("-----------------------------------");
	}
}

class  A{
	public A()
	{
		System.out.println("I am a default ctor of A");
	}
	public A(double a)
	{
		System.out.println("I am a ctor of A with parameter double");
		this(); //error
	}
	public A(String s)
	{
		System.out.println("I am a ctor of A with parameter Stirng");
	}
	public A(double a, String s)
	{
		this(a);
		System.out.println("I am a ctor of A with parameter double, String");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	this ctor sentaksında döngüsel durum geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A z = new A(4.5);
		System.out.println("-----------------------------------");
	}
}

class  A{

	public A(double a)
	{
		this(a + "");
		System.out.println("I am a ctor of A with parameter double");
	}
	public A(String s)
	{
		this(3.3);
		System.out.println("I am a ctor of A with parameter Stirng");
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte yine döngüsel durum oluşur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A z = new A(4.5);
		System.out.println("-----------------------------------");
	}
}

class  A{

	public A(double a)
	{
		System.out.println("I am a ctor of A with parameter double");
	}
	public A(int a) //error
	{
		this(a);
		System.out.println("I am a ctor of A with parameter Stirng");
	}

}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte int parametreli ctor'dan önce double parametreli ctor'un çağrılabilmesi için tür dönüştürme
	operatörü kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A z = new A(10);
		System.out.println("-----------------------------------");
	}
}

class  A{

	public A(double a)
	{
		System.out.println("I am a ctor of A with parameter double");
	}
	public A(int a)
	{
		this((double) a);
		System.out.println("I am a ctor of A with parameter int");
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	this ve super ctor sentaksları aynı anda bulunamazlar. Çünkü ikisi de ctor'un ilk deyimi olmak zorundadır. Böyle bir
	durumla karşılaşan programcının yazdığı koda ve tasarımına bakması gerekir. Çünkü doğru bir tasarım (yaklaşım) ve
	doğru bir kodlama programcıyı böyle bir noktaya getirmez
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class B extends A{
	public B()
	{
		this(0);
		super(10); //error
		System.out.println("I am a default ctor of B");
	}

	public B(int a)
	{
		super(a);
		System.out.println("I am a ctor of B with parameter int");
	}
}

class  A{

	public A()
	{
		System.out.println("I am a default ctor of A");
	}
	public A(int a)
	{
		System.out.println("I am a ctor of A with parameter int");
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da bir sınıf bildiriminde extends anahtar sözcüğü kullanılmasa bile (yani sınıfı yazan programcı taban sınıf
	ismi belirtmediğinde) java.lang paketi içerisinde bulunan Object isimli bir sınıftan türetilmiş olur. Yani Java'da
	Object sınıfı tüm sınıfların doğrudan ya da dolaylı olarak taban sınıftır. Object sınıfından türetme açıkça yazılabilir.
	Yazılmasa da aynı anlamdadır. Biz yazmamayı tercih edeceğiz. Bu şekildeki yaklaşımın gerekliliği ve önemi ileride
	ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class B extends Object{
	//...
}

class A{

}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli ve niteliksiz isim arama genel kurallarına göre bir isim ilgili sınıfta bulunamazsa taban sınıfa ve dolaylı taban
	sınıflara da sırasıyla bulununcaya ya da bulanamayıncaya kadar bakılır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		C x = new C();
		x.bar(12);

		System.out.printf("x.a = %d%n", x.a);
		System.out.printf("x.b = %d%n", x.b);
	}
}

class C extends B{
	public void bar(int val)
	{
		foo();
		b = val;
		a = -b;
	}
}

class B extends A{
	public int b;
	public void foo()
	{
		System.out.println("B.foo");
	}
}

class A{
	public int a;
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıfın protected bölümün türemiş sınıf içerisinde aşağıdaki gibi erişilemez
---------------------------------------------------------------------------------------------------------------------*/
package orhn;

public class A {
    protected int x;
    protected A()
    {
        //
    }
    protected void foo()
    {

    }
}

package ozturk;

import orhn.A;

public class B extends A {
    public void bar()
    {
       A a = new A(); //error
       a.foo(); //error
       a.x = 10; //error
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	 Türemiş sınıf içerisinde kendisine ait olan, taban sınıfın protected bölümüne erişilebilir. Bu durumda protected
    elemanlara doğrudan erişim mümkündür. ctor için ise istenirse super ctor sentaksı kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

public class A {
    protected int x;
    protected A()
    {
        //
    }
    protected void foo()
    {

    }
}

package ozturk;

import orhn.A;

public class B extends A {
   public B(int a)
   {

   }

   public void bar()
   {
       x = 10;
       foo();
   }
}


-----------------------------------------------------------
-----------------------------------------------------------
25.05.2023 Perşembe - 39.Ders

/*----------------------------------------------------------------------------------------------------------------------
	 Sınıf Çalışması: com.orhn.util.datetime paketi içerisindeki Time ve TimeUtil sınıflarını yazınız
	 Açıklamalar:
		- Sınıfın public bölümünü değiştirmeden diledğiniz kadar metot ya da veri ekleyebilirsiniz
		- Zaman geçerlilik kontrolü yapılacaktır. Geçersiz olması durumunda program uygun mesaj verip sonlandırılacaktır

----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.Time;

class App {
	public static void main(String [] args)
	{
		Time now = new Time();

		System.out.println(now.toLongTimeString());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte basit bir dijital saat yapılmıştır. Aslında örnek efektif yazılmamıştır. Sadece durumu göstermek
	için bu şekilde yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.Time;

class App {
	public static void main(String [] args)
	{
		for (;;) {
			Time now = new Time();
			System.out.printf("%s\r", now.toString());
		}
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte basit bir dijital saat yapılmıştır. Aslında örnek efektif yazılmamıştır. Sadece durumu göstermek
	için bu şekilde yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.Time;

class App {
	public static void main(String [] args)
	{
		Time time = new Time(9, 23, 15, 234);

		System.out.println(time.toLongTimeString());

		time.setHour(33);

		System.out.println(time.toShortTimeString());
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte basit bir dijital saat yapılmıştır. Aslında örnek efektif yazılmamıştır. Sadece durumu göstermek
	için bu şekilde yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.Time;

class App {
	public static void main(String [] args)
	{
		Time time = new Time(9, 60, 15, 234);

		System.out.println(time.toLongTimeString());

		time.setHour(33);

		System.out.println(time.toShortTimeString());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte basit bir dijital saat yapılmıştır. Aslında örnek efektif yazılmamıştır. Sadece durumu göstermek
	için bu şekilde yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.Time;

class App {
	public static void main(String [] args)
	{
		Time time = new Time(10, 15);

		System.out.println(time.toLongTimeString());

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte basit bir dijital saat yapılmıştır. Aslında örnek efektif yazılmamıştır. Sadece durumu göstermek
	için bu şekilde yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.Time;
import com.orhn.util.datetime.TimeUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Random r = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayi giriniz : ");
		int count = kb.nextInt();

		while (count-- > 0){
			System.out.println(TimeUtil.randomTime(r).toLongTimeString());
		}
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
28.05.2023 Pazar Cumhurbaşkanlığı 2. Tur Seçimleri - 40.Ders

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir kesri temsil eden MutableFraction isimli sınıfı aşağıdaki açıklamalara göre yazınız
	Açıklamalar:
	- Sınıf Matematikteki bir kesri temsil ettiğinden pay ve payda değerleri tutulacaktır

	- Sınıfın ilgili set ve get metotları yazılacaktır

	- Pay'ın sıfırdan farklı, paydanın sıfır olması durumunda tanımsızlığa ilişkin bir mesaj verilecektir, pay ve paydanın
	her ikisinin birden sıfır olması durumunda belirsizliğe ilişkin mesaj verilecektir. Her iki durumda da program
	sonlandırılacaktır

	- Kesir her durumda sadeleşmiş bir biçimde tutulacaktır. Örneğin kesrin pay ve paydası sırasıyla 4 ve 18 olarak
	verildiğinde kesir 2 / 9 olarak tutulacaktır.

	- Kesir negatif ise işaret payda bulunacaktır. Örneğin kesrin pay ve paydası sırasıyla 3 ve -4 olarak verilmişse
	kesir -3 / 4 biçiminde tutulacaktır

	- Kesrin pay ve paydasının ikisinin birden negatif olması durumunda kesir pozitif olarak tutulacaktır

	- Kesrin payının sıfır olması durumunda payda ne olursa olsun 1(bir) yapılacaktır

	- Sınıfın iki kesri toplayan, bir kesir ile bir tamsayıyı toplayan aşağıdaki gibi metotları olacaktır. Aynı işlemler
	 çıkarma, çarpma ve bölme için de yapılacaktır

	- Sınıfın kesri 1(bir) artıran ve bir azaltan inc ve dec metotları yazılacaktır

	- Sınıfın toString metodu şu formatta yazı döndürecektir:
	    3 / 10 kesri için -> 3 / 10 = 3.333333
	    10 / 1 kesri için -> 10

	 - Sınıfın public bölümünü değiştirmeden istediğiniz değişikliği ve eklemeleri yapabilirsiniz

----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf = new MutableFraction(16, 56);

		System.out.println(mf.toString());
	}
}


package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf = new MutableFraction(16, 8);

		System.out.println(mf.toString());
	}
}


package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf = new MutableFraction(16, 0);

		System.out.println(mf.toString());
	}
}


package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf = new MutableFraction(0, 0);

		System.out.println(mf.toString());
	}
}

package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf = new MutableFraction(18, 27);

		System.out.println(mf.toString());

		mf.setDenominator(0);
		System.out.println(mf.toString());
	}
}

package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf1 = new MutableFraction(18, 27);
		MutableFraction mf2 = new MutableFraction(3, 4);

		MutableFraction result = mf1.add(mf2);

		System.out.println(result.toString());
	}
}
package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf1 = new MutableFraction(18, 27);
		MutableFraction mf2 = new MutableFraction(3, 4);

		MutableFraction result = mf1.subtract(mf2);

		System.out.println(result.toString());
	}
}

package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf1 = new MutableFraction(18, 27);
		MutableFraction mf2 = new MutableFraction(3, 4);

		MutableFraction result = mf1.multiply(mf2);

		System.out.println(result.toString());
	}
}

package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf1 = new MutableFraction(18, 27);
		MutableFraction mf2 = new MutableFraction(3, 4);

		MutableFraction result = mf1.divide(mf2);

		System.out.println(result.toString());
	}
}


package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf = new MutableFraction(18, 27);

		System.out.println(mf.toString());

		mf.inc(5);

		System.out.println(mf.toString());


		mf.dec(5);

		System.out.println(mf.toString());
	}
}


package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		MutableFraction mf = new MutableFraction(18, 27);

		System.out.println(mf.toString());

		mf.inc();

		System.out.println(mf.toString());


		mf.dec();

		System.out.println(mf.toString());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	DateTime Sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.DateTime;
import com.orhn.util.datetime.Month;

class App {
	public static void main(String [] args)
	{
		DateTime dateTime = new DateTime(28, Month.MAY, 2023, 14, 55, 45, 445);

		System.out.println(dateTime.toShortDateTimeStringTR());
		System.out.println(dateTime.toShortDateTimeStringEN());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	DateTime Sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.DateTime;
import com.orhn.util.datetime.Month;

class App {
	public static void main(String [] args)
	{
		DateTime dateTime = new DateTime(28, Month.MAY, 2023, 14, 55, 45, 445);

		System.out.println(dateTime.toLongDateTimeStringTR());
		System.out.println(dateTime.toLongDateTimeStringEN());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	DateTime Sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.DateTime;
import com.orhn.util.datetime.Month;

class App {
	public static void main(String [] args)
	{
		DateTime dateTime = new DateTime(28, Month.MAY, 2023, 14, 55, 45, 445);

		System.out.println(dateTime.toLongDateTimeStringEN());

		dateTime.setDay(29);
		dateTime.setMonth(Month.AUG);
		System.out.println(dateTime.toLongDateTimeStringEN());

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir sınıf içerisinde gizlenmiş tutulan bir başka referansa ilişkin sınıfın bir metodunun
	genel olarak aynı isimde (ve aynı parametik yapıda) sınıf dışından da kullanılacak şekilde yazılan metoduna
	"delegate/forwarding/pass through method" denir. Java'da daha çok "delegate" terimi kullanılır
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	AnalyticalCircle Sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;


import com.orhn.math.geometry.AnalyticalCircle;

class App {
	public static void main(String [] args)
	{
		AnalyticalCircle ac = new AnalyticalCircle(-4.5, 100, 200);

		System.out.printf("Radius:%f%n", ac.getRadius());
		System.out.printf("Circumference:%f%n", ac.getCircumference());
		System.out.printf("Area:%f%n", ac.getArea());
		System.out.printf("Center:(%d, %d)%n", ac.getX(), ac.getY());

		ac.setX(-200);
		ac.setRadius(5.6);

		System.out.printf("Radius:%f%n", ac.getRadius());
		System.out.printf("Circumference:%f%n", ac.getCircumference());
		System.out.printf("Area:%f%n", ac.getArea());
		System.out.printf("Center:(%d, %d)%n", ac.getX(), ac.getY());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfı immutable olduğundan WeatherInfo sınıfı ile  String sınıfı ilişki ne aggregation, ne de composition
	ilişkisidir. İkisine de belirli ölçüde yakın olsa da tam olarak uymamaktadır. Bu özel bir durumdur ve genel ilişkileri
	etkilemez. Bu ilişkiye isim verilmesi de gerekmez
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		String name = "Any place";
		double lat = 32.5;
		double lng = 34.5;

		WeatherInfo wi = new WeatherInfo(name, lat, lng);

		System.out.println(wi.toString());

		name = "other place";
		System.out.println(wi.toString());

	}
}

class WeatherInfo{
	private String m_place;
	private double m_latitude;
	private double m_longitude;

	public WeatherInfo(String place, double latitude, double longitude)
	{
		m_place = place;
		m_latitude = latitude;
		m_longitude = longitude;
	}

	public String toString()
	{
		return String.format("%s:(%f, %f)", m_place, m_latitude, m_longitude);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki NumericLottery sınıfı ile Random sınıfı arasında 4 ilişkiden hiçbirisi yoktur. Özel durumdur. Random sınıfı,
    içerisinde tuttuğu verilerin değil, davranışlarının yani metotlarının daha anlamlı olduğu bir sınıftır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app.lottery;
import java.util.Random;

public class NumericLottery {
    private final Random random;

    public  NumericLottery()
    {
        random = new Random();
    }

    public NumericLottery(Random r)
    {
        random = r;
    }

    public int[] getNumbers() {
        return getNumbers(getFlags());
    }

    private static int [] getNumbers(boolean [] flags)
    {
        int []numbers = new int[6];

        int idx = 0;

        for (int i = 1; i < 50; ++i)
            if(flags[i])
                numbers[idx++] = i;

        return numbers;
    }

    public int [][] getNumbers(int count)
    {
        int [][] numbers = new int[count][];

        for (int i = 0; i < count; ++i)
            numbers[i] = getNumbers();

        return numbers;
    }

    private boolean [] getFlags()
    {
        boolean [] flags = new boolean[50];

        for (int i = 0; i < 6; ++i){
            int a;

            for (;;){
                a = random.nextInt(1, 49);
                if(!flags[a])
                    break;
            }
            flags[a] = true;
        }
        return flags;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aralarında türetme ilişkisi olmayan iki sınıf türünden referans birbirinie tür dönüştürme operatörü (explicit) ile
	bile dönüştürülemez (atanamaz)
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		X x;
		Y y;

		x = new X();
		y = (Y) x; //error
	}
}

class X{
	//..
}

class Y{
	//..
}

/*----------------------------------------------------------------------------------------------------------------------
	Taban sınıf türünden bir referans, türemiş sınıf türünden bir referansa doğrudan (implicit) atanamaz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		X x;
		Y y;

		x = new X();
		y = x;  //error
	}
}

class Y extends X{
	//..
}
class X {
	//..
}

/*----------------------------------------------------------------------------------------------------------------------
	Taban sınıf türünden bir referans, türemiş sınıf türünden bir referansa doğrudan (implicit) atanamaz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		B x;
		A y;

		x = new B();

		x.a = 20;
		x.b = 30;

		y = x; //upcasting

		System.out.printf("x.a = %d%n", x.a);
		System.out.printf("x.b = %d%n", x.b);
		System.out.printf("y.a = %d%n", y.a);
		System.out.println("----------------------------------");

		++y.a;

		System.out.printf("x.a = %d%n", x.a);
		System.out.printf("x.b = %d%n", x.b);
		System.out.printf("y.a = %d%n", y.a);
	}
}

class B extends A{
	public int b;
	// ..
}
class A {
	public int a;
	//..
}

/*----------------------------------------------------------------------------------------------------------------------
		Aşağıdaki örnekte doWork metodu yalnızca A sınıfına bağlı (dependency) olarak yazılmıştır. Bu metot A sınıfından
	doğrudan ya da dolaylı olarak türetilen her sınıf türünden referans ile çağrılabilir. Yani, doWork metodu için derleme
	zamanından yalnızca A türünün bulunması yeterlidir. Hatta daha sonra A'dan doğrudan ya da dolaylı olarak türetilmiş
	yani A'dan türeyen sınıflar hiyerarşisine eklenmiş sınıflar için de doWork metodu çağrılabilir. Yani doWork metodunu
	ayrıca değiştirmeye gerek yoktur. Burada doWork metodu "türden bağımsız" yazılmıştır. Türden bağımsız kod yazma kavramı
	detaylı olarak ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A a = new A();
		B b = new B();
		C c = new C();
		D d = new D();
		E e = new E();
		F f = new F();

		Sample.doWork(a);
		Sample.doWork(b); //upcasting
		Sample.doWork(c); //upcasting
		Sample.doWork(d); //upcasting
		Sample.doWork(e); //upcasting
		Sample.doWork(f); //upcasting
	}
}

class Sample{
	public static void doWork(A a)
	{
		++a.x;
	}
}

class F extends C{

}
class E extends B{

}
class D extends A{

}

class C extends B{

}

class B extends A{

	// ..
}
class A {
	public int x;
	//..
}


-----------------------------------------------------------
-----------------------------------------------------------
13.06.2023 Salı - 41.Ders

/*----------------------------------------------------------------------------------------------------------------------
	CompanyApp uygulaması
	Not: CompanyApp sınıfındaki getManager, getWorker, getSalesManaber ve getProjectWorker metotları tamamen konuyu
	anlatmak için yazılmıştır

	20:09
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.company.CompanyApp;

class App {
	public static void main(String [] args)
	{
		CompanyApp.run();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
		Bir referans değişkenin iki tane türü vardır: static, dynamic

	- static type: Referansın bildirildiği türdür. "Referansın türü" dendiğinde static tür anlaşılır. Derleme zamanına
	ilişkin bir bilgidir ve değişmez.

	- dynamic type: Referansın gösterdiği nesnenin gerçek türüdür. Çalışma zamanına ilişkindir ve değişebilir

	Anahtar Notlar: Bir referansın dinamik türü String olarak aşağıdaki genel biçimi biçimi verilen çağrı ile elde
	edilebilir.
		<referans>.getClass().getName();
	Buna göre x bir referans olmak üzere x referansının dinamik türü şu şekilde ekrana yazdırılabilir:
		System.out.println(x.getClass().getName());

	Aşağıdaki örnekte x'in dinamik türünün değişimi basit bir şekilde gösterilmiştir. Örnekte dikkat edilirse App sınıfının
	main metodu A sınıfının türetme hiyerarşisi içerisinde yalnızca A sınıfına bağlı olarak yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;


import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		SampleFactory factory = new SampleFactory();

		A a;

		System.out.print("Bir sayi giriniz:");
		int count = kb.nextInt();

		while (count-- > 0){
			a = factory.getRandomA();
			System.out.println(a.getClass().getName());
		}
	}
}

class SampleFactory{
	private final Random m_random = new Random();

	public A getRandomA()
	{
		int val = m_random.nextInt(5);

		return switch (val){
			case 0 -> new B();
			case 1 -> new C();
			case 2 -> new D();
			case 3 -> new E();
			default -> new F();
		};
	}

}

class F extends E{

}


class E extends A{

}

class D extends B{

}

class C extends B{

}

class B extends A{

}
class A{

}

/*----------------------------------------------------------------------------------------------------------------------
		Bir referans değişkenin iki tane türü vardır: static, dynamic

	- static type: Referansın bildirildiği türdür. "Referansın türü" dendiğinde static tür anlaşılır. Derleme zamanına
	ilişkin bir bilgidir ve değişmez.

	- dynamic type: Referansın gösterdiği nesnenin gerçek türüdür. Çalışma zamanına ilişkindir ve değişebilir

	Anahtar Notlar: Bir referansın dinamik türü String olarak aşağıdaki genel biçimi biçimi verilen çağrı ile elde
	edilebilir.
		<referans>.getClass().getName();
	Buna göre x bir referans olmak üzere x referansının dinamik türü şu şekilde ekrana yazdırılabilir:
		System.out.println(x.getClass().getName());

	Aşağıdaki örnekte x'in dinamik türünün değişimi basit bir şekilde gösterilmiştir. Örnekte dikkat edilirse App sınıfının
	main metodu A sınıfının türetme hiyerarşisi içerisinde yalnızca A sınıfına bağlı olarak yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;


class App {
	public static void main(String [] args)
	{
		C c = new C();
		B b;
		A a;

		b = c;

		System.out.println(b.getClass().getName());

		a = b;

		System.out.println(a.getClass().getName());

		System.out.println(b.getClass().getName());
	}
}


class C extends B{

}

class B extends A{

}
class A{

}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir dizi referansının dinamik türüne ilişkin ismi JNI (Java Native Interface) tür ismi olarak
	elde edilir. Bu isim aslında arakoddakiş isimdir. Detaylar burada ele alınmayacaktır. Aşağıdaki örneğin ekran
	çıktısı şu şekildedir:
	[I
    [D
    [C
    [Z
    [Ljava.lang.String;
    [Lcom.orhn.util.math.geometry.Point;
    [[I
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;


import com.orhn.math.geometry.Point;

class App {
	public static void main(String [] args)
	{
		int [] a = new int[10];
		double [] b = new double[10];
		char [] c = new char[20];
		boolean [] d = new boolean[20];
		String [] e = new String[5];
		Point [] f = new Point[10];
		int [][] g = new int[10][];

		System.out.println(a.getClass().getName());
		System.out.println(b.getClass().getName());
		System.out.println(c.getClass().getName());
		System.out.println(d.getClass().getName());
		System.out.println(e.getClass().getName());
		System.out.println(f.getClass().getName());
		System.out.println(g.getClass().getName());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Taban sınıf türünden bir referans türemiş sınıf türünden bir referansa doğrudan atanamaz. Bu işlem tür dönüştürme
	operatörü ile yapılabilir. Bu işleme "downcasting" denir. Burada tür dönüştürme operatörü derlemeden geçmek için
	kullanılır. Çalışma zamanında kaynak referansın dinamik türünün tür dönüştürme operatörüne yazılan türü (hedef tür)
	kapsayıp kapsamadığına bakılır. Kapsıyorsa haklı dönüşümdür, akış devam eder. Kapsamıyorsa haksız dönüşümdür exception
	oluşur. Buradaki kapsama nesneseldir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		SampleFactory factory = new SampleFactory();

		A a;

		System.out.print("Bir sayi giriniz:");
		int count = kb.nextInt();

		B b;
		while (count-- > 0){
			a = factory.getRandomA();
			System.out.println(a.getClass().getName());
			b = (B)a;
			b.y = 20;
		}
	}
}

class SampleFactory{
	private final Random m_random = new Random();

	public A getRandomA()
	{
		int val = m_random.nextInt(5);

		return switch (val){
			case 0 -> new B();
			case 1 -> new C();
			default -> new A();
		};
	}

}

class C extends B{
	public int z;
}

class B extends A{
	public int y;
}
class A{
	public int x;
}


/*----------------------------------------------------------------------------------------------------------------------
	Object sınıfı doğrudan ya da dolaylı olarak her sınıfın taban sınıfı olduğuna göre her türden referans Object türünden
	referansa atanabilir. Aşağıdaki örnekte çeşitli referans türleri için Object referansları kullanılarak upcasting yapılmış
	downcasting yapılarak dinamik türlere ilişkin referanslar elde edilmiştir. Şüphesiz downcasting işleminin dinamik
	tür bilinmeden yapılması exception oluşumuna yol açabilir. Bilinmiyorsa bu dönüşüm nasıl yapılacaktır?
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.math.MutableFraction;
import com.orhn.math.geometry.Circle;
import com.orhn.util.ArrayUtil;
import com.orhn.util.datetime.Date;

class App {
	public static void main(String [] args)
	{
		Object os = "istanbul";
		Object oc = new Circle(2.4);
		Object od = new Date();
		Object oia = new int[10];
		Object of = new MutableFraction(10, -5);

		System.out.println(os.getClass().getName());
		System.out.println(oc.getClass().getName());
		System.out.println(od.getClass().getName());
		System.out.println(oia.getClass().getName());
		System.out.println(of.getClass().getName());

		String s = (String) os;
		Circle c = (Circle) oc;
		Date d = (Date) od;
		int [] a = (int [])oia;
		MutableFraction mf = (MutableFraction) of;

		System.out.println(s.toUpperCase());
		System.out.println(c.getArea());
		System.out.println(d.toLongDateStringEN());
		ArrayUtil.print(a);
		System.out.println(mf.getRealValue());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Object dizisinin elemanları olan referansların dinamik türleri çalışma zamnında tespit edilerek
	downcasting yapılmıştır. Dinamik tür bilgisi tespiti için tür ismi kullanılmıştır. Programcının tür ismini yanlış
	yazma olsılığı vardır. Ayrıca yazı karşılaştırması uygulamayı göreceli yavaşlatabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.randomgenerator.RandomObjectArrayGeneratorApp;

class App {
	public static void main(String [] args)
	{
		RandomObjectArrayGeneratorApp.run();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	instanceof operatörü iki operandlı (binary), araek (infix) ve özel amaçlı (special purpose) bir operatördür. Operatörün
	birinci operandı bir referans olmalıdır. İkinci operandı ise bir referans tür ismi olmalıdır. Operatörün ürettiği
	değer boolean türdendir. Operatör birinci operandı olan referansın dinamik türü, ikinci operandı olanb türü kapsıyorsa
	true, kapsamıyorsa false değerini üretir. Operatör özellikle "downcasting" işleminin güvenli yapılması (haklı dönüşüm)
	için kullanılır

	Aşağıdaki örnekte instanceof operatörü kullanılarak hem okunabilirlik/algılanabilirlik artırılmış, ham hata yapma
	olasılığı ortadan kaldırılmış hem de karşılaştırma işlemi data etkin hale getirilmiştir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.randomgenerator.RandomObjectArrayGeneratorApp;

class App {
	public static void main(String [] args)
	{
		RandomObjectArrayGeneratorApp.run();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 16 ile birlikte eklenen "Pattern matching" kurallarında instanceof için olanı ile dowcasting işlemi programcı
	tarafından	değil derleyici tarafından üretilen kod ile yapılabilmektedir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.randomgenerator.RandomObjectArrayGeneratorApp;

class App {
	public static void main(String [] args)
	{
		RandomObjectArrayGeneratorApp.run();
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	instanceof operatörü birinci operandına ilişkin referansın dinamik türünün ikinci operandına ilişkin türü kapsayıp
	kapsamadığına bakar. Buradaki kapsama şüphesiz nesnesel kapsamadır. Aşağıdaki programı çalıştırıp durumu gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.randomgenerator.RandomObjectArrayGeneratorApp;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		SampleFactory factory = new SampleFactory();

		A a;

		System.out.print("Bir sayi giriniz:");
		int count = kb.nextInt();

		while (count-- > 0){
			System.out.println("-------------------------------------------");
			a = factory.getRandomA();
			System.out.println(a.getClass().getName());
			if(a instanceof B b)
				b.foo();
			else System.out.println("B veya B den türemiş bir tür değildir");
			System.out.println("---------------------------------------------");
		}
	}
}

class SampleFactory{
	private final Random m_random = new Random();

	public A getRandomA()
	{
		int val = m_random.nextInt(5);

		return switch (val){
			case 0 -> new B();
			case 1 -> new C();
			case 2 -> new D();
			case 3 -> new E();
			default -> new F();
		};
	}

}

class F extends E{

}


class E extends A{

}

class D extends B{

}

class C extends B{

}

class B extends A{
	public void foo()
	{
		System.out.println("B.foo");
	}
}
class A{

}

/*----------------------------------------------------------------------------------------------------------------------
	Sarmalayan Sınıflar (Wrapper Classes): Java'da her temel türe karşılık gelen bir sınıf vardır. Bu sınıflara
	sarmalayan sınıflar denir. Böyle bir tasarımın nedeni sınıfları tanıdıkça anlaşılacaktır. Bu sınıflar sarmalamanın
	dışında ilgili temel türe ilişkin bazı yararlı işlemlerin de yapılmasına yönelik metotlar. Örneğin Integer sarmalayan
	sınıfının parseInt metodu bir yazıyı int türden bir değere çevirmek için kullanılır. Temel türlere ilişkin
	sarmalayan sınıflar şunlardır:

	Temel Tür							Sarmalayan Sınıf
	----------------------------------------------------
	short									Short
	int										Integer
	long									Long
	byte									Byte
	double									Double
	float									Float
	char									Character
	boolean									Boolean

	Bu sınıflardan tanmsayı ve gerçek sayı türlerine ilişkin olanlarına (Short, Integer, Long, Byte, Double ve Float)
	numerik sarmalayan sınıflar da denebilir.

	Sarmalayan sınıfların temel özellikleri:
	- Sarmalayan sınıfların hepsi java.lang paraketi içerisinde bildirilmiştir

	- Tamsayı ve gerçek sayı türlerine ilişkin sınıflar java.lang paketinde bulunan Number sınıfından türetilmiştir. Number
	sınıfının birçok yararlı metodu vardır. Bu metotlar ileride ele alınacaktır.

	- Sarmalayan sınıfların hepsi "immutable"'dır.

	- Bu sınıflar temel türden değerlerin heap'de tutulması için kullanılır. Bu kavrama "kutulama (boxing)" denir. Bu
	konu ileride ele alınacaktır.

	- Java 9 ile birlikte sarmalayan sınıfların ctor'ları "deprecated" olmuştur. Zaten Java 5'den itibaren bu ctor'ların
	kullanılması iyi bir teknbik değildi, artık deprecated olduğu için hiç kullanılmamalıdır. Bunun ileride anlaşılacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı, gerçek sayı ve char türüne ilişkin sarmalayan sınıfların MIN_VALUE ve MAX_VALUE isimli final ve static veri
	elemanları vardır. Bu elemanlar ilişkin oldukları temel türdendir. Double ve Float sınıflarının MIN_VALUE değerlerinin
	pozitif olduğuan dikkat ediniz. Bu durum IEEE 754 formatına ilişkindir. double ve float türleri için sınır değerlerin
	"-+" biçiminde olduğunu anımsayınız
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;


class App {
	public static void main(String [] args)
	{
        System.out.printf("byte:[%d, %d]%n", Byte.MIN_VALUE, Byte.MAX_VALUE);
        System.out.printf("short:[%d, %d]%n", Short.MIN_VALUE, Short.MAX_VALUE);
        System.out.printf("int:[%d, %d]%n", Integer.MIN_VALUE, Integer.MAX_VALUE);
        System.out.printf("long:[%d, %d]%n", Long.MIN_VALUE, Long.MAX_VALUE);
        System.out.println("double:[-+" +  Double.MIN_VALUE + ", -+" + Double.MAX_VALUE + "]");
        System.out.println("float:[-+" +  Float.MIN_VALUE + ", -+" + Float.MAX_VALUE + "]");
        System.out.printf("char:[%d, %d]%n", (int)Character.MIN_VALUE, (int)Character.MAX_VALUE);

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
15.06.2023 Salı - 42.Ders

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı, gerçek sayı ve char türüne ilişkin sarmalayan sınıfların SIZE ve BYTES isimli final static veri elemanları
	vardır. Bu elemanlar ilişkin oldukları türlerin sırasıyla bit ve byte uzunluklarını tutarlar. Bu elemanlar okunanbilirliği
	artırmak için ilgili türün uzunluğu gerektiğinde kullanılabilirler. Java'da temel türlerin uzunluk bilgileri her zaman
	aynıdır. Sistemden sisteme değişmez. Bu sebeple tür uzunluklarının sayısal değeri de kullanılabilir. Anımsanacağı
	gibi Java'da boolean türünün uzunluğu belirtilmemiştir. Bu sebeple Boolean sınıfının SIZE ve BYTES elemanları
	yoktur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
        System.out.printf("byte:%d, %d  byte/bit/bits%n", Byte.BYTES, Byte.SIZE);
        System.out.printf("short:%d, %d  byte/bit/bits%n", Short.BYTES, Short.SIZE);
        System.out.printf("int:%d, %d  byte/bit/bits%n", Integer.BYTES, Integer.SIZE);
        System.out.printf("long:%d, %d  byte/bit/bits%n", Long.BYTES, Long.SIZE);
        System.out.printf("double:%d, %d  byte/bit/bits%n", Double.BYTES, Double.SIZE);
        System.out.printf("float:%d, %d  byte/bit/bits%n", Float.BYTES, Float.SIZE);
        System.out.printf("char:%d, %d  byte/bit/bits%n", Character.BYTES, Character.SIZE);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bilindiği gibi nümerik sarmalayan sınıfların parseXXX metotları ile bir yazı ilgili türe dönüştürülebilir. Character
	sınıfı dışındaki tüm sarmalayan sınıfların parseXXX metotları vardır. Boolean sınıf dışındaki sarmalayan sınıfların
	parseXXX metotları yazıyı ilgili türe çeviremezlerse exception oluşur. Boolean sınıfının parseBoolean metodu çeviremedeği
	bir yazı için false değerini döndürür. Yani kısaca parseBoolean metpdu büyük-küçük harf duyarsız (case insesitive)
	bir biçimde yazının true olması durumunda true değerine, diğer tüm yazılar için false değerine geri döner
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        Scanner kb = new Scanner(System.in);

        for (;;){
            System.out.print("true veya false giriniz:");
            boolean flag = Boolean.parseBoolean(kb.nextLine());

            System.out.printf("Flag = %b%n", flag);
        }
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı türlerine ilişkin sarmalayan sınıfların "sayı sistemi (radix)" parametreli parseXXX metotları da vardır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        Scanner kb = new Scanner(System.in);

        for (;;){
            System.out.print("Tabani giriniz:");
            int radix = Integer.parseInt(kb.nextLine());

            if(radix <= 0)
                break;

            System.out.print("Bir sayi giriniz:");
            String str = kb.nextLine();

            int a = Integer.parseInt(str, radix);

            System.out.printf("a = %d%n", a);
        }
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sarmalayan sınıflarınn ctor'ları Java 9 ile birlikte deprecated olmuştur. Yani kutulama (boxing) bu ctor'lar ile
	yapılmamalıdır. Zaten Java 5'den itibaren hiç bir programcı bunları kullanmamaktadır. Bu anlamda bunların deprecated
	olması için geç bile kalınmıştır. Bu anlamda Java 11 ile birlikte bu ctor'ların artık olmayacağı söylenmiştir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        Integer i = new Integer();
        Double d = new Double();

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Kutulama için sarmalayan sınıfların valueOf metotları kullanılır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        Integer i = Integer.valueOf(10);
        Double d = Double.valueOf("4.5");

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı türlerine ilişkin sarmalayan sınıfların ilişkin oldukları temel türden parametreli valueOf metotları [-128, 127]
	aralığındaki değerleri bir ön bellekten (cache) alır. Böylece daha efektif bir çalışma sağlanır (significantly better space and time performance).
	Bu aralık dışındaki değerlerin bir ön bellekte tutulacağı garanti değildir (implementation defined/dependent).
	Not: IntValue sınıfının kodlarını tekrar inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        Integer i1 = Integer.valueOf(10);
        Integer i2 = Integer.valueOf(10);
        Integer i3 = Integer.valueOf(1000);
        Integer i4 = Integer.valueOf(1000);

        System.out.println(i1 == i2 ? "Aynı nesne" : "Farklı Nesneler");
        System.out.println(i3 == i4 ? "Aynı nesne" : "Farklı Nesneler");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Character sınıfının valueOf metodu ['\u0000', '\u007F'] aralığındaki karakterlere ilişkin sıra numaralarını bir ön bellekten
	alır. Bu karakterler aslında standart ASCII karakterlerdir. Bunlar dışındaki karakterler için ön bellek kullanımı
	garanti değildir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        Character c1 = Character.valueOf('A');
        Character c2 = Character.valueOf('A');
        Character c3 = Character.valueOf('Ħ');
        Character c4 = Character.valueOf('Ħ');

        System.out.println(c1 == c2 ? "Aynı nesne" : "Farklı Nesneler");
        System.out.println(c3 == c4 ? "Aynı nesne" : "Farklı Nesneler");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Boolean sınıfının valueOf metodu true ve false değerlerine ilişkin Boolean nesnelerini bir ön bellekten alır.
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        Boolean b1 = Boolean.valueOf(true);
        Boolean b2 = Boolean.valueOf(true);
        Boolean b3 = Boolean.valueOf(false);
        Boolean b4 = Boolean.valueOf(false);

        System.out.println(b1 == b2 ? "Aynı nesne" : "Farklı Nesneler");
        System.out.println(b3 == b4 ? "Aynı nesne" : "Farklı Nesneler");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Yöntemi ne olursa olsun tüm sarmalayan sınıflar ve ilişkin oldukları tür parametreli valueOf metotları kullanılarak
    referans elde edilmesi "significantly better space and time performance" açısından önemlidir. Bu sebeple Java 5'den
    itibaren ctor kullanımı tavsiye edilmemektedir ve hiç bir programcı da bunu kullanmamaktadır
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Number sınıfının xxxValue metotları nümerik sarmalayan sınıflar için (platform classes) ilişkin olduğu temel türe
	göre tür dönüştürmöe kurallarına uygun olarak çalışırlar. Yani örneğin int türden bir değerin short türüne explicit
	dönüştürülmesi durumunda elde edilen değer ile Integer sınıfı sarmalanmış nesneye ilişkin shortValue metodunun
	döndürdüğü değer aynıdır
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayi giriniz:");
        int val = Integer.parseInt(kb.nextLine());
        Integer iVal = Integer.valueOf(val);

        short a = (short)val;
        short b = iVal.shortValue();

        System.out.printf("a = %d%n", a);
        System.out.printf("b = %d%n", b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Sarmalayan sınıflar ile temel türden bir değer de mantıksal olarak Object referansı ile tutulabilir. Bu işlem için
	kutulama yapılır. Aynı şekilde kutu açarak da değer elde edilebilir. Yani genel amaç temel türden değerlerin "heap"'de
	tutulmasıdır
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        Object object = Integer.valueOf(10); //Kutulma (boxing)
        System.out.println(object.getClass());

        int a = ((Integer)object).intValue(); //Kutuyu açma (boxing)

        System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------
    RandomObjectArrayGeneratorApp Uygulaması
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.randomgenerator.RandomObjectArrayGeneratorApp;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
        RandomObjectArrayGeneratorApp.run();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Java 5 ile birlikte temel türlere ilişkin sarmalayan sınıf referanslarına ilgili türden bir değer doğrudan atanabilir.
	Bu işlem aslında derleyici tarafından aşağıdaki gibi kodların üretilmesini sağlar. Yani programcı bu atamayı
	yaptığında derleyici uygun kodu üretir. Bu kavrama "otomatik kutulama (autoboxing)" denir.
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.randomgenerator.RandomObjectArrayGeneratorApp;


class App {
	public static void main(String [] args)
	{
		Integer iVal = 10; //auto boxing : Integer.valueOf(10);
		Double dVal = 2.3; //auto boxing : Double.valueOf(2.3);
		Boolean bVal = true; //auto boxing : Boolean.valueOf(true);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Otomatik kutulama Object sınıfı için de geçerlidir
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Object oi = 10; //auto boxing : Integer.valueOf(10);
		Object od = 2.3; //auto boxing : Double.valueOf(2.3);
		Object ob = true; //auto boxing : Boolean.valueOf(true);

		System.out.println(oi.getClass().getName());
		System.out.println(od.getClass().getName());
		System.out.println(ob.getClass().getName());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki metot çağrılarında temel türden argümanlar için kutulama, referans türden argümanlar için upcasting
    	yapılmıştır
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.math.MutableFraction;

class App {
	public static void main(String [] args)
	{
		Util.printDynamicType(10); //autoboxing
		Util.printDynamicType(true);//autoboxing
		Util.printDynamicType("ankara");//upcasting
		Util.printDynamicType(new MutableFraction(2, 3)); //upcasting
	}
}

class Util{
	public  static void printDynamicType(Object o)
	{
		System.out.println(o.getClass().getName());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Otomatik kutulama kuralları gereği kendi sarmalayan sınıf referansına veya Object türden referansa yapılabilir. Aksi
	durumda error oluşur
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Double dVal = 10; //error Integer.valueOf(10);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte otomatik kutu açma yapılmıştır
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int val = 10;
		Integer iVal = val; //auto boxing : Integer.valueOf(val)

		int a = iVal; //auto unboxing: ival.intValue();

		System.out.printf("a = %d%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Otomatik kutu açma tür dönüştürme operatörü kullanılarak aşağıdaki gibi Object türündentemel türe yapılabilir. Yine
	derleyici bu durumda aşağıdakine benzer kodlar üretir
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Object oi = 10; //auto boxing : Integer.valueOf(10);
		Object od = 2.3; //auto boxing : Double.valueOf(2.3);
		Object ob = true; //auto boxing : Boolean.valueOf(true);

		System.out.println(oi.getClass().getName());
		System.out.println(od.getClass().getName());
		System.out.println(ob.getClass().getName());


		System.out.println("-------------------------------");
		//int a = ((Integer)oi).intValue();
		int a = (int)oi; //auto unboxing: ((Integer)oi).intValue();
		double b = (double)od; //auto unboxing: ((Double)oi).doubleValue();
		boolean c = (boolean)ob; //auto unboxing: ((Boolean)oi).booleanValue();

		System.out.printf("a = %d%n", a);
		System.out.printf("b = %f%n", b);
		System.out.printf("c = %b%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Otomatik kutu açma uygun türe yapılmalıdır. Aşağıdaki örnekte haksız dönüşümden dolayı exception oluşur
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Object oi = 10; //auto boxing : Integer.valueOf(10);
		System.out.println(oi.getClass().getName());

		double a = (double) oi; //auto unboxing: ((Double)oi).doubleValue();
		System.out.printf("a = %f%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problem aşağıdaki gibi çözülebilir
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Object oi = 10; //auto boxing : Integer.valueOf(10);
		System.out.println(oi.getClass().getName());

		double a = (int) oi; //auto unboxing: ((Integer)oi).intValue();
		System.out.printf("a = %f%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte int türüne otomatik kutu açılmış, elde edilen değer short türüne dönüştürülmüştür (cast). Tür
	dönüştürme operatörünün "sağdan sola öncelikli (right associative)" olduğunu anımsayınız
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Object oi = 10; //auto boxing : Integer.valueOf(10);
		System.out.println(oi.getClass().getName());

		short a = (short) (int)oi; //auto unboxing: ((Integer)oi).intValue();
		System.out.printf("a = %d%n", a);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
    RandomObjectArrayGeneratorApp uygulamasında sanki programcı her tür Object'ten türetilmiş gibi kod yazmıştır.
	Şüphesiz temel türler Object'ten türetilmemiştir. Otomatik kutulama ve otomatik kutu açma sayesinde temel türler
	için de aynı mantık kullanılabilmiştir
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.randomgenerator.RandomObjectArrayGeneratorApp;

class App {
	public static void main(String [] args)
	{
		RandomObjectArrayGeneratorApp.run();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Sarmalayan sınıflar ile sanki ilişkin oldukları türlermiş gibi kod yazılabilmektedir. Aslında bu işlemler otomatik
	kutulama ve otomatik kutu açma ile yapılmaktadır. Örnek durumu göstermek için yazılmıştır
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		for (Integer i = 0; i < 10 ; i++) {
			System.out.printf("%d", i);
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte sarmalayan sınıfların immutable olduğu da gösterilmektedir
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Integer iVal = 10;
		Integer temp = iVal;

		System.out.println(iVal == temp ? "Aynı nesne" : "Farklı nesneler");

		++iVal;//iVal = Integer.valueOf(iVal.intValue() + 1)

		System.out.println(iVal == temp ? "Aynı nesne" : "Farklı nesneler");

	}
}


/*----------------------------------------------------------------------------------------------------------------------
    final olarak bildirimiş bir sınıftan türetme yapılamaz
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class B extends A{

}

final class A {

}

/*----------------------------------------------------------------------------------------------------------------------
    final bir sınıf başka bir sınıftan türetilmiş olabilir. Zaten bir sınıf bildiriminde extends ile başka bir sınıf
	yazılmasa da Object sınıfından türetilmiş olur
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class C extends B{

}
final class B extends A{

}

class A {

}

-----------------------------------------------------------
-----------------------------------------------------------
20.06.2023 Salı - 43.Ders


/*----------------------------------------------------------------------------------------------------------------------
    Aşağı seviyede heap'de tahsis edilen nesnelere "dinamik ömürlü" nesneler denir. Bu nesnelerin yok edilmesi Java'da
	"çöp toplayıcı (garbage collector)" denilen ve arka planda çalışan bir akış tarafından yapılır. Çöp toplayıcı
	"artık kullanılmayan (garbage collected, eligible)" yani çöp diyebileceğimiz nesneleri yok eder. Burada 3 tane temel
	soru sorulabilir:
	1. Programcı bir nesneyi yok edebilir mi?
	2. Çöp olan yani artık kullanılmayan bir nesne çöp olur olmaz yok edilir mi?
	3. Çöp toplayıcı yok edilmesi gereken bir nesneyi nasıl anlar?

Cevap 1: Java'da programcı bir nesneyi yok edemez. Yani tahsis edilmiş bir alanı geri bırakamaz (free/delete). Programcı
	kod kışı içerisinde nesneyi "garbage collected" duruma getirebilir.

Cevap 2: Çöp toplayıcının ne zaman devreye gireceği standartlarda belirtilmemiştir. Bu çöp toplayıcı ile birlikte,
	JVM ve JRE yazanlara bırakılmıştır (implementation defined/dependent). Hemen devreye gireceği garanti değildir. Programcı
	bu bilinçle ve çöp toplayıcının etkinliğine güvenerek kod yazar.

Cevap 3: Bir nesnenin yok edilebilir yani çöp duruma gelmesi o nesneyi gösteren hiçbir referansın kalmaması demektir.
	Yani nesnenin adresinin hiçbir referans tarafından gösterilmiyor duruma gelmesidir. Bir nesnenin adresinin hangi
	referanslar	tarafından tutulduğu ve özellikle kaç tane referans tarafından tutulduğunun takibi için çeşitli algoritmalar
	kullanılmaktadır. Bu algoritmanın ne ve nasıl olacağı  da yazanlara bırakılmıştır. Biz burada "referans sayma (reference counting)"
	algoritması kullanılıyor varsayımıyla açıklama yapacağız. Referans sayma yönteminde her yaratılan nesne için bir
	referans sayacı tutulur. Bu sayaç genelde nesnenin içerisinde tutulur. Bu yöntemde nesnenin adfresi yeni bir referansa
	atandığında sayaç 1(bir) artırılır. Nesne bir referanstan kopartıldığında sayaç 1(bir) azaltılır. Sayacı sıfır olan
	yani hiçbir referans tarafından gösterilmeyen bir nesne artık "garbage collected" duruma gelmiş olur. Bir program
	sonlandığında tüm nesneler yok edilir

---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample(); //rc1:1

		{
			Sample k;

			k = s; //rc1:2

			Mample.foo(k); //rc1:3 --> rc1:4
		}//rc1:1

		s = new Sample(); //rc1:0 (garbage collected), rc2:1
		//..
		//..
	}
}


class Mample{
	public static void foo(Sample s)
	{
		Sample k;

		k = s;
	}
}

class Sample{

}

/*----------------------------------------------------------------------------------------------------------------------
    Programcı isterse çöp toplayıcının o an devreye girmesini sağlayabilir. Bunun için System sınıfının gc isimli static
	metodu veya Runtime sınıfının non-static gc metodu çağrılabilir. Ancak bu çoğunlukla hatta neredeyse hiçbir zaman
	yapılmaması gereken bir yaklaşımdır. Programcı çöp toplayıcının devreye girmesi konusunda etkin çalışmasına
	güvenmelidir. Çünkü çöp toplayıcının gereksiz yere arkaplanda çaşlıştırılması da programın performansını göreceli
	olarak olumsuz yönde etkileyecektir
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s;

		s = new Sample(); //rc1:1

		{
			Sample k;

			k = s; //rc1:2

			Mample.foo(k); //rc1:3 --> rc1:4
		}//rc1:1

		s = new Sample(); //rc1:0 (garbage collected), rc2:1
		System.gc(); //Runtime.getRuntime().gc();
		//..
		//..
	}
}


class Mample{
	public static void foo(Sample s)
	{
		Sample k;

		k = s;
	}
}

class Sample{

}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağı seviyede non-static metot kavramıo yoktur. Bundan dolayı derleyici non-static metotları byte code'a adeta
	static metot biçiminde yazar. Metodun non-stic olduğu bilgisi arakodda vardır. Non-static bir metodu arakoda yazarken
	metoda ilgili sınıf türünden +1 tane referans parametresi ekler. non-static bir metodun çağrısı da o metot çağrılırken
	kullanılan referansın, metodun arakoddaki karşılığı olan static metoda argüman olaraak geçirilmesiyle yapılır
	Aşağıdaki örnekte non-static bir metodun bildirimi ve çağrılmasının yaklaşık karşılıklarık gösterilmiştir. ctor'lar da
	arakoda metot olarak yazılır (init).
	Yani başka mbir bakış açısıyla non-static metotlara aşağı seviyede gizlice adres geçirilmiş olur
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();

		s.setA(20);

		//Yukarıdaki setA cagrısını arakoddaki yaklasık karsılıgı
		Sample.setA(s, 20);

		s.print();

		//Yukarıdaki print cagrısını arakoddaki yaklasık karsılıgı
		Sample.print(s);
	}
}


class Sample{
	private int m_a;

	public void setA(int a)
	{
		m_a = a;
	}

	//setA metodunu arakoddaki yaklaşık karşıklığı
	public static void setA(Sample s, int a)
	{
		s.m_a = a;
	}


	public void print()
	{
		System.out.printf("m_a = %d%n", m_a);
	}

	//print metodunun arakoddaki yaklasık karsılıgı
	public static void print(final Sample s)
	{
		System.out.printf("m_a = %d%n", s.m_a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    non-static metotlara gizlice geçirilen adrese (referansaI metot bildiriminde "this referansı" ile erişilebilir. this
	referansı o metodu çağıran referansa yani arakoddaki static metodun parametresine karşılık gelir. Bu durumda metot
	çağrılırken this referansı nesnenin adresi olur. this referansının türü, hangi sınıfın non-static metot bildirimi
	içerisinde kullanılmışsa o sınıf türündendir. Bu kavram "non-static bir metoda this geçirilir" şeklinde de söylenir.
	ctor'lara da this geçirilir
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();

		s.setA(20);
		s.print();

	}
}


class Sample{
	private int m_a;

	public void setA(int a)
	{
		this.m_a = a;
	}

	public void print()
	{
		System.out.printf("m_a = %d%n", this.m_a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    this referansı bir sabittir. Yani this referansına atama yapılamaz
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();

		s.setA(20);
		s.print();

	}
}


class Sample{
	private int m_a;

	public void setA(int a)
	{
		this = new Sample(); //error
		this.m_a = a;
	}

	public void print()
	{
		System.out.printf("m_a = %d%n", this.m_a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    static metotlara this geçirilmez. Dolayısıyla this referansının static metotlar içinde kullanımı geçersizdir+
---------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();

		s.setA(20);

	}
}


class Sample{
	private int m_a;

	public static void setA(int a)
	{
		this.m_a = a; //error
	}


}

/*----------------------------------------------------------------------------------------------------------------------
	Programcı this referansını ne zaman kullanacaktır? Aslında bunun cevabı programcıya göre değişebilir. Biz genel olarak
	this referansını gerekmedikçe kullanmayacağız. Ancak bazı programcılar sınıfın bir non-static metodu içerisinde
	non-static başka bir metodu çağırıdıklarında, static metotları ayırt etmek açısından yaniş okunabilirlik açısından
	this referansını kullanırlar
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki Vector2 sınıfında veri elamanlarının isimleri cgtor'un parametrelerinin isimleri aynı olduğundan atama
	durumunda this referansı zorunludur. Bazı programcılar sınıfın veri elemanı private bile olsa isimlendirmede bir ek
	kullanmazlar. Bu durumda veri elemanları aynı isimde prametrelere sahip tüm metotlarda this referansı kullanmaları
	gerekir. Bu iyi ya da kötü teknik biçiminde anlaşılmamalıdır. Sonuçta bu da bir convention'dır.
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class Vector2{
	public double x, y;

	public Vector2(int x, int y)
	{
		this.x = x;
		this.y = y;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıfın metotlarının aynı referans üzerinden zincir biçiminde aşağıdaki gibi çağrılabilmesi için implementasyonda
	ilgili metotların this referansına geri dönmesi gerekir (fluent). Şüphesiz bu tarz yazılıp yazılmayacağı yine sınıfın
	ne olduğuna bağlıdır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.wrapper.MutableIntValue;

class App {
	public static void main(String [] args)
	{
		MutableIntValue intValue = new MutableIntValue();

		int val = intValue.setValue(20).multiply(2).add(4).divide(1).subtract(5).getValue();

		System.out.printf("val = %d%n", val);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi programlamada kullanılmayan bir byte'lık adresi temsil eden "null adres" denilen bir adres vardır.
	Yani bu adres herhangi bir değişken ya da bir nesne için tahsis edilmez. null adres modern sistemlerin hemen hemen
	hepsinde belleğin ilk gözüdür, yani sıfır numaralı adrestir. Ancak sıfır numaralı adres olmak zorunda değildir. Kullanılmayan
	bir adres olmalıdır. Java'da null adres null isimli sabit ile temsil edilir. Bu sabite "null reference" denir. Bir
	referansa null atandığında o referansın içerisinde bir adres vardır ancak adres kullanılmadığı için herhangi bir nesnenin
	adresi olmaz. null referans temel türden değişkenlere atanamaz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		int a = null; //error
		Sample s;
		String str;
		Color c;
		int[] b;

		s = null;
		str = null;
		c = null;
		b = null;
	}
}

enum Color{RED, GREEN, BLUE}
class Sample{

}

/*----------------------------------------------------------------------------------------------------------------------
	Bir referansın default değeri null'dır. Singleton kalıbının "lazy" implementasyonunu anımsayınız
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();

		System.out.println(s1 == s2 ? "Aynı nesne" : "Farklı nesne");
	}
}

class Singleton{
	private static Singleton ms_instance;

	private int m_value;

	private Singleton(){}

	public static Singleton getInstance()
	{
		if(ms_instance == null)
			ms_instance = new Singleton();

		return ms_instance;
	}

	public int getValue()
	{
		return m_value;
	}

	public void setValue(int value)
	{
		m_value = value;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir referansın null olması durumunda o referansın ilişkin olduğu türün elemanlarına erişim durumunda execption
	oluşur. Aşağıdaki kod durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s = null;

		s.foo();
	}
}

class Sample{
	public void foo()
	{

	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte yorum satırı içerisinde yazılan döngü yazılmadığından ya da daha genel söyleyişle Engine
	türden dizinin her bir elemanı olan referansın null olması ve o referanslara uygun nesnelerin adreslerinin verilmemesi
	dolayısıyla exception oluşur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Driver driver;
		driver = new Driver();

		driver.setUsername("AMehmet");
		driver.setName("Ali Mehmet Cetinkol");
		driver.setRating(100);

		Car car = new Car(driver);

		car.run();

		System.out.println("**************************************");

		Pilot[] pilots = {new Pilot(1, "Ali Cetinkol", 10000), new Pilot(2, "Orhan ozturk",
				7000), new Pilot(3, "Mahmut Tuncer", 5000)};
		Plane p = new Plane(4, pilots);

		p.fly();
	}
}

class  Plane{
	private Engine[] m_engines;
	private Pilot[] m_pilots;

	private void startEngines()
	{
		for (Engine engine : m_engines) {
			engine.startEngine();
		}
	}
	private void accelerateEngines()
	{
		for (Engine engine : m_engines) {
			engine.acclerateEngine();
		}
	}
	private void slowEngines()
	{
		for (Engine engine : m_engines) {
			engine.slowEngine();
		}
	}
	private void stopEngines()
	{
		for (Engine engine : m_engines) {
			engine.stopEngine();
		}
	}

	public Plane(int engineCount, Pilot [] pilots)
	{
		m_pilots = pilots;
		m_engines = new Engine[engineCount];

		/*
		for (int i = 0; i < engineCount; ++i)
			m_engines[i] = new Engine();
		 */
	}

	public void fly()
	{
		System.out.println("Pilots:");
		for (Pilot p: m_pilots) {
			System.out.printf("%d. %s, %d%n", p.getTitle(), p.getName(), p.getFlightDuration());
		}

		startEngines();
		accelerateEngines();
		//..

		System.out.println("Flying...");
		//..

		slowEngines();

		//..
		stopEngines();

	}
}

class Pilot{
	private int m_title;
	private String m_name;
	private int m_flightDuration;

	public Pilot(int title, String name, int flightDuration)
	{
		m_title = title;
		m_name = name;
		m_flightDuration = flightDuration;
	}

	public int getTitle() {
		return m_title;
	}

	public void setTitle(int m_title) {
		this.m_title = m_title;
	}

	public String getName() {
		return m_name;
	}

	public void setName(String m_name) {
		this.m_name = m_name;
	}

	public int getFlightDuration() {
		return m_flightDuration;
	}

	public void setFlightDuration(int m_flightDuration) {
		this.m_flightDuration = m_flightDuration;
	}
}

class Car{
	private Engine m_engine;
	private Driver m_driver;

	public Car(Driver driver)
	{
		m_driver = driver;
		m_engine = new Engine();
	}

	public void brake()
	{
		System.out.println("brake");
		m_engine.slowEngine();
	}

	public void run()
	{
		System.out.printf("Driver : %s, %d%n", m_driver.getName(), m_driver.getRating());

		m_engine.startEngine();
		m_engine.acclerateEngine();

		System.out.println("running...");

		brake();
		m_engine.stopEngine();
	}
}

class Driver{
	private String m_username;
	private String m_name;
	private int m_rating;

	public String getUsername() {
		return m_username;
	}

	public void setUsername(String m_username) {
		this.m_username = m_username;
	}

	public String getName() {
		return m_name;
	}

	public void setName(String m_name) {
		this.m_name = m_name;
	}

	public int getRating() {
		return m_rating;
	}

	public void setRating(int m_rating) {
		this.m_rating = m_rating;
	}
}

class Engine{
	//...
	public void startEngine()
	{
		System.out.println("Start Engine");
	}

	public void acclerateEngine()
	{
		System.out.println("Accelerate Engine");
	}

	public void slowEngine()
	{
		System.out.println("Slow Engine");
	}
	public void stopEngine()
	{
		System.out.println("Stop Engine");
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	null referans bir referans değişkeni nesneden kopartmak için kullanılabilir. Bir referansa null atanması o referansın
	gösterdiği nesnenin "garbage collected" olduğu anlamına gelmez. Aşağıdaki örnekte ** ile belirtilen atama ile
	s1 referansının gösterdiği nesne "garbage collected" olmaz. Çünkü halen daha o nesneyi s2 referansı gösterrmektedir. Yani
	o nesneyi gösteren referans sayısı sıfır olmamıştır. Ancak ** ile belirtilen atama ile artık nesneyi gösteren hiç bir
	referans kalmamıştır, nesne "garbage collected" duruma gelmiştir. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s1, s2;

		s1 = new Sample();
		s1.x = 10;
		System.out.printf("s1.x = %d%n", s1.x);

		s2 = s1;

		s1 = null; //**
		System.out.printf("s2.x = %d%n", s2.x);
		s2 = null; //**
		//**
	}
}

class Sample{
	public int x;
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte miv referansına null atanması derleyicinin "değer verilmeme ihtimali olan bir değişkeni kullanıyorsun"
	şeklindeki hata durumunu engellemöek için kullanılmıştır. Derleyic programcının aşağıdaki algoritması anlayıp akışın
	hiç bir switch deyiminden yakalanmadan çıkacağını anla(ya)maz. Üstelik anlamak zorunda da değildir. Hatta aşağıdaki
	kod anlaması mümkün olmayacak şekilde de yazılabilir. Örneğin if deyimi ve yaptıkları bir metot içerisinde yazılıp burada
	çağrılabilir. Bu durumda derleyici bunu anlayamaz. Şüphesiz aşağıdaki örnek farklı şekillerde de ytazılabilir. null
	kullanımı göstermek için bu şekilde yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.wrapper.MutableIntValue;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());

		if(a < 1 || a > 3){
			System.out.println("Geçersiz bir deger girdiniz!....");
			System.exit(1);
		}

		MutableIntValue miv = null;

		switch (a){
			case 1 -> miv = new MutableIntValue(-128);
			case 2 -> miv = new MutableIntValue(0);
			case 3 -> miv = new MutableIntValue(127);
		}

		System.out.printf("Value = %d%n", miv.getValue());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    30.07.2024
    Algoritma bir problemi çözümüne ulaştıran doğru adımlara denir.
    Algoritmaların anlatımında belli bir formal yöntem yoktur. Genel olarak sahte kodlar (pseudo codes) kullanılarak
    algoritmalar açıklanır. Algoritmalar genel olarak dilden bağımsızdır. Ancak ince noktalara gelindiğinde algoritmalar da
    dile bağımlı hale gelebilir. Örneğin, bir dilde belli bir işi daha kolay yapan deyimler olabilir. Bu durumda algoritma
    o deyimlerle gerçekleştirilebilir.

    Bir algoritmanın işleyişinin masaya yatırılıp incelenmesine "algoritma analizi (analysis of algorithm)" denir. Bu
    analiz genel olarak matematiksel yöntemlerle yapılır. İki algoritmanın karşılaştırılabilmesi için kullanılan ölçüye
    "algoritmanın karmaşıklığı (complexity of algorithm)" denir. Algoritmanın karmaşıklığı için iki temel ölçüt vardır:
    Hız (speed), kaynak kullanımı (resource usage).
    Burada baskın ölçüt hızdır. Yani daha çok algoritmalar hızlarına göre karşılaştırılır. Ancak bazı durumlarda (bu durumlar
    hıza göre az olsa da kritik durumlardır) kaynak kullanımı da gözönüne alınabilir. Şüphesiz iki ölçütün de en iyi olduğu
    durum her zaman mümkün olmaz.

    Örneğin aşağıdaki gibi yazılmış en büyük sayıyı bulma algoritması için:
    int [] a = {...};
    int max;
    int n;

    n = a.length;
    max = a[0];
    for (int i = 1; i < n; ++i)
        if (max < a[i])
            max = a[i];

    Burada toplam işlemin sayısı max = a[i] işlemine bağlıdır. Bu algoritmada dizinin elemanları bilinmeden bu anlaşılamaz.
    İşte algoritma analizinde işlemlerin sayısını hesaplarken üç durum dikkate alınabilmektedir:

    - Ortalama durum (average case condition)
    - En kötü durum (worst case condition)
    - En iyi durum (best case condition)

    En kötü durum olabileceklerin en kötüsüdür. Yukarıdaki örnekte en kötü durumda max = a[i] işlemi "n - 1" kez yapılır.
    Ortalama durum tüm olasılıkların ortalamasını temsil eder. Yukarıdaki örnekte ortalama max = a[i] işlemi "(n - 1) / 2"
    kez yapılmaktadır. En iyi durum olabileceklerin en iyisini temsil eder. Yani max = a[i] işlemi hiç yapılmaz.
    Algoritma analizinde en iyi durumun çok yararı yoktur. Çünkü aşırı iyimserlik programlamada çok değerli değildir.
    En kötü durum senaryosu önemlidir. Çünkü bazı durumlarda en kötü duruma hazırlıklı olmak gerekebilir. En önemli durum
    ortalama durumdur. Ortalama durum algoritmanın karakterini en iyi belirten durumdur. Genellikle algoritma ele alınırken
    hem ortalama durum hem de en kütü durum analizi yapılır.

    Algoritmalarda işlem sayısına ilişkin analizler çok kolay değildir. Özellikle ortalama durumu hesaplamak bazen çok karmaşık
    olabilmektedir. Algoritmaları pratik bakımdan kıyaslamak için asimtotik notasyonlardan yararlanılmaktadır. Bu notasyonların
    en yaygın kullanılanı "Big O" notasyondur. Bu notasyonda belli karakterdeki algoritmalar aynı kategoride kabul edilir.
    Eğer algoritma birden fazla kategoriye sahipse en kötü duruma ilişkin kategori gerçek kategorisini belirtir.

    Algoritmanın karmaşıklığının Big O notasyonu ile iyiden kötüye doğru ketegorileri şunlardır:
    - Polinomsal (polynomial) karmaşıklıklar
    O(1)        -> sabit karmaşıklık: döngü yok. Örneğin: Üçgenin alanının bulunması, dizinin bir elemanına erişim
    O(logn)     -> logaritmik karmaşıklık (2 tabanında): Tek bir döngü var. Her adımda dönme sayısı yarı yarıya azalıyor. Örnek: binary search
    O(n)        -> doğrusal karmaşıklık: Tek döngü. Örneğin: Bir dizinin elemanları toplamının bulunması.
    O(n * logn) -> nlogn karmaşıklık: İçiçe iki döngü var, birisinde her adımda dönme sayısı yarı yarıya azalıyor. Örneğin: quick sort algoritması
    O(n ^ 2)    -> karesel karmaşıklık: İçiçe iki döngü var. Örneğin: Bir matrisin elemanları toplamının bulunması
    O(n ^ 3)    -> küpsel karmaşıklık: İçiçe üç döngü var. Örneğin: Bir kübün üzerindeki noktaların toplamının bulunması, matrislerin çarpımı
    ...
    O(n ^ k)    -> k-sal karmaşıklık (k sabit): İçiçe k tane döngü var

    - Polinomsal olmayan (non-polynomial) karmaşıklıklar
    O(k ^ n)    -> Üstel karmaşıklık (k sabit): Örneğin: N elemanlı bir kümenin alt kümelerinin bulunması
    O(n!)       -> Faktöriyel karmaşıklık. Örneğin: gezgin satıcı problemi

    Bir algoritma çoğu zaman herhangi bir karmaşıklıktayken bazı zamanlar (bu az olmalıdır) üst bir karmaşıklıkta
    çalışıyorsa, bu tarz karmaşıklıklara "amortize edilmiş (amortized) karmaşıklıklar" denir. Örneğin, bir algoritma
    çogu zaman O(1) karmaşıklıkta iken bazı zamanlar O(n) karmaşıklıkta çalışıyor ise "amortize edilmiş sabit zamanlı
    (amortized constant time)" karmaşıklıktadır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    Yaratılmış olan bir dizinin eleman sayısı değiştirilemez. Yani büyütülüp, küçültülemez. Biz diziyi büyütmek için
    yeni uzunlukta yeni bir dizi yaratılıp eski dizinin elemanlarının yeni diziye kopyalanması gerekir. Aynı referans
    ile devam edilmek istenirse yeni yaratılan dizinin adresi eski referansa atanmalıdır. java.util paketinde Arrays
    isimli diziler ile çeşitli işlemler yapabilen static metotların bulunduğu bir sınıf vardır. Bu sınıfın copyOf
    metotları ile bir dizinin yeni bir uzunlukta kopyası çıkartılabilir. Bu anlamda dizi mantıksal olarak hem büyütülebilir
    hem de küçültülebilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.ArrayUtil;

import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Random r = new Random();

		for (;;) {
			System.out.print("Dizinin eleman sayısını giriniz:");
			int count = Integer.parseInt(kb.nextLine());

			if (count <= 0)
				break;

			int[] a = ArrayUtil.getRandomArray(r, count, 0, 99);

			ArrayUtil.print(2, a);

			System.out.print("Yeni eleman sayısını giriniz:");
			int newCount = Integer.parseInt(kb.nextLine());

			a = Arrays.copyOf(a, newCount);
			ArrayUtil.print(2, a);
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Dinamik büyüyen dizi (dynamic array) veri yapıları diziyiğ eklenen eleman sayısı kadar büyütmez. Dizinin
    büyütülmesi gerektiği durumda büyütme işlemini biraz fazlaca yapar. İşte bu tarz veri yapılarından dizinin
    uzunluğuna "capacity" denir. Dizide nmantıksal olarak tutulan elemöanların sayısına ise "size/count" denir. Java'da
    "size" daha çok kullanılır. size hiçbir zaman capacity değerinden büyük olamaz. Capacity değeri size değerinden büyük
    veya size değerine eşit olabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte yukarıda anlatılan capacity kavramı kullanılarak kod yazılmıştır. Bu durumda örnekteki algoritma
    "amortize edilmiş sabit zaman maliyetli (amoritized contant time cost)" olarak çalışmaktadır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

import com.orhn.app.places.StorePlacesToArrayApp;

class App {
	public static void main(String [] args)
	{
		StorePlacesToArrayApp.run();
	}
}

package com.orhn.app.places;

import java.util.Arrays;
import java.util.Scanner;

public class StorePlacesToArrayApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Input the initial \"capacity\" value:");
        PlaceInfo [] places = new PlaceInfo[Integer.parseInt(kb.nextLine())];

        int idx = 0;

        for (;;) {
            System.out.print("Input name:");
            String name = kb.nextLine();

            if ("quit".equals(name))
                break;

            System.out.print("Input latitude:");
            double latitude = Double.parseDouble(kb.nextLine());

            System.out.print("Input longitude:");
            double longitude = Double.parseDouble(kb.nextLine());

            if (idx == places.length)
                places = Arrays.copyOf(places, places.length == 0 ? 1 : places.length * 2) ;

            places[idx++] = new PlaceInfo(name, latitude, longitude);

            System.out.printf("Capacity:%d%n", places.length);
            System.out.printf("Size:%d%n", idx);
        }

        System.out.println("-------------------------------------------------------");

        for (int i = 0; i < idx; ++i)
            System.out.println(places[i].toString());

        System.out.printf("Capacity:%d%n", places.length);
        System.out.printf("Size:%d%n", idx);
    }
}


package com.orhn.app.places;

public class PlaceInfo {
    private String m_name;
    private double m_latitude;
    private double m_longitude;
    //...

    public PlaceInfo(String name, double latitude, double longitude)
    {
        m_name = name;
        m_latitude = latitude;
        m_longitude = longitude;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public double getLatitude()
    {
        return m_latitude;
    }

    public void setLatitude(double latitude)
    {
        //...
        m_latitude = latitude;
    }

    public double getLongitude()
    {
        return m_longitude;
    }

    public void setLongitude(double longitude)
    {
        //...
        m_longitude = longitude;
    }

    public String toString()
    {
        return String.format("Name:%s, Latitude: %f, Longitude: %f", m_name, m_latitude, m_longitude);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfında capacitty kullanılır ancak büyütme politikası (growth policy) söylenmez. Bu sebeple ArrayList
    sınıfının capacity değerini veren bir metodu yoktur. Dolayısıyla capacity bilgisi gereken aşağıdaki kodlarda Vector
    sınıfı ile örnekler yazılacaktır. Vector sınıfı burada anlatılmayan fazlalıkları ve capacity değerini vermesi dışında
    ArrayList sınıfı ile aynı düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının default ctor'u capacity değeri 10 olarak nesnenin yaratılmasını sağlar. Vector
    sınıfının capacity metodu capacity değerini döndürür. ArrayList sınıfında capacity metodu yoktur4. ArrayList/Vector
    sınıfının size metodu tutulan eleman sayısına geri döner. Sınıfın initisalCapacity parametreli ctor'u ile başlangıç
    capacity değeri belirlenebilir
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

import java.util.Vector;

class App {
	public static void main(String [] args)
	{
		Vector numbers = new Vector();
		Vector names = new Vector(5);

		System.out.printf("Capacity of numbers:%d%n", numbers.capacity());
		System.out.printf("Size of numbers:%d%n", numbers.size());
		System.out.printf("Capacity of names:%d%n", names.capacity());
		System.out.printf("Size of names:%d%n", names.size());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının add metodu sona eleman eklemek için kullanılır. Şüphesiz bu metot gerektiğinde capacity
    değerini de uygun şekilde artırır. Bu metot "amortized constant time cost" biçiminde çalışır. Vector sınıfının
    default capacity büyütmesi genel olarak var olan capacity değerinin 2 katı kadardır. ArrayList/Vector sınıfının
	get metodu parametresi ile aldığı index numarasına ilişkin elemanın referansına geri döner. ArrayList/Vector
	sınıfın get metoduna pozitifi ya da negatif bakımdan sınırlar dışında bir indeks numarası verildiğinde exception
	oluşur. Burada indeks değerleri [0, size) aralığındadır. Capacity değeri size'dan büyük bile olsa indeks [0, size)
	aralığında bir değer olmalıdır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

import java.util.Scanner;
import java.util.Vector;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Vector numbers = new Vector();

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		System.out.print("Input count:");
		int count = Integer.parseInt(kb.nextLine());

		for (int i = 0; i < count; ++i)
			numbers.add(i * 10);

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		int size = numbers.size();

		for (int i = 0; i < size; ++i) {
			int val = (int)numbers.get(i);

			System.out.printf("%d ", val);
		}

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının index parametreli add metodu araya ekleme yapmak için kullanılabilir. Bu metot O(n)
    karmaşıklıktadır. Bu sürekli araya eleman eklme yapılan algoritmalarda bu veri yapısının dikkatli kullanılması
    ya da kullanılmaması gerektiği anlamına gelir. Şüphesiz bu metot gerektiğinde capacity değerini uygun şekilde
    büyütür
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Scanner;
import java.util.Vector;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		Vector numbers = new Vector();

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		System.out.print("Input count:");
		int count = Integer.parseInt(kb.nextLine());

		for (int i = 0; i < count; ++i)
			numbers.add(0, i * 10);

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		int size = numbers.size();

		for (int i = 0; i < size; ++i) {
			int val = (int)numbers.get(i);

			System.out.printf("%d ", val);
		}

		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfı for-each döngü deyimi ile dolaşılabilir (iterable) bir sınıftır. for-each döngü deyiminin
    her adımında içeride tutulan elemanları sırasıyla elde edilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.ArrayList;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		ArrayList numbers = new ArrayList();

		System.out.print("Input count:");
		int count = Integer.parseInt(kb.nextLine());

		for (int i = 0; i < count; ++i)
			numbers.add(i * 10);

		for (Object o : numbers) {
			int val = (int)o;

			System.out.printf("%d ", val);
		}

		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte capacity değeri de elde edildiğinden Vector sınıfı kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.places.StorePlacesToArrayApp;

class App {
	public static void main(String [] args)
	{
		StorePlacesToArrayApp.run();
	}
}




package com.orhn.app.places;

import java.util.Scanner;
import java.util.Vector;

public class StorePlacesToArrayApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Input the initial \"capacity\" value:");
        Vector places = new Vector(Integer.parseInt(kb.nextLine()));

        for (;;) {
            System.out.print("Input name:");
            String name = kb.nextLine();

            if ("quit".equals(name))
                break;

            System.out.print("Input latitude:");
            double latitude = Double.parseDouble(kb.nextLine());

            System.out.print("Input longitude:");
            double longitude = Double.parseDouble(kb.nextLine());

            places.add(new PlaceInfo(name, latitude, longitude));

            System.out.printf("Capacity:%d%n", places.capacity());
            System.out.printf("Size:%d%n", places.size());
        }

        System.out.println("-------------------------------------------------------");

        for (Object o : places) {
            PlaceInfo pi = (PlaceInfo)o;

            System.out.println(pi.toString());
        }

        System.out.printf("Capacity:%d%n", places.capacity());
        System.out.printf("Size:%d%n", places.size());
    }
}


package com.orhn.app.places;

public class PlaceInfo {
    private String m_name;
    private double m_latitude;
    private double m_longitude;
    //...

    public PlaceInfo(String name, double latitude, double longitude)
    {
        m_name = name;
        m_latitude = latitude;
        m_longitude = longitude;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public double getLatitude()
    {
        return m_latitude;
    }

    public void setLatitude(double latitude)
    {
        //...
        m_latitude = latitude;
    }

    public double getLongitude()
    {
        return m_longitude;
    }

    public void setLongitude(double longitude)
    {
        //...
        m_longitude = longitude;
    }

    public String toString()
    {
        return String.format("Name:%s, Latitude: %f, Longitude: %f", m_name, m_latitude, m_longitude);
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ArrayList kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.app.places.StorePlacesToArrayApp;

class App {
	public static void main(String [] args)
	{
		StorePlacesToArrayApp.run();
	}
}


package com.orhn.app.places;

import java.util.ArrayList;
import java.util.Scanner;

public class StorePlacesToArrayApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Input the initial \"capacity\" value:");
        ArrayList places = new ArrayList(Integer.parseInt(kb.nextLine()));

        for (;;) {
            System.out.print("Input name:");
            String name = kb.nextLine();

            if ("quit".equals(name))
                break;

            System.out.print("Input latitude:");
            double latitude = Double.parseDouble(kb.nextLine());

            System.out.print("Input longitude:");
            double longitude = Double.parseDouble(kb.nextLine());

            places.add(new PlaceInfo(name, latitude, longitude));
            System.out.printf("Size:%d%n", places.size());
        }

        System.out.println("-------------------------------------------------------");

        for (Object o : places) {
            PlaceInfo pi = (PlaceInfo)o;

            System.out.println(pi.toString());
        }

        System.out.printf("Size:%d%n", places.size());
    }
}



package com.orhn.app.places;

public class PlaceInfo {
    private String m_name;
    private double m_latitude;
    private double m_longitude;
    //...

    public PlaceInfo(String name, double latitude, double longitude)
    {
        m_name = name;
        m_latitude = latitude;
        m_longitude = longitude;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public double getLatitude()
    {
        return m_latitude;
    }

    public void setLatitude(double latitude)
    {
        //...
        m_latitude = latitude;
    }

    public double getLongitude()
    {
        return m_longitude;
    }

    public void setLongitude(double longitude)
    {
        //...
        m_longitude = longitude;
    }

    public String toString()
    {
        return String.format("Name:%s, Latitude: %f, Longitude: %f", m_name, m_latitude, m_longitude);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    30.07.2024
    ArrayList sınıfının isEmpty metodu ile listenin boş olup olmadığı test edilebilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.ArrayList;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		ArrayList cities = new ArrayList();

		for (;;) {
			System.out.print("Şehir ismini giriniz:");
			String city = kb.nextLine();

			if ("elma".equals(city))
				break;

			cities.add(city);
		}

		if (!cities.isEmpty())
			for (Object o : cities) {
				String city = (String)o;
				System.out.println(city.toUpperCase());
			}
		else
			System.out.println("Hiç şehir girilmedi!...");

		System.out.println("Tekrar yapıyor musunuz?");
	}
}



/*----------------------------------------------------------------------------------------------------------------------
    StringUtil sınıfının ArrayList parametreli join metodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.StringUtil;

import java.util.ArrayList;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		ArrayList cities = new ArrayList();

		for (;;) {
			System.out.print("Şehir ismini giriniz:");
			String city = kb.nextLine();

			if ("elma".equals(city))
				break;

			cities.add(city);
		}

		if (!cities.isEmpty())
			System.out.println(StringUtil.join(cities, '-', true));
		else
			System.out.println("Hiç şehir girilmedi!...");

		System.out.println("Tekrar yapıyor musunuz?");
	}
}




/*-----------------------------------------------------
  	FILE		: StringUtil.java
  	AUTHOR		: Orhan OZTURK
  	LAST UPDATE : 16.02.2023

  	Aim:


  	Copyleft(c) 1992 by Orhan ÖZTÜRK All Rights Free

 -----------------------------------------------------*/

package com.orhn.util;

import java.util.ArrayList;
import java.util.Scanner;
import java.util.Random;

public class StringUtil {

	private StringUtil()
	{}

	private static final String ALPHABET_TR = "abcçdefgğhıijklmnoöprsştuüvyz";
	private static final String ALPHABET_EN = "abcdefghijklmnopqrstuwxvyz";
	private static final String ALPHABET_CAPITAL_TR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ";
	private static final String ALPHABET_CAPITAL_EN = "ABCDEFGHIJKLMNOPQRSTUWXVYZ";
	private static final String ALPHABET_ALL_TR = ALPHABET_TR + ALPHABET_CAPITAL_TR;
	private static final String ALPHABET_ALL_EN = ALPHABET_EN + ALPHABET_CAPITAL_EN;

	/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazının ilk harfi büyük geri kalan harfleri küçük olacak şekilde ve
 	harf dışı karakterler de aynı kalacak şekilde bir yazı döndüren capitalizeWS isimli metodu StringUtil sınıfı
 	içerisinde yazınız ve aşağıdaki kod ile test ediniz. Metot yazının başında boşluk karakterleri olsa bile ilk
 	boşluk olmayan harfi büyütecek şekilde yazılacaktır
 	Örnek:   jAVA Programcısı ÇOK çalışmalıdır ->   Java programcısı çok çalışmalıdır
   ----------------------------------------------------------------------------------------------------------------------*/
	public static String capitalizeWS(String str)
	{
		int i;
		int len = str.length();

		for (i = 0; i < len && Character.isWhitespace(str.charAt(i)); i++)
			;

		return i == len ? str : str.substring(0, i) + Character.toUpperCase(str.charAt(i)) + str.substring(i + 1).toLowerCase();
	}

	/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden elma girilene kadar alınan yazıların arasında - karakteri olacak birleştirilmiş bir
	String oluşturan programı yazınız.
	Örneğin ankara istanbul izmir girilirse -> ankara-istanbul-izmir
	Örneğin: ankara girilirse -> ankara
	Açıklamalar:
	- Tamamı whitespace karakterlerden oluşan ve boş string yazıya eklenmeyecektir
	----------------------------------------------------------------------------------------------------------------------*/
	public static void concatWithHpyhen()
	{
		Scanner kb = new Scanner(System.in);

		System.out.println("Yazıları girmeye baslayınız:");
		String str = "";
		String s;

		while (!(s = kb.nextLine()).equals("elma")) {
			if(s.trim().isEmpty())
				continue;

			str += s + "-";
		}

		if(!str.isEmpty())
			str = str.substring(0, str.length() - 1);

		System.out.println(str);
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;

		for(int i = 0; (i = s1.indexOf(s2, i)) != -1; ++i, ++count)
			;

		return count;
	}

	public static String changeCase(String s)
	{
		char []c = s.toCharArray();

		for(int i = 0; i < c.length; ++i)
			c[i] = Character.isLowerCase(c[i]) ? Character.toUpperCase(c[i]) : Character.toLowerCase(c[i]);

		return String.valueOf(c);
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String getRandomTextTR(Random r, int n)
	{
		return getRandomText(r, n, ALPHABET_ALL_TR);
	}

	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new Random(), n);
	}

	public static String getRandomTextEN(Random r, int n)
	{
		return getRandomText(r, n, ALPHABET_ALL_EN);
	}

	public static String [] getRandomTextsTR(int count, int min, int max)
	{
		return getRandomTextsTR(new Random(), count, min, max);
	}

	/**
	 * Açıklama test
	 *
	 * @param r
	 * @param count
	 * @param min
	 * @param max
	 * @return
	 *
	 * Example Usega :
	 */
	public static String [] getRandomTextsTR(Random r, int count, int min, int max)
	{
		String [] result = new String[count];
		for(int i = 0; i < count; ++i)
			result[i] = getRandomTextTR(r, r.nextInt(min, max + 1));

		return result;
	}
	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new Random(), n);
	}

	public static String getRandomText(Random r, int n, String sourceText)
	{
		String str = "";
		int len = sourceText.length();

		for(int i = 0; i < n; ++i)
			str += sourceText.charAt(r.nextInt(len));

		return str;
	}

	public static String padLeading(String s, int len, char ch)
	{
		int length = s.length();

		return len <= length ? s : repeat(len - length, ch) + s;
	}

 	public static String padLeading(String s, int len)
 	{
 		return padLeading(s, len, ' ');
 	}

 	public static String padTrailing(String s, int len, char ch)
 	{
 		int length = s.length();

		return len <= length ? s : s + repeat(len - length, ch);
 	}

 	public static String padTrailing(String s, int len)
 	{
 		return padTrailing(s, len, ' ');
 	}

 	public static String repeat(int count, char ch)
 	{
 		return String.format("%" + count + "c", ' ').replace(' ', ch);
 	}

 	public static String getLastLongestPalindrome(String s)
	{
		String result = "";

		int end = s.length();

		while (end != 0) {
			int begin = 0;

			while (begin != end) {
				String str = s.substring(begin++, end);

				if(str.length() > 1 && isPalindrome(str) && result.length() < str.length())
					result = str;
			}

			--end;
		}

		return result;

	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;

		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));

			if(!Character.isLetter(cLeft)) {
				++left;
				continue;
			}

			char cRight = Character.toLowerCase(s.charAt(right));

			if(!Character.isLetter(cRight)) {
				--right;
				continue;
			}

			if(cLeft != cRight)
				return false;

			++left;
			--right;
		}

		return true;
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), ALPHABET_TR);
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), ALPHABET_EN);
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; i++)
			if(!s.contains(alphabet.charAt(i) + ""))
				return false;

		return true;
	}

	public static String reverse(String str)
	{
		String s = "";

		for (int i = str.length() - 1; i >= 0; --i)
			s += str.charAt(i);

		return s;
	}

	public static String squeeze(String s1, String s2)
	{
		int len = s1.length();
		char[] c = new char[len];
		int idx = 0;

		for (int i = 0; i < len; ++i){
			char ch = s1.charAt(i);
			if(!s2.contains(ch + ""))
				c[idx++] = ch;
		}

		return String.valueOf(c, 0, idx);
	}

	public static String join(String [] s, char delimiter)
	{
		return join(s, delimiter + "");
	}

	public static String join(String [] s, String delimiter)
	{
		return String.join(delimiter, s);
	}

	public static String join(String [] s, char delimiter, boolean removeEmpties)
	{
		return join(s, delimiter + "", removeEmpties);
	}

	public static String join(String [] s, String delimiter, boolean removeEmpties)
	{
		String str = "";

		for (int i = 0; i < s.length; i++) {
			if(removeEmpties && s[i].isBlank())
				continue;

			str += s[i] + delimiter;
		}

		return str.substring(0, str.length() - delimiter.length());
	}

	public static String join(ArrayList list, String delimiter)
	{
		return join(list, delimiter, false);
	}

	public static String join(ArrayList list, char delimiter)
	{
		return join(list, delimiter, false);
	}

	public static String join(ArrayList list, char delimiter, boolean removeEmpties)
	{
		return join(list, delimiter + "", removeEmpties);
	}

	public static String join(ArrayList list, String delimiter, boolean removeEmpties)
	{
		String str = "";

		for (Object o : list) {
			String s = (String)o;

			if (removeEmpties && s.isBlank())
				continue;

			str += s + delimiter;
		}
		return str.substring(0, str.length() - delimiter.length());
	}
}




/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının set metodu, birinci parametresi ile aldığı indeks değerindeki elemanı ikinci parmetresi ile
    aldığı eleman ile değiştirir. Metot eski elemana ilişkin referansı döndürür. Metoda [0, size) aralığı dışındaki
    indeks numarası verildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		ArrayList numbers = new ArrayList();

		System.out.print("Kaç tane sayı üretmek istersiniz?");
		int count = Integer.parseInt(kb.nextLine());
		for (int i = 0; i < count; ++i)
			numbers.add(random.nextInt(100));

		for (Object o : numbers) {
			int a = (int)o;

			System.out.printf("%d ", a);
		}
		System.out.println();

		int oldValue = (int)numbers.set(3, 108);

		for (Object o : numbers) {
			int a = (int)o;

			System.out.printf("%d ", a);
		}

		System.out.println();
		System.out.printf("Eski değer:%d%n", oldValue);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}



/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının set metodu, birinci parametresi ile aldığı indeks değerindeki elemanı ikinci parmetresi ile
    aldığı eleman ile değiştirir. Metot eski elemana ilişkin referansı döndürür. Metoda [0, size) aralığı dışındaki
    indeks numarası verildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		ArrayList numbers = new ArrayList();

		System.out.print("Kaç tane sayı üretmek istersiniz?");
		int count = Integer.parseInt(kb.nextLine());
		for (int i = 0; i < count; ++i)
			numbers.add(random.nextInt(100));

		for (Object o : numbers) {
			int a = (int)o;

			System.out.printf("%d ", a);
		}
		System.out.println();

		int oldValue = (int)numbers.set(3, 108);

		for (Object o : numbers) {
			int a = (int)o;

			System.out.printf("%d ", a);
		}

		System.out.println();
		System.out.printf("Eski değer:%d%n", oldValue);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının toString metodu ile ArrayList'in elemanları [] içerisinde virgülle ayrılacak şekilde bir
    String olarak elde edilir. Bu String'in oluşturulma detayları ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		ArrayList numbers = new ArrayList();

		System.out.print("Kaç tane sayı üretmek istersiniz?");
		int count = Integer.parseInt(kb.nextLine());

		for (int i = 0; i < count; ++i)
			numbers.add(random.nextInt(100));


		System.out.println(numbers.toString());

		int oldValue = (int)numbers.set(3, 108);

		System.out.println(numbers.toString());

		System.out.printf("Eski değer:%d%n", oldValue);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: ArrayList/Vector sınıfında size değerini azaltan (mantıksal silme yapan) metotlar capacity değerini
    değiştirmezler
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının clear metodu tüm elemanları siler (listeyi boşaltır) ancak capacity değerini değiştirmez
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import java.util.Vector;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		Vector numbers = new Vector();

		System.out.print("Kaç tane sayı üretmek istersiniz?");
		int count = Integer.parseInt(kb.nextLine());
		for (int i = 0; i < count; ++i)
			numbers.add(random.nextInt(100));

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.println(numbers.toString());
		numbers.clear();
		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.println(numbers.toString());
	}
}




/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının remove metodu parametresi ile aldığı indeks numarasına ilişkin elemanı siler. Metot
    sildiği elemana ilişkin referansa geri döner. Diziden eleman silmek O(n) karmaşıklıktadır. remove metodu da
    capacity değerini değiştirmez
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import java.util.Vector;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		Vector numbers = new Vector();

		System.out.print("Kaç tane sayı üretmek istersiniz?");
		int count = Integer.parseInt(kb.nextLine());
		for (int i = 0; i < count; ++i)
			numbers.add(random.nextInt(100));

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.println(numbers.toString());
		int oldValue = (int)numbers.remove(3);
		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.println(numbers.toString());
		System.out.printf("Eski değer:%d%n", oldValue);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının trimToSize metodu capacity değerini size değerine getirir. Bu metot O(n) karmaşıklıktadır.
    Bu sebeple bu metodun sürekli veya gereksiz yere çağrılmaması gerekir. trimToSize metodu size değeri sıfır ise genel
    olarak capacity değerini de sıfıra çeker
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Scanner;
import java.util.Vector;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		Vector numbers = new Vector();

		System.out.print("Kaç tane sayı üretmek istersiniz?");
		int count = Integer.parseInt(kb.nextLine());
		for (int i = 0; i < count; ++i)
			numbers.add(random.nextInt(100));

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());
		System.out.println(numbers.toString());

		numbers.trimToSize();

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());
		System.out.println(numbers.toString());

		numbers.clear();
		numbers.trimToSize();

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());
		System.out.println(numbers.toString());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	ArrayList/Vector sınıfının ensureCapacity metodu capacity değerini aşağıdaki şekilde büyütmeye çalışır: (else if
	biçiminde düşününüz)
	- Yeni capacity değeri o anki capacity değerinden küçük veya eşitse değişiklik yapmaz.
	- Yeni capacity değeri o anki capacity değerinin artması gereken değerinden küçük veya eşit ise artması gereken
	capacity değerine çeker
	- Yeni capacity değeri o anki capacity değerinin artması gereken değerinden büyükse yeni capacity değerine çeker

	Özetle bu metot en az o anki capacity değerinin artması gereken kadar artırabilir. O anki capacity değerini azaltmaz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import java.util.Random;
import java.util.Vector;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Vector numbers = new Vector();

		for (int i = 0; i < 11; ++i)
			numbers.add(random.nextInt(100));

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());
		System.out.println(numbers.toString());

		numbers.ensureCapacity(15);

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		numbers.ensureCapacity(34);

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		numbers.ensureCapacity(85);

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.collection.CSDArrayList;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		CSDArrayList numbers = new CSDArrayList();

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		System.out.print("Input count:");
		int count = Integer.parseInt(kb.nextLine());

		for (int i = 0; i < count; ++i)
			numbers.add(i * 10);

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		int size = numbers.size();

		for (int i = 0; i < size; ++i) {
			int val = (int)numbers.get(i);

			System.out.printf("%d ", val);
		}

		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.collection.CSDArrayList;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		CSDArrayList numbers = new CSDArrayList();

		System.out.print("Kaç tane sayı üretmek istersiniz?");
		int count = Integer.parseInt(kb.nextLine());

		for (int i = 0; i < count; ++i)
			numbers.add(random.nextInt(100));

		int size = numbers.size();

		for (int i = 0; i < size; ++i)
			System.out.printf("%d ", (int)numbers.get(i));

		System.out.println();

		int oldValue = (int)numbers.set(3, 108);

		for (int i = 0; i < size; ++i)
			System.out.printf("%d ", (int)numbers.get(i));

		System.out.println();

		System.out.printf("Eski değer:%d%n", oldValue);

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.collection.CSDArrayList;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		CSDArrayList numbers = new CSDArrayList();

		for (int i = 0; i < 11; ++i)
			numbers.add(random.nextInt(100));

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		int size = numbers.size();

		for (int i = 0; i < size; ++i)
			System.out.printf("%d ", (int)numbers.get(i));

		System.out.println();

		numbers.ensureCapacity(15);

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		numbers.ensureCapacity(34);

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		numbers.ensureCapacity(85);

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.collection.CSDArrayList;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		CSDArrayList numbers = new CSDArrayList();

		System.out.print("Kaç tane sayı üretmek istersiniz?");
		int count = Integer.parseInt(kb.nextLine());
		for (int i = 0; i < count; ++i)
			numbers.add(random.nextInt(100));

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());

		int size = numbers.size();

		for (int i = 0; i < size; ++i)
			System.out.printf("%d ", (int)numbers.get(i));

		System.out.println();


		numbers.trimToSize();

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());
		size = numbers.size();

		for (int i = 0; i < size; ++i)
			System.out.printf("%d ", (int)numbers.get(i));

		System.out.println();


		numbers.clear();
		numbers.trimToSize();

		System.out.printf("Capacity:%d%n", numbers.capacity());
		System.out.printf("Size:%d%n", numbers.size());
		size = numbers.size();

		for (int i = 0; i < size; ++i)
			System.out.printf("%d ", (int)numbers.get(i));

		System.out.println();

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.collection.CSDArrayList;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		CSDArrayList numbers = new CSDArrayList();

		System.out.print("Kaç tane sayı üretmek istersiniz?");
		int count = Integer.parseInt(kb.nextLine());
		for (int i = 0; i < count; ++i)
			numbers.add(random.nextInt(100));

		System.out.printf("Capacity:%d%n", numbers.capacity());
		int size = numbers.size();

		for (int i = 0; i < size; ++i)
			System.out.printf("%d ", (int)numbers.get(i));

		System.out.println();

		int oldValue = (int)numbers.remove(3);
		System.out.printf("Capacity:%d%n", numbers.capacity());
		size = numbers.size();

		for (int i = 0; i < size; ++i)
			System.out.printf("%d ", (int)numbers.get(i));

		System.out.println();

		System.out.printf("Eski değer:%d%n", oldValue);

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.collection.CSDArrayList;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		CSDArrayList numbers = new CSDArrayList();

		System.out.print("Input count:");
		int count = Integer.parseInt(kb.nextLine());

		for (int i = 0; i < count; ++i)
			numbers.add(0, i * 10);

		int size = numbers.size();

		System.out.printf("Size = %d%n", size);

		for (int i = 0; i < size; ++i)
			System.out.printf("%d ", (int)numbers.get(i));

		System.out.println();

	}
}



/*----------------------------------------------------------------------
	FILE        : CSDArrayList.java
	AUTHOR      : Java-Feb-2022 Group
	LAST UPDATE : 17.09.2022

	CSDArrayList class

	Copyleft (c) 1993 by C and System Programmers Association (CSD)
	All Rights Free
-----------------------------------------------------------------------*/



package com.orhn.util.collection;

public class CSDArrayList {
    private static final int DEFAULT_CAPACITY = 10;
    private Object [] m_elems;
    private int m_index;

    private static void doWorkForIllegalArgumentException(String message)
    {
        System.out.println(message);
        System.exit(1); //exception işlemleri konusuna kadar sabredin
    }

    private static void doWorkForIndexOutOfBoundException(String message)
    {
        System.out.println(message);
        System.exit(1); //exception işlemleri konusuna kadar sabredin
    }

    private static void checkCapacity(int capacity)
    {
        if (capacity < 0)
            doWorkForIllegalArgumentException("Capacity value can not be negative:" + capacity);
    }

    private void checkIndex(int index)
    {
        if (index < 0 || index >= m_index)
            doWorkForIndexOutOfBoundException("Index out of range:" + index);
    }

    private void changeCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        System.arraycopy(m_elems, 0, temp, 0, m_index);
        m_elems = temp;
    }

    private void enlargeCapacityIfNecessary()
    {
        if (m_elems.length == m_index)
            changeCapacity(m_elems.length == 0 ? 1 : m_elems.length * 2);
    }

    public CSDArrayList()
    {
        m_elems = new Object[DEFAULT_CAPACITY];
    }

    public CSDArrayList(int initialCapacity)
    {
        checkCapacity(initialCapacity);
        m_elems = new Object[initialCapacity];
    }

    public boolean add(Object elem)
    {
        enlargeCapacityIfNecessary();

        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, Object elem)
    {
        enlargeCapacityIfNecessary();

        for (int i = m_index++; i > index; --i)
            m_elems[i] = m_elems[i - 1];

        m_elems[index] = elem;
    }

    public int capacity()
    {
        return m_elems.length;
    }

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public void ensureCapacity(int minCapacity)
    {
        if (minCapacity > m_elems.length)
            changeCapacity(Math.max(m_elems.length * 2, minCapacity));
    }

    public Object get(int index)
    {
        checkIndex(index);

        return m_elems[index];
    }

    public boolean isEmpty()
    {
        return m_index == 0;
    }

    public Object remove(int index)
    {
        checkIndex(index);
        Object oldElem = m_elems[index];

        for (int i = index; i < m_index - 1; ++i)
            m_elems[i] = m_elems[i + 1];

        m_elems[--m_index] = null;

        return oldElem;
    }

    public Object set(int index, Object elem)
    {
        checkIndex(index);
        Object oldElem = m_elems[index];

        m_elems[index] = elem;

        return oldElem;
    }

    public int size()
    {
        return m_index;
    }

    public void trimToSize()
    {
        if (m_index != m_elems.length)
            changeCapacity(m_index);
    }

    //...
}



/*----------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf içerisinde taban sınıfta bulunan non-static bir veri elemanı ile aynı isimde verş elemanı bidirilebilir.
	Bu durumda türemiş sınıf içerisindeki veri elemanı taban sınıf veri elemanı ismini maskeler (shadowing, masking).
	Aşağıdaki örnekte b referansı ile B içerisinde bildirilen veri elemanına, a referansı ile a'nın gösterdği B nesnesinin
	(dinamik türünün) A bölümündeki x veri elemanına erişilmiş olur. ArtıkB türü üzerinden A sınıfının x veri elemanına
	erişilemez. Bu anlatılanlar sınıf dışından erişim için geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.collection.CSDArrayList;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		B b = new B();

		b.x = 10;

		System.out.printf("b.x = %d%n", b.x);

		A a = b; //upcasting

		a.x = 30;

		System.out.printf("a.x = %d%n", a.x);
		System.out.printf("b.x = %d%n", b.x);
	}
}

class B extends A {
	public int x;

	//...
}
class A {
	public int x;
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	super referansı ile taban sınıfın bir elemanına erişilebilir. Aşağıdaki örnekte setValues metodu ile hem taban hem de
	türemiş sınıfta aynı isimde bulunan veri elemanlarına atama yapılmıştır. super referansı ile taban sınıfın bir metodu da
	çağrılabilir. Bu konunun detayların ileride ele alınacaktır. Örnekte super.x erişiminde super rereferansını
	kaldırarak sonucu gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;


class App {
	public static void main(String [] args)
	{
		B b = new B();

		b.setValues(10, 20);
		A a = b;

		System.out.printf("a.x = %d%n", a.x);
		System.out.printf("b.x = %d%n", b.x);
	}
}

class B extends A {
	public int x;

	public void setValues(int a, int b)
	{
		x = a; //this.x = a
		super.x = b;
		super.foo();
	}
	//...
}

class A {
	public int x;

	public void foo()
	{
		System.out.println("A.foo()");
	}

	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf içerisinde taban sınıfta bulunan static bir veri elemanı ile aynı isimde bir veri elemanı bildirilebilir.
	Aşağıdaki örnekte ** ile belirtilen ifadede sınıf ismi kullanılmazsa B'nin x veri elemanı set edilir. ** ile belirtilen
	ifadede erişimi doğrudan yapıp sonucu gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;


class App {
	public static void main(String [] args)
	{
		B.setValues(10, 20);
		System.out.printf("A.x = %d%n", A.x);
		System.out.printf("B.x = %d%n", B.x);
	}
}

class B extends A {
	public static int x;

	public static void setValues(int a, int b)
	{
		x = a; //this.x = a
		A.x = b; //**
	}
	//...
}

class A {
	public static int x;

	//...
}



/*----------------------------------------------------------------------------------------------------------------------
	Polymorphism (Çok Biçimlilik): Polymorphism Biyoloji'den programlamaya aktarılmıştır. Biyoloji'de polymorphism
	şu şekilde tanımlanabilir: "Farklı doku ya da organların evrim süreci içerisinde temel işlevleri aynı kalmak koşuluyla,
	bu işlevi yerine getirme biçimlerinin birbirinden türeyen canlılarda değişebilmesidir". Örneğin görme davranışı (eylemi)
	birbirinden türemiş canlılar arasında farklılık gösterebilir. Ancak görev "görmektir".

	Nesne yönelimli programlama tekniğinde bu bölümde anlatılan çok biçimliliğe (ki bu da Biyoloji'den aktarılandır)
	"çalışma zamanı çok biçimliliği (runtime polymorphism)" denir. Polymorphisim dendiğinde "runtime polymorphism"
	anlaşılır. Diğer bir "polymorphism" de "derleme zamanı çok biçimliliği (compile time polymorphism)" olarak adlandırılır.
	Bu konu ileride ele alınacaktır.

	Çalışma zamanı çok biçimliliği için pek çok tanım ya da açıklama (betimleme) yapılabilse de genel olarak aşağıdaki
	3 tanıma indirgenebilir:
	1. Biyolojik Tanım: Taban sınıfın bir fonksiyonunun türemiş sınıfta yeniden gerçekleştirilmesidir.
	2. Yazılım Mühendisliği Tanımı: Türden bağımsız kod yazmaktır.
	3. Aşağı Seviyeli Tanım: Önceden yazılmış kodların sonradan yazılmış kodları çağırabilmesidir.

	Java'da çalışma zamanı çok biçimliliği sanal (virtual) metotlar kullanılarak gerçekleştirilir. Java'da non-static olan
	ve final olmayan metotlar sanaldır. İleride bunun dışında sanal olan metotlar da göreceğiz.

	Anahtar Notlar: Yukarıdaki tanıma göre Java'da bir metodu sanal yapmak için özel bir bildirim yoktur. Buna
	"virtual dispatching" denir. Bazı programlama dilleri için (Java'yı büyük ölçü de örnek alan Kotlin, C# gibi diller de
	dahil) bir metodun sanal olduğu özel anahtar sözcüklerle bildirim sırasında yazılır. Java'da ileride göreceğimiz
	abstract anahtar sözcüğü dışında bir metodun sanal olması için bildirimde bir şey yazılmaz

	Sanal bir metodun türemiş sınıf içerisinde geri dönüş değeri ve imzası aynı olacak şekilde yazılmasına "override"
	denir. override işleminde erişim belirleyicinin durumu ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte B sınıfında A'nın (yani taban sınıfının) foo ve int parametreli bar metodu "override" edilmiştir.
	B sınıfında double parametreli bar metodu "overload" edilmiştir
----------------------------------------------------------------------------------------------------------------------*/


class B extends A {
	public void foo() //override
	{
		System.out.println("B.foo");
	}

	public void bar(int a) //override
	{
		System.out.println("B.bar(int)");
	}

	public void bar(double a) //overload
	{
		System.out.println("B.bar(double)");
	}
}

class A {
	public void foo() //virtual
	{
		System.out.println("A.foo");
	}

	public void bar(int a) //virtual
	{
		System.out.println("A.bar");
	}
}




/*----------------------------------------------------------------------------------------------------------------------
	Derleyici non-static bir metot çağrısı için "çalışma zamanında referansın dinamik türüne bak, dinamik türe ilişkin
	sınıfta metot override edilmişse onu çağır" kodunu üretir. Aşağıdaki örnekte main metodunun içerisindeki müşteri
	kod A sınıfınfdan türetilmiş olanm sınıflardan bağımsız olarak yazılmıştır. Yani türden bağımsız yazılmıştır. Ancak
	çalışma zamanında referansın dinamil türü A sınıfından türetilmiş olam bir sınıf olabilir. Örnekte dinamik tür
	üretilen rasgele sayıya bağlıdır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		SampleApp.run();
	}
}

class SampleApp {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		RandomAFactory factory = new RandomAFactory(new Random());

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		while (count-- > 0) {
			System.out.println("----------------------------------");
			A a = factory.createRandomInstance();

			System.out.println(a.getClass().getName());
			a.foo();
			a.bar(10);
			System.out.println("----------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class RandomAFactory {
	private final Random m_random;

	public RandomAFactory(Random random)
	{
		m_random = random;
	}

	public A createRandomInstance()
	{
		return switch (m_random.nextInt(4)) {
			case 0 -> new A();
			case 1 -> new B();
			case 2 -> new C();
			default -> new D();
		};
	}
}


class D extends A {
	public void foo() //override
	{
		System.out.println("D.foo");
	}

	public void bar(int a) //override
	{
		System.out.println("D.bar(int)");
	}
}

class C extends B {
	public void foo() //override
	{
		System.out.println("C.foo");
	}

	public void bar(int a) //override
	{
		System.out.println("C.bar(int)");
	}
}

class B extends A {
	public void foo() //override
	{
		System.out.println("B.foo");
	}

	public void bar(int a) //override
	{
		System.out.println("B.bar(int)");
	}

	public void bar(double a) //overload
	{
		System.out.println("B.bar(double)");
	}
}

class A {
	public void foo() //virtual
	{
		System.out.println("A.foo");
	}

	public void bar(int a) //virtual
	{
		System.out.println("A.bar");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örneğe E sınıfı eklenmesine rağmen main metodu içerisindeki kodlar bundan etkilenmemiştir. Yani main metodu
	içerisinde A'dan türeyen sınıflar anlamında türden bağımsızlık vardır. Diğer bir deyişle, "A sınıfın türemiş olan
	her sınıf A'dır" düşüncesiyle kod yazılmıştır. Çalışma zamanında dinamik tür ile gerçek türlere ilişkin metotlar
	çağrılır. Ayrıca dikkat edilirse E sınıfı main metodundan sonra yazılmasına karşın çalışma zamanında kullanılabilmektedir.
	"Aşağı Seviyeli Tanım"'ı anımsayınız. Örnekteki her sınıfı ayrı bir dosyada hatta ayrı kütüphane veya kütüphanelerde
	olabileceği düşüncesiyle konuya odaklanınız
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		SampleApp.run();
	}
}

class SampleApp {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		RandomAFactory factory = new RandomAFactory(new Random());

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		while (count-- > 0) {
			System.out.println("----------------------------------");
			A a = factory.createRandomInstance();

			System.out.println(a.getClass().getName());
			a.foo();
			a.bar(10);
			System.out.println("----------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class RandomAFactory {
	private final Random m_random;

	public RandomAFactory(Random random)
	{
		m_random = random;
	}

	public A createRandomInstance()
	{
		return switch (m_random.nextInt(5)) {
			case 0 -> new A();
			case 1 -> new B();
			case 2 -> new C();
			case 3 -> new E();
			default -> new D();
		};
	}
}

class E extends C {
	public void foo() //override
	{
		System.out.println("E.foo");
	}

	public void bar(int a) //override
	{
		System.out.println("E.bar(int)");
	}
}

class D extends A {
	public void foo() //override
	{
		System.out.println("D.foo");
	}

	public void bar(int a) //override
	{
		System.out.println("D.bar(int)");
	}
}

class C extends B {
	public void foo() //override
	{
		System.out.println("C.foo");
	}

	public void bar(int a) //override
	{
		System.out.println("C.bar(int)");
	}
}

class B extends A {
	public void foo() //override
	{
		System.out.println("B.foo");
	}

	public void bar(int a) //override
	{
		System.out.println("B.bar(int)");
	}

	public void bar(double a) //overload
	{
		System.out.println("B.bar(double)");
	}
}

class A {
	public void foo() //virtual
	{
		System.out.println("A.foo");
	}

	public void bar(int a) //virtual
	{
		System.out.println("A.bar");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sanal dinamik türe ilişkin sınıfta override edilmemişse sırasıyla doğrudan ve dolaylı taban sınıflara bakılır. İlk
	bulunan metot çağrılır. Bu durumda en kötü ihtimalle static türe ilişkin sınıftaki çağrılır. Şüphesiz static
	türe ilişkin sınıfta metodun olmaması söz konusu olamaz. Aksi durumda müşteri kodlar derlenemez
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		SampleApp.run();
	}
}
class SampleApp {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		RandomAFactory factory = new RandomAFactory(new Random());

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		while (count-- > 0) {
			System.out.println("----------------------------------");
			A a = factory.createRandomInstance();

			System.out.println(a.getClass().getName());
			a.foo();
			a.bar(10);
			System.out.println("----------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class RandomAFactory {
	private final Random m_random;

	public RandomAFactory(Random random)
	{
		m_random = random;
	}

	public A createRandomInstance()
	{
		return switch (m_random.nextInt(5)) {
			case 0 -> new A();
			case 1 -> new B();
			case 2 -> new C();
			case 3 -> new E();
			default -> new D();
		};
	}
}

class E extends C {
	public void foo() //override
	{
		System.out.println("E.foo");
	}
}
class D extends A {

	public void bar(int a) //override
	{
		System.out.println("D.bar(int)");
	}
}

class C extends B {
	public void foo() //override
	{
		System.out.println("C.foo");
	}

	public void bar(int a) //override
	{
		System.out.println("C.bar(int)");
	}
}

class B extends A {
	//...
	public void bar(double a) //overload
	{
		System.out.println("B.bar(double)");
	}
}

class A {
	public void foo() //virtual
	{
		System.out.println("A.foo");
	}

	public void bar(int a) //virtual
	{
		System.out.println("A.bar");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bazen override edilen metot içerisinde taban sınıfın ilgili metodunun da çağrılması gerekebilir. Bu işlem super
	referansı ile yapılır. Bu işlem mantıksal olarak "eski davranışla beraber yeni eklentilerin de olduğu" anlamına
	gelir. Buna "augmentation" da denir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		SampleApp.run();
	}
}
class SampleApp {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		RandomAFactory factory = new RandomAFactory(new Random());

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		while (count-- > 0) {
			System.out.println("----------------------------------");
			A a = factory.createRandomInstance();

			System.out.println(a.getClass().getName());
			a.foo();
			a.bar(10);
			System.out.println("----------------------------------");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class RandomAFactory {
	private final Random m_random;

	public RandomAFactory(Random random)
	{
		m_random = random;
	}

	public A createRandomInstance()
	{
		return switch (m_random.nextInt(5)) {
			case 0 -> new A();
			case 1 -> new B();
			case 2 -> new C();
			case 3 -> new E();
			default -> new D();
		};
	}
}

class E extends C {
	public void foo() //override
	{
		System.out.println("E.foo");
		super.foo();
	}

	public void bar(int a) //override
	{
		System.out.println("E.bar(int)");
		super.bar(a);
	}
}
class D extends A {
	public void foo() //override
	{
		System.out.println("D.foo");
		super.foo();
	}

	public void bar(int a) //override
	{
		System.out.println("D.bar(int)");
		super.bar(a);
	}
}

class C extends B {
	public void foo() //override
	{
		System.out.println("C.foo");
		super.foo();
	}

	public void bar(int a) //override
	{
		System.out.println("C.bar(int)");
		super.bar(a);
	}
}

class B extends A {
	public void foo() //override
	{
		System.out.println("B.foo");
		super.foo();
	}

	public void bar(int a) //override
	{
		System.out.println("B.bar(int)");
		super.bar(a);
	}

	public void bar(double a) //overload
	{
		System.out.println("B.bar(double)");
	}
}

class A {
	public void foo() //virtual
	{
		System.out.println("A.foo");
	}

	public void bar(int a) //virtual
	{
		System.out.println("A.bar");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	CompanyApp örneği: Örnekte calculateInsurancePayment sanal metodu dolayısıyla HumanResources.payInsurance metodu türden
	bağımsız yazılmıştır ve çok biçimli olarak dinamik türe ilişkin nesnenin sigorta ödemesini elde edebilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.company.CompanyApp;

class App {
	public static void main(String [] args)
	{
		CompanyApp.run();
	}
}

package com.orhn.app.company;

public class CompanyApp {
    private static Worker getWorker() //Metot herhangi bir yerden bilgileri okuyor olarak düşününüz
    {
        Worker w = new Worker();

        w.setCitizenId("12345678924");
        w.setName("Ali");
        w.setAddress("Şişli");
        w.setFeePerHour(100.4);
        w.setHourPerDay(8);

        return w;
    }

    private static Manager getManager() //Metot herhangi bir yerden bilgileri okuyor olarak düşününüz
    {
        Manager m = new Manager();

        m.setName("Veli");
        m.setCitizenId("12345678916");
        m.setAddress("Mecidiyeköy");
        m.setSalary(30000);
        m.setDepartment("Pazarlama");

        return m;
    }

    private static SalesManager getSalesManager() //Metot herhangi bir yerden bilgileri okuyor olarak düşününüz
    {
        SalesManager sm = new SalesManager();

        sm.setName("Selami");
        sm.setCitizenId("12345678918");
        sm.setAddress("Beykoz");
        sm.setSalary(40000);
        sm.setDepartment("Satış");
        sm.setExtra(10000);

        return sm;
    }

    private static ProjectWorker getProjectWorker() //Metot herhangi bir yerden bilgileri okuyor olarak düşününüz
    {
        ProjectWorker pw = new ProjectWorker();

        pw.setCitizenId("12345678924");
        pw.setName("Ayşe");
        pw.setAddress("Riva");
        pw.setFeePerHour(100.4);
        pw.setHourPerDay(8);
        pw.setFeeFactor(1.5);
        pw.setProjectName("Chat system");

        return pw;
    }


    public static void run()
    {
        HumanResources hr = new HumanResources();
        Manager m = getManager();
        Worker w = getWorker();
        SalesManager sm = getSalesManager();
        ProjectWorker pw = getProjectWorker();

        //...

        hr.payInsurance(m);
        hr.payInsurance(w);
        hr.payInsurance(sm);
        hr.payInsurance(pw);
    }
}


package com.orhn.app.company;

public class Employee {
    private String m_citizenId;
    private String m_name;
    private String m_address;

    //...

    public String getCitizenId()
    {
        return m_citizenId;
    }

    public void setCitizenId(String citizenId)
    {
        //...
        m_citizenId = citizenId;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getAddress()
    {
        return m_address;
    }

    public void setAddress(String address)
    {
        //...
        m_address = address;
    }

    public double calculateInsurancePayment()
    {
        return 0;
    }

    //...
}

package com.orhn.app.company;

public class HumanResources {
    //...
    public void payInsurance(Employee employee)
    {
        System.out.println("--------------------------------------");
        System.out.printf("Citizen Id:%s%n", employee.getCitizenId());
        System.out.printf("Name:%s%n", employee.getName());
        System.out.printf("Insurance Payment:%f%n", employee.calculateInsurancePayment());
        System.out.println("--------------------------------------");

        //...
    }
}

package com.orhn.app.company;

public class Manager extends Employee {
    private double m_salary;
    private String m_department;
    //...


    public double getSalary()
    {
        return m_salary;
    }

    public void setSalary(double salary)
    {
        //...
        m_salary = salary;
    }

    public String getDepartment()
    {
        return m_department;
    }

    public void setDepartment(String department)
    {
        //...
        m_department = department;
    }

    public double calculateInsurancePayment()
    {
        return m_salary * 1.6;
    }
}


package com.orhn.app.company;

public class ProjectWorker extends Worker {
    private double m_feeFactor;
    private String m_projectName;
    //...


    public double getFeeFactor()
    {
        return m_feeFactor;
    }

    public void setFeeFactor(double feeFactor)
    {
        //...
        m_feeFactor = feeFactor;
    }

    public String getProjectName()
    {
        return m_projectName;
    }

    public void setProjectName(String projectName)
    {
        //...
        m_projectName = projectName;
    }

    public double calculateInsurancePayment()
    {
        return super.calculateInsurancePayment() * m_feeFactor;
    }
}

package com.orhn.app.company;

public class SalesManager extends Manager {
    private double m_extra;

    //...

    public double getExtra()
    {
        return m_extra;
    }

    public void setExtra(double extra)
    {
        //...
        m_extra = extra;
    }

    public double calculateInsurancePayment()
    {
        return super.calculateInsurancePayment() + m_extra * 1.3;
    }
}



package com.orhn.app.company;

public class Worker extends Employee {
    private int m_hourPerDay;
    private double m_feePerHour;
    //...


    public int getHourPerDay()
    {
        return m_hourPerDay;
    }

    public void setHourPerDay(int hourPerDay)
    {
        //...
        m_hourPerDay = hourPerDay;
    }

    public double getFeePerHour()
    {
        return m_feePerHour;
    }

    public void setFeePerHour(double feePerHour)
    {
        //...
        m_feePerHour = feePerHour;
    }

    public double calculateInsurancePayment()
    {
        return m_feePerHour * m_hourPerDay * 30;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Object sınıfının toString metodu nesneye ilişkin tekil (unique) bir bilgiyi yazı olarak döndürür. Bu bilginin detayının
	şu an için önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Sample s1 = new Sample();
		Sample s2 = new Sample();
		Sample s3 = new Sample();

		System.out.println(s1.toString());
		System.out.println(s2.toString());
		System.out.println(s3.toString());
	}
}

class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Object sınıfının toString metodu sanal bir metottur. Bir nesnenin yazı karşılığı anlamlı olması durumunda sınıf için
	bu metot override edilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Object o1 = new Sample();
		Object o2 = new Sample();
		Object o3 = new Sample();

		System.out.println(o1.toString());
		System.out.println(o2.toString());
		System.out.println(o3.toString());
	}
}

class Sample {
	public String toString()
	{
		return "Sample";
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	println ve print metotlarının Object parametreli overload'ları ekrana bastıkları yazı için toString metodunu
	çağırırlar
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.datetime.Date;
import com.orhn.util.datetime.DateUtil;
import com.orhn.util.datetime.Time;
import com.orhn.util.datetime.TimeUtil;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
		Random r = new Random();
		Date date = DateUtil.randomDate(r);
		Time time = TimeUtil.randomTime(r);

		System.out.println(date);
		System.out.println(time);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte printf çağrılarında otomatik kutulama yapılır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		double x = 10.5;
		int y = 45;
		boolean z = true;

		System.out.printf("x = %f, y = %d, z = %b%n", x, y, z);
		System.out.printf("x = %s, y = %s, z = %s%n", x, y, z);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte + operatörünün operandlarından biri String türündendir. Bu durumda diğer operand için toString
	metodu çağrılarak yazı birleştirmesi yapılır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.datetime.Date;
import com.orhn.util.datetime.DateUtil;

class App {
	public static void main(String [] args)
	{
		Date d = DateUtil.randomDate();

		System.out.println("Tarih:" + d); // System.out.println("Tarih:" + d.toString());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	+ operatörünün operandlarından biri String türünden, diğeri temel türlerden biriyse temel türe ilişklin değerin yazı
	karşılığı auto boxing yapılıp toString metodu çağrılarak elde edilir.. Aşağıdaki örnekte
		"Sayı:" + a
	ifadesi için derleyici yaklaşık olarak:
		"Sayı:" + Integer.valueOf(a).toString()
	şeklinde bir kod üretir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.datetime.Date;
import com.orhn.util.datetime.DateUtil;

class App {
	public static void main(String [] args)
	{
		int a = 10;

		String str = "Sayı:" + a; //String str = "Sayı:" + Integer.valueOf(a).toString();

		System.out.println(str);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayList sınıfının toString metodu [ ile ] arasında yazıları elde etmek için toString metodunu çağrırır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.datetime.Date;
import com.orhn.util.datetime.DateUtil;

import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Random r = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = Integer.parseInt(kb.nextLine());

		ArrayList dates = new ArrayList();
		ArrayList numbers = new ArrayList();

		for (int i = 0; i < count; ++i) {
			dates.add(DateUtil.randomDate(r, 1900, 2100));
			numbers.add(r.nextInt(0, 99));
		}

		System.out.println(dates);
		System.out.println(numbers);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	abstract metotlar ve abstract metotlar
	Bazı durumlarda (ki bu durumlar hiç de az değildir) bir sınıf bir kavramı soyut (abstrhact) olarak tekmsil edebilir.
	Bu durumda sınıfın nesne olarak tek başına anlamı yoktur. Yani nesne yönelimli bakış açısıyla o sınıf türünden
	nesnenin tek başına yaratılmasının da anlamı yoktur. Ancak soyu sınıftan türemiş olan sınıfların nesne olarak anlamı
	olabilir. Bu taz sınıflara "soyut sınıflar (abstract classes)" denir. Soyut olmayan sınıflara da "somut sınıflar (concrete classes)"
	denir. Kendi başına nesne özelliği göstermeyen sınıfların "abstract" olarak bildirilmesi daha uygundur. Örneğin
	CompanyApp uygulamasında Employee sınıfı türünden nesne yaratılmasının anlamı yoktur. Employee sınıfından türemiş
	olan sınıflar somut olarak düşünülmelidir. Yani Employee sınıfı "çalışan kavramını" temsil eder. Böylelikle
	"soyutlama (abstraction)" yapılmış olur.

	Bu durumda programcı abstract bir sınıf gördüğünde"somut bir sınıf için bu sınıftan türetme yapmam gerekiyor, varsa
	(ki büyük ihtimalle vardır) abstract metotlarını override etmem gerekiyor" anlamalıdır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf abstract anahtar sözcüğü ile bildirildiğinde soyut bir sınıf olur. Ya da tersine soyut bir sınıf abstract
	anahtar sözcüğü ile bildirilmelidir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

abstract class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıfın abstract metotları olabilir. abstract metot gövdesi olmayan metottur. abstract metotlara gövde yazılması
	error oluşturur. abstract metotlar abstract anahtar sözcüğü ile bildirilirler. Gövde yerine noktalı virgül konarak
	bildirim tamamlanır. abstract metotlar sanaldır. Dolayısıyla abstract metot override edilebilir. En az bir tane
	abstract metodu olan bir sınıf abstract olarak bildirilmelidir. Aksi durumda error oluşurç Tersine hiçbir abstract
	metodu olmayan bir sınıf da abstract olarak bildirilebilir. abstract bir sınıfın abstract olmayan metotları olabilir
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıfın abstract metotları olabilir. abstract metot gövdesi olmayan metottur. abstract metotlara gövde yazılması
	error oluşturur. abstract metotlar abstract anahtar sözcüğü ile bildirilirler. Gövde yerine noktalı virgül konarak
	bildirim tamamlanır. abstract metotlar sanaldır. Dolayısıyla abstract metot override edilebilir. En az bir tane
	abstract metodu olan bir sınıf abstract olarak bildirilmelidir. Aksi durumda error oluşurç Tersine hiçbir abstract
	metodu olmayan bir sınıf da abstract olarak bildirilebilir. abstract bir sınıfın abstract olmayan metotları olabilir
----------------------------------------------------------------------------------------------------------------------*/

class D extends A {
	public void foo()
	{
		//...
	}
}
abstract class A {
	public abstract void foo();

	public void bar()
	{
		//...
	}
}

abstract class B {
	public abstract void foo() //error
	{

	}

	public void bar(); //error

}

class C { //error
	public abstract void foo();
}



/*----------------------------------------------------------------------------------------------------------------------
	abstract sınıf türünden bir nesne new operatörü ile yaratılamaz. abstract sınıf türünden nesne o sınıf içerisinde de
	new operatörü ile yaratılamaz.
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A a = new A(); //error
	}
}


abstract class A {
	public abstract void foo();

	public void bar()
	{
		A a;

		a = new A(); //error
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	abstract sınıfların non-static veri elemanları olabilir. abstract sınıfların abstract olmayan metotları da olabilir.
	Yani abstract sınıflar abstract olma ve buna yönelik özellikler dışında concrete bir sınıftan farksızdır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

abstract class A {
	private int m_x;
	public abstract void foo();
	public abstract void foo(int a);

	public void bar()
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	enum sınıflar abstract olarak bildirilemez
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

abstract enum Color { //error
	RED, GREEN, BLUE
}



/*----------------------------------------------------------------------------------------------------------------------
	abstract bir sınıftan türeetilmiş bir sınıf taban sınıfının en az bir tane abstract metodunu override etmezse
	türemiş sınıf da abstract olarak bildirilmek zorundadır. Sınıf içerisinde abstract metot kalmadıysa bu durumda
	sınıf concrete olabilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class C extends A {
	public void foo()
	{
		//...
	}

	public void bar()
	{
		//...
	}
}

class D extends B {
	public void bar()
	{
		//...
	}
}
abstract class B extends A {
	public void foo()
	{
		//...
	}
}

class E extends A { //error: abstract olarak bildirilmelidir
	public void foo()
	{
		//...
	}
}

abstract class A {
	public abstract void foo();
	public abstract void bar();
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	abstract sınıf referanslarının taban sınıf referansı olarak kullanımı anlamlıdır. Bu durumda polymophisim de abstract
	sınıflar ile yapılabilir ki bu da temel hedeftir.
	Aşağıda daha önce yazmış olduğunmuz Employee sınıfının abstract olduğuna dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	abstract bir sınıftan türeetilmiş bir sınıf taban sınıfının en az bir tane abstract metodunu override etmezse
	türemiş sınıf da abstract olarak bildirilmek zorundadır. Sınıf içerisinde abstract metot kalmadıysa bu durumda
	sınıf concrete olabilir
----------------------------------------------------------------------------------------------------------------------*/
class C extends A {
	public void foo()
	{
		//...
	}

	public void bar()
	{
		//...
	}
}

class D extends B {
	public void bar()
	{
		//...
	}
}
abstract class B extends A {
	public void foo()
	{
		//...
	}
}

class E extends A { //error: abstract olarak bildirilmelidir
	public void foo()
	{
		//...
	}
}

abstract class A {
	public abstract void foo();
	public abstract void bar();
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	abstract sınıf referanslarının taban sınıf referansı olarak kullanımı anlamlıdır. Bu durumda polymophisim de abstract
	sınıflar ile yapılabilir ki bu da temel hedeftir.
	Aşağıda daha önce yazmış olduğunmuz Employee sınıfının abstract olduğuna dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.app.company.CompanyApp;

class App {
	public static void main(String [] args)
	{
		CompanyApp.run();
	}
}


package com.orhn.app.company;

public class CompanyApp {
    private static Worker getWorker() //Metot herhangi bir yerden bilgileri okuyor olarak düşününüz
    {
        Worker w = new Worker();

        w.setCitizenId("12345678924");
        w.setName("Ali");
        w.setAddress("Şişli");
        w.setFeePerHour(100.4);
        w.setHourPerDay(8);

        return w;
    }

    private static Manager getManager() //Metot herhangi bir yerden bilgileri okuyor olarak düşününüz
    {
        Manager m = new Manager();

        m.setName("Veli");
        m.setCitizenId("12345678916");
        m.setAddress("Mecidiyeköy");
        m.setSalary(30000);
        m.setDepartment("Pazarlama");

        return m;
    }

    private static SalesManager getSalesManager() //Metot herhangi bir yerden bilgileri okuyor olarak düşününüz
    {
        SalesManager sm = new SalesManager();

        sm.setName("Selami");
        sm.setCitizenId("12345678918");
        sm.setAddress("Beykoz");
        sm.setSalary(40000);
        sm.setDepartment("Satış");
        sm.setExtra(10000);

        return sm;
    }

    private static ProjectWorker getProjectWorker() //Metot herhangi bir yerden bilgileri okuyor olarak düşününüz
    {
        ProjectWorker pw = new ProjectWorker();

        pw.setCitizenId("12345678924");
        pw.setName("Ayşe");
        pw.setAddress("Riva");
        pw.setFeePerHour(100.4);
        pw.setHourPerDay(8);
        pw.setFeeFactor(1.5);
        pw.setProjectName("Chat system");

        return pw;
    }


    public static void run()
    {
        HumanResources hr = new HumanResources();
        Manager m = getManager();
        Worker w = getWorker();
        SalesManager sm = getSalesManager();
        ProjectWorker pw = getProjectWorker();

        //...

        hr.payInsurance(m);
        hr.payInsurance(w);
        hr.payInsurance(sm);
        hr.payInsurance(pw);
    }
}

package com.orhn.app.company;

public abstract class Employee {
    private String m_citizenId;
    private String m_name;
    private String m_address;

    //...

    public String getCitizenId()
    {
        return m_citizenId;
    }

    public void setCitizenId(String citizenId)
    {
        //...
        m_citizenId = citizenId;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        //...
        m_name = name;
    }

    public String getAddress()
    {
        return m_address;
    }

    public void setAddress(String address)
    {
        //...
        m_address = address;
    }

    public abstract double calculateInsurancePayment();
    //...
}


package com.orhn.app.company;

public class HumanResources {
    //...
    public void payInsurance(Employee employee)
    {
        System.out.println("--------------------------------------");
        System.out.printf("Citizen Id:%s%n", employee.getCitizenId());
        System.out.printf("Name:%s%n", employee.getName());
        System.out.printf("Insurance Payment:%f%n", employee.calculateInsurancePayment());
        System.out.println("--------------------------------------");

        //...
    }
}


package com.orhn.app.company;

public class Manager extends Employee {
    private double m_salary;
    private String m_department;
    //...


    public double getSalary()
    {
        return m_salary;
    }

    public void setSalary(double salary)
    {
        //...
        m_salary = salary;
    }

    public String getDepartment()
    {
        return m_department;
    }

    public void setDepartment(String department)
    {
        //...
        m_department = department;
    }

    public double calculateInsurancePayment()
    {
        return m_salary * 1.6;
    }
}


package com.orhn.app.company;

public class ProjectWorker extends Worker {
    private double m_feeFactor;
    private String m_projectName;
    //...


    public double getFeeFactor()
    {
        return m_feeFactor;
    }

    public void setFeeFactor(double feeFactor)
    {
        //...
        m_feeFactor = feeFactor;
    }

    public String getProjectName()
    {
        return m_projectName;
    }

    public void setProjectName(String projectName)
    {
        //...
        m_projectName = projectName;
    }

    public double calculateInsurancePayment()
    {
        return super.calculateInsurancePayment() * m_feeFactor;
    }
}

package com.orhn.app.company;

public class SalesManager extends Manager {
    private double m_extra;

    //...

    public double getExtra()
    {
        return m_extra;
    }

    public void setExtra(double extra)
    {
        //...
        m_extra = extra;
    }

    public double calculateInsurancePayment()
    {
        return super.calculateInsurancePayment() + m_extra * 1.3;
    }
}


package com.orhn.app.company;

public class Worker extends Employee {
    private int m_hourPerDay;
    private double m_feePerHour;
    //...


    public int getHourPerDay()
    {
        return m_hourPerDay;
    }

    public void setHourPerDay(int hourPerDay)
    {
        //...
        m_hourPerDay = hourPerDay;
    }

    public double getFeePerHour()
    {
        return m_feePerHour;
    }

    public void setFeePerHour(double feePerHour)
    {
        //...
        m_feePerHour = feePerHour;
    }

    public double calculateInsurancePayment()
    {
        return m_feePerHour * m_hourPerDay * 30;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	abstract sınıfların ctor'ları olabilir. abstract sınıfların ctor'larının public yapılması anlamsızdır. public
	yerine protected yapılması okunabilirlik/algılanabilirlik açısından uygundur. private ve no-modifier ctor'lar
	sınıfın senaryosuna göre anlamlı olabilirler.
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		B b;

		b = new B(10, 20);

		A a;

		a = b;

		System.out.printf("a.x = %d%n", a.getX());

		a.foo();
	}
}

class B extends A {
	private int m_y;

	public B(int x, int y)
	{
		super(x);
		m_y = y;
	}

	public void foo()
	{
		System.out.println("B.foo");
	}

}
abstract class A {
	private int m_x;
	protected int a;

	private A()
	{
		System.out.println("A.A()");
	}

	protected A(int x)
	{
		this();
		m_x = x;
	}

	public int getX()
	{
		return m_x;
	}

	public void setX(int x)
	{
		m_x = x;
	}

	public abstract void foo();
}



/*----------------------------------------------------------------------------------------------------------------------
	Şüphesiz abstract sınıflar final oalrak bildirilemez. Ya da finaşl sonıflar abstract olarak bildirilemez :)
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

abstract final class A {

}

/*----------------------------------------------------------------------------------------------------------------------
	override edilen bir metodun erişim belirleyicisi (erişim anlamında) dürşürülemez. override edilen bir metodun
	erişim belirleyici yükseltilebilir. Bu durumda public bir metot ancak public olarak override edilebilir
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class B extends A {
	protected void foo() //error
	{
		//...
	}

	public void bar()
	{
		//...
	}
}

abstract class A {
	public abstract void foo();

	protected abstract void bar();
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	private bir metot override edilemez. Dolayısıyla private metot abstract olamaz. Sizce neden private override
	edilemez? Aşağıdaki örnek bunun cevabı mıdır?
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A a = new B();

		a.foo();
	}
}

class B extends A {
	public void foo()
	{
		//...
	}


}

abstract class A {
	private void foo()
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java'da static bir metot türemiş sınıfta aynı geri dönüş değeri ve aynı imza ile ve erişim belirleyicisi düşürülmemek
	kaydıyla yeniden yazılabilir. Bu durumda metot hangi sınıf ile çağrılıyorsa o sınıfın metodu çağrılmış olur. Bu durum
	her ne kadar override işlemini andırsa da "override" dendiğinde non-static metot anlaşılır. "static metotlar override EDİLEMEZ"
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A.foo();
		B.foo();
	}
}

class B extends A {
	public static void foo()
	{
		System.out.println("B.foo");
	}


}

class A {
	public static void foo()
	{
		System.out.println("A.foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	31.07.2024
	Exception İşlemleri:
	Exception programlamada genel olarak çalışma zamanında oluşan hatalara denir. Ancak bezen bir exception hata durumuna
	ilişkin olmayabilir. Exception oluştuğunda akışın nasıl devam edeceğinin belirlenmesine "exception handling" denir.
	Örneğin, bir yön bulma uygulamasında GPS sensöründen bilgi alınamaması durumunda bir exception oluşuyor olsun. Bu
	durumda "exception handling" ile program bunu kullanıcıya belirterek uygulamanın devam etmesini sağlayabilir.

	Java'da exception işlemleri için aşağıdaki anahtar sözcükler kullanılır: throw, try, catch, finally, throws

	Bir exception throw deyimi ile fırlatılabilir. throw deyiminin kullanımının genel biçimi şu şekildedir:
		throw <referans>;
	throw deyiminin aldığı referansın Throwable sınıfından doğrudan ya da dolaylı olarak türeömiş bir sınıf türünden olması
	gerekir. Aksi durumda error oluşur.

	Bir exception fırlatıldığında akış exception'ın fırlatıldığı metottan çıkar.

	Bir exception yakalanamaz ise bu durumda exception'ın fırlatıldığı akış (thread) sonlanır

    Akış exception bakımından ele alınacaksa (handling) try bloğu içerisinde yazılmalıdır. try bloğu catch bloğu
    veya blokları ya da tek başına finally bloğu veya catch blokları ve finally bloğu ile devam edebilir. Yani try
    bloğu tek başına olamaz. try bloğu tüm diğer blokları ile birlikte tek bir deyimdir (try statement). try bloğu ile
    birlikte bulunan diğer bloklar arasında herhangi bir deyim yazılmaz.

    catch bloğunun parantezi içerisinde yazılan parametreye catch parametresi denir. catch parametresine ilişkin türün
    Throwable sınıfından doğrudan ya da dolaylı olarak türetilmiş bir sınıf türünden olması gerekir.

    Exceptionm oluşursa (fırlatılırsa) akış try bloğundan bir daha geri dönmemek üzere (non-resumptive) catahc bloklarına
    sıçrar catch blokları yukarıdan aşağıya doğru switch deyimi teker teker kontrol edilir. Uygun catch bloğu bulunursa
    o catch bloğu çalıştırılır. Uygun bloğu fırlatılan exception nesnesinin adresinin atanabildiği türden parametreye
    sahip ilk catch bloğudur. Exception yakalanırsa yakalanan catch bloğunda ilişkin kodlar çalıştırılır. Kodlar bitince
    tüm diğer catch blokları atlanarak akış devam eder. Eğer exception yakalanırsa, yakalanan catch bloğuna ilişkin
    kodlar çalıştırılır. Kodlar bitince tüm diğer catch blokları atlanarak akış devam eder. Eğer exception hiç yakalanmazsa
    akış sonlanır. Yani bir catch bloğu çalıştırılırsa aynı try deyimi içerisindenki diğer catch blokları çalıştırılmaz.
    try bloğu hiç exception oluşmadan sonlanırsa tüm catch blokları atlanarak akış devam eder
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte fırlatılan MathException sınıfı doğrudan ya da dolaylı olarak Throwable sınıfından türetilmediği
	için error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class MathUtil {
	public static double log10(double val)
	{
		if (val <= 0) {
			MathException ex = new MathException();

			throw ex; //error
		}

		return Math.log10(val);
	}
}

class MathException {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi düzenlenebilir. Örnekte throw işleminden sonra akış metodu terkedeceğinden if deyiminin
	else kısmına ihtiyaç yoktur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class MathUtil {
	public static double log10(double val)
	{
		if (val <= 0) {
			MathException ex = new MathException();

			throw ex;
		}

		return Math.log10(val);
	}
}

class MathException extends RuntimeException {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte parseDouble metodunun fırlattığı exception'ın yakalanamadığına dikkat ediniz. Kodu çeşitli
	değerlerle çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (IndeterminateException ex) {
			System.out.println("Belirsiz");
		}
		catch (UndefinedException ex) {
			System.out.println("Tanımsız");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new IndeterminateException();

		if (Math.abs(val - 0) < 0.0001)
			throw new UndefinedException();

		return Math.log10(val);
	}
}

class IndeterminateException extends RuntimeException {
	//...
}


class UndefinedException extends RuntimeException {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Taban sınıf parametreli catch bloğu o sınıftan türemiş olan sınıflara ilişkin exception nesnelerini yakalayabilir.
	Dikkat edilirse bu bir "upcasting" işlemidir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (MathException ex) {
			System.out.println("Belirsiz veya tanımsız");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new IndeterminateException();

		if (Math.abs(val - 0) < 0.0001)
			throw new UndefinedException();

		return Math.log10(val);
	}
}

class IndeterminateException extends MathException {
	//...
}


class UndefinedException extends MathException {
	//...
}

class MathException extends RuntimeException {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf parametreli catch bloğu taban sınıf parametreli catch bloğundan sonra yazılamaz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (MathException ex) {
			System.out.println("Belirsiz veya tanımsız");
		}
		catch (UndefinedException ex) { //error
			System.out.println("tanımsız");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new IndeterminateException();

		if (Math.abs(val - 0) < 0.0001)
			throw new UndefinedException();

		return Math.log10(val);
	}
}

class IndeterminateException extends MathException {
	//...
}


class UndefinedException extends MathException {
	//...
}

class MathException extends RuntimeException {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf parametreli catch bloğu taban sınıf parametreli catch bloğundan önce yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (UndefinedException ex) { //error
			System.out.println("tanımsız");
		}
		catch (MathException ex) {
			System.out.println("Belirsiz veya tanımsız");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new IndeterminateException();

		if (Math.abs(val - 0) < 0.0001)
			throw new UndefinedException();

		return Math.log10(val);
	}
}

class IndeterminateException extends MathException {
	//...
}


class UndefinedException extends MathException {
	//...
}

class MathException extends RuntimeException {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Throwable parametreli catch bloğu ile tüm fırlatılan exception nesneleri yakalanabilir. Şüphesiz Throwable parametreli
	catch bloğunun tüm catch bloklarından sonra yazılması gerekir. Aşağıdaki örnekte parseDouble metodunun fırlattığı
	exception Throwable ile yakalanmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (IndeterminateException ex) {
			System.out.println("Belirsiz");
		}
		catch (UndefinedException ex) {
			System.out.println("Tanımsız");
		}
		catch (Throwable ex) {
			System.out.println("Exception oluştu");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new IndeterminateException();

		if (Math.abs(val - 0) < 0.0001)
			throw new UndefinedException();

		return Math.log10(val);
	}
}

class IndeterminateException extends RuntimeException {
	//...
}


class UndefinedException extends RuntimeException {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir try bloğu içerisinde bir exception yakalanamazsa o try bloğunu kapsayan try bloğunun catch bloklarına bakılır.
	Bu işlem uygun catch bloğu bulununcaya veya bulunamayıncaya kadar devam eder. Bulunursa, catch bloğu çalıştırılır,
	bulunamazsa akış sonlanır. Eğer bir exception try bloğu içerisinde yakalanmışisa kapsayan try bloklarının catch bloklarına
	bakılmaz. Aşağıdaki çeşitli değerlerle çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Util.doWork();
		}
		catch (UndefinedException ex) {
			System.out.println("Tanımsız");
		}
		catch (Throwable ex) {
			System.out.println("Exception oluştu");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void doWork()
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (IndeterminateException ex) {
			System.out.println("doWork:Belirsiz");
		}

		System.out.println("doWork sonu");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new IndeterminateException();

		if (Math.abs(val - 0) < 0.0001)
			throw new UndefinedException();

		return Math.log10(val);
	}
}

class IndeterminateException extends RuntimeException {
	//...
}


class UndefinedException extends RuntimeException {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte doWork metodu IndeterminateException fırlatıldığında onu yakalamış ve aynı nesneyi yeniden
	fırlatmıştır. Bu işleme "rethrow" denir.

	Aşağıdaki örnekte doWork metodunun müşteri kodları açısından IndeterminateException da fırlatılabilir. Bu doWork için
	dökumana yazılır. doWork metodunu yazan programcı açısından ise IndeterminateException hem ilgili try deyiminde
	işlenmiş hem de aynı exception nesnesi müşteri koda fırlatılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Util.doWork();
		}
		catch (IndeterminateException ex) {
			System.out.println("Belirsiz");
		}
		catch (UndefinedException ex) {
			System.out.println("Tanımsız");
		}
		catch (Throwable ex) {
			System.out.println("Exception oluştu");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void doWork()
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (IndeterminateException ex) {
			System.out.println("doWork:Belirsiz");
			throw ex; //rethrow
		}

		System.out.println("doWork sonu");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new IndeterminateException();

		if (Math.abs(val - 0) < 0.0001)
			throw new UndefinedException();

		return Math.log10(val);
	}
}

class IndeterminateException extends RuntimeException {
	//...
}


class UndefinedException extends RuntimeException {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	finally bloğu try deyiminden nasıl çıkılırsa çıkılsın çalıştırılacak bloktur. finally bloğu catch blokları
	ile birlikte olacaksa tüm catch bloklarının sonunda olmalıdır. Aşağıdaki örneği çeşitli değerler ile çalıştırarak
	sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Util.doWork();
		}
		catch (IndeterminateException ex) {
			System.out.println("Belirsiz");
		}
		catch (UndefinedException ex) {
			System.out.println("Tanımsız");
		}
		finally {
			System.out.println("main:finally");
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void doWork()
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (IndeterminateException ex) {
			System.out.println("doWork:Belirsiz");
			throw ex;
		}
		finally {
			System.out.println("doWork:finally");
		}

		System.out.println("doWork sonu");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new IndeterminateException();

		if (Math.abs(val - 0) < 0.0001)
			throw new UndefinedException();

		return Math.log10(val);
	}
}

class IndeterminateException extends RuntimeException {
	//...
}


class UndefinedException extends RuntimeException {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	02.08.2024
	Aşağıdaki örnekte return değilmeden önce try yazısı ekleneceğinden exceptiontryfinally biçiminde olur. Örnekte durumun
	anlaşılması için MutableString sınıfı yazılmıştır. Sınıf daha iyi yazılabilir. Sadece soruya odaklanmanız önerilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		System.out.println(Sample.doWork("exception")); //exceptiontryfinally
	}
}

class Sample {
	public static MutableString doWork(String str)
	{
		MutableString result = new MutableString(str);

		try {
			return result.append("try");
		}
		finally {
			result.append("finally");
		}
	}
}

class MutableString {
	private String m_str;

	public MutableString(String str)
	{
		m_str = str;
	}

	public void setStr(String str)
	{
		m_str = str;
	}

	//...

	public MutableString append(String str)
	{
		m_str += str;

		return this;
	}

	public String toString()
	{
		return m_str;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		System.out.println(Sample.doWork("exception")); //exceptiontry
	}
}

class Sample {
	public static String doWork(String str)
	{
		String result = str;

		try {
			return result += "try";
		}
		finally {
			result += "finally";
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		System.out.println(Sample.doWork("exception")); //exceptiontry
	}
}

class Sample {
	public static String doWork(String str)
	{
		MutableString result = new MutableString(str);

		try {
			return result.append("try").toString();
		}
		finally {
			result.append("finally");
			System.out.printf("result:%s%n", result);
		}
	}
}

class MutableString {
	private String m_str;

	public MutableString(String str)
	{
		m_str = str;
	}

	public void setStr(String str)
	{
		m_str = str;
	}

	//...

	public MutableString append(String str)
	{
		m_str += str;

		return this;
	}

	public String toString()
	{
		return m_str;
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Console sınıfı ve test kodu: writeXXX metotlarının nasıl bildirildiğininn şu an önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	public static void main(String [] args)
	{
		int a = Console.readInt("Bir sayı giriniz:", "Hatalı sayı girdiniz!...");

		Console.writeLine("a = %d", a);
		Console.writeLine("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Console sınıfı ve test kodu: writeXXX metotlarının nasıl bildirildiğininn şu an önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	public static void main(String [] args)
	{
		double a = Console.readDouble("Bir sayı giriniz:", "Hatalı sayı girdiniz!...");

		Console.writeLine("a = %f", a);
		Console.writeLine("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Console sınıfı ve test kodu: writeXXX metotlarının nasıl bildirildiğininn şu an önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	public static void main(String [] args)
	{
		long a = Console.readLong("Bir sayı giriniz:", "Hatalı sayı girdiniz!...");

		Console.writeLine("a = %d", a);
		Console.writeLine("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------
	FILE        : Console.java
	AUTHOR      : Java-Feb-2022 Group
	LAST UPDATE : 02.10.2022

	Utility Console class for standard input and output operations

	Copyleft (c) 1993 by C and System Programmers Association (CSD)
	All Rights Free
-----------------------------------------------------------------------*/
package com.orhn.util.console;

import java.util.Scanner;

public final class Console {
    private static final Scanner ms_kb = new Scanner(System.in);
    private Console()
    {
    }

    public static int readInt()
    {
        return readInt("");
    }

    public static int readInt(String message)
    {
        return readInt(message, "");
    }

    public static int readInt(String message, String errMessage)
    {
        for (;;) {
            try {
                System.out.print(message);

                return Integer.parseInt(ms_kb.nextLine());
            }
            catch (NumberFormatException ignore) {
                System.out.print(errMessage);
            }
        }
    }


    public static double readDouble()
    {
        return readDouble("");
    }

    public static double readDouble(String message)
    {
        return readDouble(message, "");
    }

    public static double readDouble(String message, String errMessage)
    {
        for (;;) {
            try {
                System.out.print(message);

                return Double.parseDouble(ms_kb.nextLine());
            }
            catch (NumberFormatException ignore) {
                System.out.print(errMessage);
            }
        }
    }


    public static long readLong()
    {
        return readLong("");
    }

    public static long readLong(String message)
    {
        return readLong(message, "");
    }

    public static long readLong(String message, String errMessage)
    {
        for (;;) {
            try {
                System.out.print(message);

                return Long.parseLong(ms_kb.nextLine());
            }
            catch (NumberFormatException ignore) {
                System.out.print(errMessage);
            }
        }
    }

    //...

    public static void write(String fmt, Object...objects)
    {
        System.out.printf(fmt, objects);
    }

    public static void writeLine(String fmt, Object...objects)
    {
        write(fmt + "\n", objects);
    }

    public static void writeLine()
    {
        writeLine("\n");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Exception sınıfları içerisinde tutulan elemanlar ile bilgi taşınabilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (MathException ex) {
			System.out.println(ex.getMessage());
			System.out.println(ex.getStatus());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new MathException("Indeterminate", MathExceptionStatus.INDETERMINATE);

		if (Math.abs(val - 0) < 0.0001)
			throw new MathException("Undefined", MathExceptionStatus.UNDEFINED);

		return Math.log10(val);
	}
}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends RuntimeException {
	private final String m_message;
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		m_message = message;
		m_status = status;
	}

	public String getMessage()
	{
		return m_message;
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Throwable sınıfı içerisinde exception işlemlerine yönelik bir takım veri elemanları bulunmaktadır. Bunlardan
	en tipik olanı mesaja karşılık gelen String türden olanıdır. Throwable sınıfından türetilmiş olan sınıflar yani
	exception sınıfları genel olarak String parametreli ctor'u yazarlar. Böylelikle hiyerarşik olarak mesaj Throwable
	sınıfına iletilmiş olur. İsterse programcı başka bilgileri de yazdığı exception sınıfına ekleyebilir. Throwable sınıfının
	getMessage metodu ile mesaj bilgisi elde edilebilir. getMessage metodu sanal bir metottur. Dolayısıyla override edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (MathException ex) {
			System.out.println(ex.getMessage());
			System.out.println(ex.getStatus());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new MathException("Indeterminate", MathExceptionStatus.INDETERMINATE);

		if (Math.abs(val - 0) < 0.0001)
			throw new MathException("Undefined", MathExceptionStatus.UNDEFINED);

		return Math.log10(val);
	}
}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends RuntimeException {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte fırlatılması durumunda MathException sınıfının getMessage metodunun çağrıldığına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new MathException("Indeterminate", MathExceptionStatus.INDETERMINATE);

		if (Math.abs(val - 0) < 0.0001)
			throw new MathException("Undefined", MathExceptionStatus.UNDEFINED);

		return Math.log10(val);
	}
}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends RuntimeException {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Throwable sınıfının parametresiz printStackTrace metodu exception fırlatılması noktalarını stack biçiminde gösteren
	detaylı mesajı ekrana basar. Bu metotta basılan yazı akış exception yakalanmadığından dolayı sonlandığında da basılan
	yazı ile neredeyse aynıdır. Bu metot da gerekirse override edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (Throwable ex) {
			ex.printStackTrace();
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new MathException("Indeterminate", MathExceptionStatus.INDETERMINATE);

		if (Math.abs(val - 0) < 0.0001)
			throw new MathException("Undefined", MathExceptionStatus.UNDEFINED);

		return Math.log10(val);
	}
}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends RuntimeException {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Throwable sınıfının içerisinde Thrpwable türünden bir referans tutulur. Bu referans bir exception içerisinde başka
	başka bir referansının taşınabilmesini sağlar. getCause metodu ile içsel olarak tutulan exception referansı Throwable
	türünden elde edilir. Ayrıca Throwable sınıfının Throble paranmetresi de alanb ctor'u ile bu bilgisi nesneye verilebilir.
	Cause exception'ın anlamı ileride ele alınacaktır. Aşağıdaki örnek bir kullanımına ilişkin demo olarak düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Sample.doWork();
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
			Throwable cause = ex.getCause();

			if (cause instanceof NumberFormatException)
				System.out.printf("Cause Message:%s%n", cause.getMessage());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Sample {
	public static void doWork()
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (Throwable ex) {
			//...
			throw new WrapperException("doWork", ex);
		}
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new MathException("Indeterminate", MathExceptionStatus.INDETERMINATE);

		if (Math.abs(val - 0) < 0.0001)
			throw new MathException("Undefined", MathExceptionStatus.UNDEFINED);

		return Math.log10(val);
	}
}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends RuntimeException {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

class WrapperException extends RuntimeException {
	public WrapperException(String message)
	{
		super(message);
	}

	public WrapperException(String message, Throwable cause)
	{
		super(message, cause);
	}

	public String getMessage()
	{
		Throwable cause = getCause();

		return String.format("Message:%s%s", super.getMessage(), cause != null ? ", Cause Message:" + cause.getMessage() : "");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Throwable sınıfının içerisinde Thrpwable türünden bir referans tutulur. Bu referans bir exception içerisinde başka
	başka bir referansının taşınabilmesini sağlar. getCause metodu ile içsel olarak tutulan exception referansı Throwable
	türünden elde edilir. Ayrıca Throwable sınıfının Throwable paranmetresi de alan ctor'u ile bu bilgisi nesneye verilebilir.
	Cause exception'ın anlamı ileride ele alınacaktır. Aşağıdaki örnek bir kullanımına ilişkin demo olarak düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Sample.doWork();
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
			Throwable cause = ex.getCause();

			if (cause instanceof NumberFormatException)
				System.out.printf("Cause Message:%s%n", cause.getMessage());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Sample {
	public static void doWork()
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (Throwable ex) {
			//...
			throw new WrapperException("doWork", ex);
		}
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new MathException("Indeterminate", MathExceptionStatus.INDETERMINATE);

		if (Math.abs(val - 0) < 0.0001)
			throw new MathException("Undefined", MathExceptionStatus.UNDEFINED);

		return Math.log10(val);
	}
}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends RuntimeException {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

class WrapperException extends RuntimeException {
	public WrapperException(String message)
	{
		super(message);
	}

	public WrapperException(String message, Throwable cause)
	{
		super(message, cause);
	}

	public String getMessage()
	{
		Throwable cause = getCause();

		return String.format("Message:%s%s", super.getMessage(), cause != null ? ", Cause Message:" + cause.getMessage() : "");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Throwable sınıfının içerisinde Thrpwable türünden bir referans tutulur. Bu referans bir exception içerisinde başka
	başka bir referansının taşınabilmesini sağlar. getCause metodu ile içsel olarak tutulan exception referansı Throwable
	türünden elde edilir. Ayrıca Throwable sınıfının Throwable paranmetresi de alan ctor'u ile bu bilgisi nesneye verilebilir.
	Cause exception'ın anlamı ileride ele alınacaktır. Aşağıdaki örnek bir kullanımına ilişkin demo olarak düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Sample.doWork();
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
			Throwable cause = ex.getCause();

			if (cause instanceof NumberFormatException)
				System.out.printf("Cause Message:%s%n", cause.getMessage());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Sample {
	public static void doWork()
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (Throwable ex) {
			//...
			throw new WrapperException("doWork", ex);
		}
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new MathException("Indeterminate", MathExceptionStatus.INDETERMINATE);

		if (Math.abs(val - 0) < 0.0001)
			throw new MathException("Undefined", MathExceptionStatus.UNDEFINED);

		return Math.log10(val);
	}
}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends RuntimeException {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

class WrapperException extends RuntimeException {
	public WrapperException(String message)
	{
		super(message);
	}

	public WrapperException(String message, Throwable cause)
	{
		super(message, cause);
	}

	public String getMessage()
	{
		Throwable cause = getCause();

		return String.format("Message:%s%s", super.getMessage(), cause != null ? ", Cause Message:" + cause.getMessage() : "");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da exception sınıfları kategori olarak iki gruba ayrılır: checked, unchecked

	unchecked exception sınıfları: Bir exception sınıfının türetme hiyerarşisi içerisinde Error sınıfı veya RuntimeException
	sınıfı varsa unchecked exception sınıfıdır

	checked exception sınıfları: unchecked olmayan exception sınıflarıdır

	Anahtar Notlar: Bir exception sınıfının unchecked veya checked olmasının çalışma zamanı açısından bir farkı yoktur.
	Yani exception sınıfları için zamanı durumu aynıdır. Bir sınıfın checked exception sınıfı olması derleme zamanında bazı
	özellikleri (detayları) beraberinde getirir.

	Anahtar Notlar: Exception sınıflarının yazımında geleneksel olarak Throwable sınıfından doğrudan türetme yapılmaz

	Anahtar Notlar: Türetme kavramı dolayısıyla bir exception sınıfından türetilen bir başka exception sınıf kategori
	olarak taban sınıfı ile aynıdır. Yani taban sınıfı checked kendisi de checked bir exception sınıfıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	checked bir exception throw edilen metot içerisinde eğer exception ele alınmayacaksa (handling) throws bildirimi
	yapılmalıdır. Aksi durumda error oluşur. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (Throwable ex) {
			ex.printStackTrace();
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val) throws MathException
	{
		if (val < 0)
			throw new MathException("Indeterminate", MathExceptionStatus.INDETERMINATE);

		if (Math.abs(val - 0) < 0.0001)
			throw new MathException("Undefined", MathExceptionStatus.UNDEFINED);

		return Math.log10(val);
	}
}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends Exception {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	05.08.2024
	Birden fazla checked exception forlatılması durumunda exception sınıfları arasında doğrudan ya da dolaylı olarak
	kalıtım ilişkisi yoksa hepsi throws listesine yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try {
			Scanner kb = new Scanner(System.in);
			System.out.print("Bir sayı giriniz:");
			double val = Double.parseDouble(kb.nextLine());
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (Throwable ex) {
			ex.printStackTrace();
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val) throws ZeroException, NegativeException
	{
		if (val < 0)
			throw new NegativeException("Indeterminate");

		if (Math.abs(val - 0) < 0.0001)
			throw new ZeroException("Undefined");


		return Math.log10(val);
	}
}


class ZeroException extends MathException {
	public ZeroException(String message)
	{
		super(message, MathExceptionStatus.ZERO);
	}

	public String getMessage()
	{
		return String.format("ZeroException:%s", super.getMessage());
	}
}

class NegativeException extends MathException {
	public NegativeException(String message)
	{
		super(message, MathExceptionStatus.NEGATIVE);
	}

	public String getMessage()
	{
		return String.format("NegativeException:%s", super.getMessage());
	}

}


enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends Exception {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	checked exception fırlatma ihtimali olan bir akışın throws bildirimi yapılmayaxcaksa try bloğu içerisinde olması
	ve fırlatma ihtimali olan checked exception'ları yakalayabilecek catch bloklarının var olması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	public static void main(String [] args)
	{
		try {
			double val = Console.readDouble("Bir sayı giriniz:");
			double result = MathUtil.log10(val); //error

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (NegativeException ex) {
			ex.printStackTrace();
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val) throws ZeroException, NegativeException
	{
		if (val < 0)
			throw new NegativeException("Indeterminate");

		if (Math.abs(val - 0) < 0.0001)
			throw new ZeroException("Undefined");


		return Math.log10(val);
	}
}

class ZeroException extends MathException {
	public ZeroException(String message)
	{
		super(message, MathExceptionStatus.ZERO);
	}

	public String getMessage()
	{
		return String.format("ZeroException:%s", super.getMessage());
	}
}

class NegativeException extends MathException {
	public NegativeException(String message)
	{
		super(message, MathExceptionStatus.NEGATIVE);
	}

	public String getMessage()
	{
		return String.format("NegativeException:%s", super.getMessage());
	}
}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends Exception {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	checked exception sınıfı türünden parametreli bir catch bloğunun ait olduğu try bloğunda o checked exception türüne
	ilişkin nesneyi fırlatabilecek bir akış bulunmalıdır. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		try {
			//...
		}
		catch (NegativeException ex) { //error
			ex.printStackTrace();
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val) throws ZeroException, NegativeException
	{
		if (val < 0)
			throw new NegativeException("Indeterminate");

		if (Math.abs(val - 0) < 0.0001)
			throw new ZeroException("Undefined");


		return Math.log10(val);
	}
}


class ZeroException extends MathException {
	public ZeroException(String message)
	{
		super(message, MathExceptionStatus.ZERO);
	}

	public String getMessage()
	{
		return String.format("ZeroException:%s", super.getMessage());
	}
}

class NegativeException extends MathException {
	public NegativeException(String message)
	{
		super(message, MathExceptionStatus.NEGATIVE);
	}

	public String getMessage()
	{
		return String.format("NegativeException:%s", super.getMessage());
	}

}

enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends Exception {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kural Exception ve Throwable sınıfları için geçerli değildir. Halbuki bu sınıflar da checked exception
	kategorisindedir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		try {
			//...
		}
		catch (Exception ex) {
			//...
		}
		catch (Throwable ex) {
			//...
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val) throws ZeroException, NegativeException
	{
		if (val < 0)
			throw new NegativeException("Indeterminate");

		if (Math.abs(val - 0) < 0.0001)
			throw new ZeroException("Undefined");


		return Math.log10(val);
	}
}


class ZeroException extends MathException {
	public ZeroException(String message)
	{
		super(message, MathExceptionStatus.ZERO);
	}

	public String getMessage()
	{
		return String.format("ZeroException:%s", super.getMessage());
	}
}

class NegativeException extends MathException {
	public NegativeException(String message)
	{
		super(message, MathExceptionStatus.NEGATIVE);
	}

	public String getMessage()
	{
		return String.format("NegativeException:%s", super.getMessage());
	}

}


enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends Exception {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	throws listesine fırlatılan exception'ların doğrudan ya da dolaylı taban sınıfları yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	public static void main(String [] args)
	{
		try {
			double val = Console.readDouble("Bir sayı giriniz:");
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (MathException ex) {
			Console.writeLine("%s", ex.getMessage());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val) throws MathException
	{
		if (val < 0)
			throw new NegativeException("Indeterminate");

		if (Math.abs(val - 0) < 0.0001)
			throw new ZeroException("Undefined");

		return Math.log10(val);
	}
}


class ZeroException extends MathException {
	public ZeroException(String message)
	{
		super(message, MathExceptionStatus.ZERO);
	}

	public String getMessage()
	{
		return String.format("ZeroException:%s", super.getMessage());
	}
}

class NegativeException extends MathException {
	public NegativeException(String message)
	{
		super(message, MathExceptionStatus.NEGATIVE);
	}

	public String getMessage()
	{
		return String.format("NegativeException:%s", super.getMessage());
	}

}


enum MathExceptionStatus {
	ZERO, NEGATIVE, UNDEFINED, INDETERMINATE, NAN
}

class MathException extends Exception {
	private final MathExceptionStatus m_status;

	public MathException(String message, MathExceptionStatus status)
	{
		super(message);
		m_status = status;
	}

	public String getMessage()
	{
		return String.format("Message:%s, Status:%s", super.getMessage(), m_status);
	}

	public MathExceptionStatus getStatus()
	{
		return m_status;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	throws bildirimi olan sanal bir metodun override edilmesi durumunda override edilen metotta throws listesinde olan
	exception sınıfları kaldırılabilir. Yani örneğin hiç throws listesi yazılmayabilir. override edikle nmetotta throws
	listesinden veya onlardan doğrudan ya da dolaylı olarak türetilmiş exception sınıfları bulunabilir. Aksi durumda
	error oluşur. Aşağıdaki örnekte yukarıdaki problemden dolayı T sınıfında foo metodunu override eden programcı
	yönetimini değiştirmelidir. Örnekte Sample ve X sınıflarının değiştirilemeyeceğini varsayınız
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{

	}
}

class Sample {
	public static void doWork() throws TheirException
	{
		//....
	}
}

class T extends X {
	public void foo() throws TheirException //Error
	{
		Sample.doWork();
	}
}

class Z extends X {
	public void foo() throws MyException
	{
		//...
	}
}

class Y extends X {
	public void foo()
	{
		//...
	}
}

abstract class X {
	public abstract void foo() throws MyException, YourException;
}

class MyException extends Exception {
	//...
}

class YourException extends Exception {
	//...
}

class OurException extends MyException {
	//...
}

class TheirException extends Exception {
	//...
}



/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem aşağıdaki gibi çözülebilir. Aşağıdaki örnekte unchecked exception nesnesi içerisinde checked bir
	exception referansı tutulmuştur (cause). Bu çözüm override edilen metoda ilişkin sınıfı biz tasarlamadığımızda
	daha çok karşımıza çıkar
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class Sample {
	public static void doWork() throws TheirException
	{
		//....
	}
}

class T extends X {
	public void foo()
	{
		try {
			Sample.doWork();
		}
		catch (TheirException ex) {
			throw new WrapperException(ex.getMessage(), ex);
		}
	}
}

class Z extends X {
	public void foo() throws MyException
	{
		//...
	}
}

class Y extends X {
	public void foo()
	{
		//...
	}
}

abstract class X {
	public abstract void foo() throws MyException, YourException;
}

class MyException extends Exception {
	//...
}

class YourException extends Exception {
	//...
}

class OurException extends MyException {
	//...
}

class TheirException extends Exception {
	//...
}

class WrapperException extends RuntimeException {
	public WrapperException(String message)
	{
		super(message);
	}

	public WrapperException(String message, Throwable cause)
	{
		super(message, cause);
	}

	public String getMessage()
	{
		Throwable cause = getCause();

		return String.format("Message:%s%s", super.getMessage(), cause != null ? ", Cause Message:" + cause.getMessage() : "");
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem abstract metodun çok genel bir kullanımı olabilecekse aşağıdaki gibi abstract metodun
	bildiriminde "throws Exception" eklenerek çözülebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class Sample {
	public static void doWork() throws TheirException
	{
		//....
	}
}

class T extends X {
	public void foo() throws TheirException
	{
		Sample.doWork();
	}
}

class Z extends X {
	public void foo() throws MyException, YourException
	{
		//...
	}
}

class Y extends X {
	public void foo()
	{
		//...
	}
}

abstract class X {
	public abstract void foo() throws Exception;
}

class MyException extends Exception {
	//...
}

class YourException extends Exception {
	//...
}

class OurException extends MyException {
	//...
}

class TheirException extends Exception {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: NullPointerException içerisinde null olan bir referansa ilikin türün elemanlarına erişim yapıldığında
    fırlatılan önemli bir exception sınıfıdır. Bu exception uygulama içerisinde "handle" edilecek bir exception olarak
    düşünülmemelidir. Bu exception'ın fırlatıldığı durum ortadan kaldırılmalıdır. Hatta gerekirse başka bir exception
    fırlatılmalıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte birden fazla exception için ortak bir iş yapılacaksa | atomu kullanılarak catch bloğu oluşturulabilir.
	Bu catch bloğu içerisinde birden fazla olan sınıfların ancak ortak elemanları kullanılabilir. Bu şekilde kullanılan
	exception sınıflarının aralarında türetme ilişkisi olmaması gerekir. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	public static void main(String [] args)
	{
		try {
			double val = Console.readDouble("Bir sayı giriniz:");
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (ZeroException | NegativeException ex) {
			Console.writeLine("Zero or Negative:%s", ex.getMessage());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new NegativeException("Indeterminate");

		if (Math.abs(val - 0) < 0.0001)
			throw new ZeroException("Undefined");

		return Math.log10(val);
	}
}


class ZeroException extends RuntimeException {
	public ZeroException(String message)
	{
		super(message);
	}

	public String getMessage()
	{
		return String.format("ZeroException:%s", super.getMessage());
	}
}

class NegativeException extends RuntimeException {
	public NegativeException(String message)
	{
		super(message);
	}

	public String getMessage()
	{
		return String.format("NegativeException:%s", super.getMessage());
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte birleştirilen exception sınıfları arasında türetme ilişkisi olduğundan error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	public static void main(String [] args)
	{
		try {
			double val = Console.readDouble("Bir sayı giriniz:");
			double result = MathUtil.log10(val);

			System.out.printf("log10(%f) = %f%n", val, result);
		}
		catch (ZeroException | NegativeException ex) { //error
			Console.writeLine("Zero or Negative:%s", ex.getMessage());
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class MathUtil {
	public static double log10(double val)
	{
		if (val < 0)
			throw new NegativeException("Indeterminate");

		if (Math.abs(val - 0) < 0.0001)
			throw new ZeroException("Undefined");

		return Math.log10(val);
	}
}


class ZeroException extends NegativeException {
	public ZeroException(String message)
	{
		super(message);
	}

	public String getMessage()
	{
		return String.format("ZeroException:%s", super.getMessage());
	}
}

class NegativeException extends RuntimeException {
	public NegativeException(String message)
	{
		super(message);
	}

	public String getMessage()
	{
		return String.format("NegativeException:%s", super.getMessage());
	}
}



/*----------------------------------------------------------------------
	FILE        : CSDArrayList.java
	AUTHOR      : Java-Feb-2022 Group
	LAST UPDATE : 17.09.2022

	CSDArrayList class

	Copyleft (c) 1993 by C and System Programmers Association (CSD)
	All Rights Free
-----------------------------------------------------------------------*/



package com.orhn.util.collection;

public class CSDArrayList {
    private static final int DEFAULT_CAPACITY = 10;
    private Object [] m_elems;
    private int m_index;

    private static void doWorkForIllegalArgumentException(String message)
    {
        throw new IllegalArgumentException(message);
    }

    private static void doWorkForIndexOutOfBoundException(String message)
    {
        throw new IndexOutOfBoundsException(message);
    }

    private static void checkCapacity(int capacity)
    {
        if (capacity < 0)
            doWorkForIllegalArgumentException("Capacity value can not be negative:" + capacity);
    }

    private void checkIndex(int index)
    {
        if (index < 0 || index >= m_index)
            doWorkForIndexOutOfBoundException("Index out of range:" + index);
    }

    private void changeCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        System.arraycopy(m_elems, 0, temp, 0, m_index);
        m_elems = temp;
    }

    private void enlargeCapacityIfNecessary()
    {
        if (m_elems.length == m_index)
            changeCapacity(m_elems.length == 0 ? 1 : m_elems.length * 2);
    }

    public CSDArrayList()
    {
        m_elems = new Object[DEFAULT_CAPACITY];
    }

    public CSDArrayList(int initialCapacity)
    {
        checkCapacity(initialCapacity);
        m_elems = new Object[initialCapacity];
    }

    public boolean add(Object elem)
    {
        enlargeCapacityIfNecessary();

        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, Object elem)
    {
        enlargeCapacityIfNecessary();

        for (int i = m_index++; i > index; --i)
            m_elems[i] = m_elems[i - 1];

        m_elems[index] = elem;
    }

    public int capacity()
    {
        return m_elems.length;
    }

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public void ensureCapacity(int minCapacity)
    {
        if (minCapacity > m_elems.length)
            changeCapacity(Math.max(m_elems.length * 2, minCapacity));
    }

    public Object get(int index)
    {
        checkIndex(index);

        return m_elems[index];
    }

    public boolean isEmpty()
    {
        return m_index == 0;
    }

    public Object remove(int index)
    {
        checkIndex(index);
        Object oldElem = m_elems[index];

        for (int i = index; i < m_index - 1; ++i)
            m_elems[i] = m_elems[i + 1];

        m_elems[--m_index] = null;

        return oldElem;
    }

    public Object set(int index, Object elem)
    {
        checkIndex(index);
        Object oldElem = m_elems[index];

        m_elems[index] = elem;

        return oldElem;
    }

    public int size()
    {
        return m_index;
    }

    public void trimToSize()
    {
        if (m_index != m_elems.length)
            changeCapacity(m_index);
    }

    public String toString()
    {
        //TODO:
        return "[]";
    }

    //...
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli metodu yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden
		elde edilen kalan ile belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ..., 6 ise "cumartesi"
		günlerine karşılık gelir

		- 1.1.1900 öncesindeki tarihler geçersiz sayılacaktır
		- getDayOfWeek metodu ile birlikte

		- İleride daha iyisi yazılacaktır parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin
		hafta sonu olup olmadığınıu test eden isWeekend ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız.
		Bu iki metot tarih geçerlilik kontrolü yapmayacaktır

		- İleride daha yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

import com.orhn.util.datetime.DateApp;

class App {
	public static void main(String [] args)
	{
		DateApp.run();
	}
}


package com.orhn.util.datetime;

public class DateApp {

    private static void printDateTR(int day, int month, int year)
    {
        try {
            Date d = new Date(day, month, year);

            System.out.println(d.toLongDateStringTR());
            System.out.println(d.isWeekend() ? "Bugün kurs var. Tekrar yaptınız mı?" : "Kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız!...");
        }
        catch (DateTimeException ignore) {
            System.out.println("Geçersiz değerler");
        }
    }

    private static void printDateEN(int day, int month, int year)
    {
        try {
            Date d = new Date(day, month, year);

            System.out.println(d.toLongDateStringEN());
            System.out.println(d.isWeekend() ? "That is the course day. Did you review?" : "Course day is coming. Do not forget to review!...");
        }
        catch (DateTimeException ignore) {
            System.out.println("Invalid values");
        }
    }
    public static void run()
    {
        java.util.Scanner kb = new java.util.Scanner(System.in);

        for (;;) {
            System.out.print("Gün ay ve yıl bilgilerini giriniz?");
            int day = kb.nextInt();
            int month = kb.nextInt();
            int year = kb.nextInt();

            if (day == 0)
                break;

            printDateTR(day, month, year);
            printDateEN(day, month, year);
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}


/***
 *  FILE            : Date.java
 *  AUTHOR          : Orhan ÖZTÜRK
 *  LAST UPDATE     : 18.05.2023
 *
 *  Date class that represents a local date
 *
 *  Copyleft(c) 1992 by Orhan OZTURK All Rights Free
 */

package com.orhn.util.datetime;

import java.time.LocalDate;

import static com.orhn.util.datetime.DateUtil.DAY_OF_WEEKS;
import static com.orhn.util.datetime.DateUtil.MONTHS;

public class Date {
    private static final String [] MONTHS_TR = {"", "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz",
            "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"};

    private static final String [] DAYS_OF_WEEK_TR = {"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};

    private static final String [] MONTHS_EN = {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    private static final String [] DAYS_OF_WEEK_EN = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

    private static int getDayOfYear(int day, int month, int year)
    {
        int totalDays = day;

        for (int m = month - 1; m >= 1; --m)
            totalDays += MONTHS[m - 1].getDays(year);

        return totalDays;
    }

    private static int getDayOfWeek(int day, int month, int year)
    {
        int totalDays = getDayOfYear(day, month, year);

        for (int y = 1900; y < year; ++y)
            totalDays += Month.isLeapYear(y) ? 366 : 365;

        return totalDays % 7;
    }

    private static String getDaySuffix(int day)
    {
        return switch (day) {
            case 1, 21, 31 -> "st";
            case 2, 22 -> "nd";
            case 3, 23 -> "rd";
            default -> "th";
        };
    }

    private static boolean isValidDate(int day, int month, int year)
    {
        return  1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= MONTHS[month - 1].getDays(year);
    }

    private static void doWorkForException(String message)
    {
        throw new DateTimeException(message);
    }

    private static void checkDate(int day, int month, int year, String message)
    {
        if (!isValidDate(day, month, year))
            doWorkForException(message);
    }

    private void checkDay(int day, String message)
    {
        checkDate(day, m_month, m_year, message);
    }

    private void checkMonth(int month, String message)
    {
        checkDate(m_day, month, m_year, message);
    }

    private void checkYear(int year, String message)
    {
        checkDate(m_day, m_month, year, message);
    }

    private void set(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
        m_dayOfWeek = getDayOfWeek(m_day, m_month, m_year);
    }

    private int m_day, m_month, m_year;
    private int m_dayOfWeek;

    public Date() //Bu ctor içerisinde yazılanların bilinmesi gerekmez. Sadece default'un anlamına odaklanınız
    {
        LocalDate today = LocalDate.now();

        set(today.getDayOfMonth(), today.getMonthValue(), today.getYear());
    }

    public Date(int day, Month month, int year)
    {
        this(day, month.ordinal() + 1, year);
    }

    public Date(int day, int month, int year)
    {
        checkDate(day, month, year, String.format("Invalid date value(s) -> day: %d, month value: %d, year: %d", day, month, year));
        set(day, month, year);
    }

    public int getDay()
    {
        return m_day;
    }

    public void setDay(int day)
    {
        if (m_day == day)
            return;

        checkDay(day, "Invalid day value:" + day);
        set(day, m_month, m_year);
    }

    public Month getMonth()
    {
        return MONTHS[m_month - 1];
    }

    public void setMonth(Month month)
    {
        setMonthValue(month.ordinal() + 1);
    }

    public int getMonthValue()
    {
        return m_month;
    }

    public void setMonthValue(int month)
    {
        if (m_month == month)
            return;

        checkMonth(month, "Invalid month value:" + month);
        set(m_day, month, m_year);
    }

    public int getYear()
    {
        return m_year;
    }

    public void setYear(int year)
    {
        if (m_year == year)
            return;

        checkYear(year, "Invalid year value:" + year);
        set(m_day, m_month, year);
    }

    public DayOfWeek getDayOfWeek()
    {
        return DAY_OF_WEEKS[m_dayOfWeek];
    }

    public String getDayOfWeekTR()
    {
        return DAYS_OF_WEEK_TR[m_dayOfWeek];
    }

    public String getDayOfWeekEN()
    {
        return DAYS_OF_WEEK_EN[m_dayOfWeek];
    }

    public boolean isLeapYear()
    {
        return Month.isLeapYear(m_year);
    }

    public boolean isWeekend()
    {
        return m_dayOfWeek == 0 || m_dayOfWeek == 6;
    }

    public boolean isWeekday()
    {
        return !isWeekend();
    }

    public String toString()
    {
        return toString('/');
    }

    public String toString(char delimiter)
    {
        return String.format("%02d%c%02d%c%04d", m_day, delimiter, m_month, delimiter, m_year);
    }

    public String toLongDateStringTR()
    {
        return String.format("%s %s", toShortDateStringTR(), getDayOfWeekTR());
    }

    public String toLongDateStringEN()
    {
        return String.format("%s %s", toShortDateStringEN(), getDayOfWeekEN());
    }

    public String toShortDateStringTR()
    {
        return String.format("%d %s %d", m_day, MONTHS_TR[m_month], m_year);
    }

    public String toShortDateStringEN()
    {
        return String.format("%d%s %s %d", m_day, getDaySuffix(m_day), MONTHS_EN[m_month], m_year);
    }
}


/***
 *  FILE            : Time.java
 *  AUTHOR          : Orhan ÖZTÜRK
 *  LAST UPDATE     : 25.05.2023
 *
 *  Time class that represents a local time
 *
 *  Copyleft(c) 1992 by Orhan OZTURK All Rights Free
 */

package com.orhn.util.datetime;

import java.time.LocalTime;

public class Time {
    private int m_hour, m_minute, m_second, m_millisecond;

    private static void doWorkForException(String message)
    {
        throw new DateTimeException(message);
    }

    private static boolean isValid(int value, int max)
    {
        return 0 <= value && value <= max;
    }

    private static boolean isValidHour(int hour)
    {
        return isValid(hour, 23);
    }

    private static boolean isValidMinute(int minute)
    {
        return isValid(minute, 59);
    }

    private static boolean isValidSecond(int second)
    {
        return isValid(second, 59);
    }

    private static boolean isValidMillisecond(int millisecond)
    {
        return isValid(millisecond, 999);
    }

    private static boolean isValidTime(int hour, int minute, int second, int millisecond)
    {
        return isValidHour(hour) && isValidMinute(minute) && isValidSecond(second) && isValidMillisecond(millisecond);
    }

    private static void checkHour(int value)
    {
        if (!isValidHour(value))
            doWorkForException("Invalid hour value -> " + value);
    }

    private static void checkMinute(int value)
    {
        if (!isValidMinute(value))
            doWorkForException("Invalid minute value -> " + value);
    }

    private static void checkSecond(int value)
    {
        if (!isValidSecond(value))
            doWorkForException("Invalid second value -> " + value);
    }

    private static void checkMillisecond(int value)
    {
        if (!isValidMillisecond(value))
            doWorkForException("Invalid millisecond value -> " + value);
    }

    private void checkTime(int hour, int minute, int second, int millisecond)
    {
        if (!isValidTime(hour, minute, second, millisecond))
            doWorkForException(String.format("Invalid time value(s): hour -> %d, minute -> %d, second -> %d, millisecond -> %d",
                    hour, minute, second, millisecond));
    }

    private void set(int hour, int minute, int second, int millisecond)
    {
        m_hour = hour;
        m_minute = minute;
        m_second = second;
        m_millisecond = millisecond;
    }

    public Time() //Bu ctor içerisinde yazılanların bilinmesi gerekmez. Sadece default ctor'un anlamına odaklanınız
    {
        LocalTime now = LocalTime.now();

        m_hour = now.getHour();
        m_minute = now.getMinute();
        m_second = now.getSecond();
        m_millisecond = now.getNano() / 1_000_000;
    }

    public Time(int hour, int minute)
    {
        this(hour, minute, 0);
    }

    public Time(int hour, int minute, int second)
    {
        this(hour, minute, second, 0);
    }

    public Time(int hour, int minute, int second, int millisecond)
    {
        checkTime(hour, minute, second, millisecond);
        set(hour, minute, second, millisecond);
    }

    public int getHour()
    {
        return m_hour;
    }

    public void setHour(int hour)
    {
        if (hour == m_hour)
            return;

        checkHour(hour);
        m_hour = hour;
    }

    public int getMinute()
    {
        return m_minute;
    }

    public void setMinute(int minute)
    {
        if (minute == m_minute)
            return;

        checkMinute(minute);
        m_minute = minute;
    }

    public int getSecond()
    {
        return m_second;
    }

    public void setSecond(int second)
    {
        if (second == m_second)
            return;

        checkSecond(second);
        m_second = second;
    }

    public int getMillisecond()
    {
        return m_millisecond;
    }

    public void setMillisecond(int millisecond)
    {
        if (millisecond == m_millisecond)
            return;

        checkMillisecond(millisecond);
        m_millisecond = millisecond;
    }

    public String toString()
    {
        return String.format("%s:%02d", toShortTimeString(), m_second);
    }

    public String toShortTimeString()
    {
        return String.format("%02d:%02d", m_hour, m_minute);
    }

    public String toLongTimeString()
    {
        return String.format("%s.%03d", toString(), m_millisecond);
    }
}

/*----------------------------------------------------------------------
	FILE        : DateTimeException.java
	AUTHOR      : Java-Feb-2022 Group
	LAST UPDATE : 07.10.2022

	DateTimeException class

	Copyleft (c) 1993 by C and System Programmers Association (CSD)
	All Rights Free
-----------------------------------------------------------------------*/
package com.orhn.util.datetime;

public class DateTimeException extends RuntimeException {
    public DateTimeException(String message)
    {
        super(message);
    }

    public String getMessage()
    {
        return String.format("For input value:%s", super.getMessage());
    }
}

/*----------------------------------------------------------------------
	FILE        : MutableFraction.java
	AUTHOR      : Java-Feb-2022 Group
	LAST UPDATE : 07.10.2022

	MutableFraction class that represents fraction in mathematics

	Copyleft (c) 1993 by C and System Programmers Association (CSD)
	All Rights Free
-----------------------------------------------------------------------*/
package com.orhn.util.math;

public class MutableFraction {
    private int m_a, m_b;

    private static MutableFraction add(int a1, int b1, int a2, int b2)
    {
        return new MutableFraction(a1 * b2 + a2 * b1, b1 * b2);
    }

    private static MutableFraction subtract(int a1, int b1, int a2, int b2)
    {
        return add(a1, b1, -a2, b2);
    }

    private static MutableFraction multiply(int a1, int b1, int a2, int b2)
    {
        return new MutableFraction(a1 * a2, b1 * b2);
    }

    private static MutableFraction divide(int a1, int b1, int a2, int b2)
    {
        return multiply(a1, b1, b2, a2);
    }

    private static void doWorkForException(String message)
    {
        throw new IllegalArgumentException(message);
    }

    private static void check(int a, int b)
    {
        if (b == 0) {
            if (a == 0)
                doWorkForException("Indeterminate");
            else
                doWorkForException("Undefined");
        }
    }

    private void configureSign()
    {
        if (m_b < 0) {
            m_a = -m_a;
            m_b = -m_b;
        }
    }

    private void simplify()
    {
        int min = Math.min(Math.abs(m_a), m_b);

        for (int i = min; i >= 2; --i)
            if (m_a % i == 0 && m_b % i == 0) {
                m_a /= i;
                m_b /= i;
                break;
            }
    }

    private void set(int a, int b)
    {
        if (a == 0) {
            m_a = 0;
            m_b = 1;
            return;
        }
        m_a = a;
        m_b = b;
        configureSign();
        simplify();
    }

    public MutableFraction()
    {
        m_b = 1;
    }

    public MutableFraction(int a)
    {
        m_a = a;
        m_b = 1;
    }

    public MutableFraction(int a, int b)
    {
        check(a, b);
        set(a, b);
    }

    public int getNumerator()
    {
        return m_a;
    }

    public void setNumerator(int value)
    {
        if (value == m_a)
            return;

        set(value, m_b);
    }

    public int getDenominator()
    {
        return m_b;
    }

    public void setDenominator(int value)
    {
        if (value == m_b)
            return;
        check(m_a, value);
        set(m_a, value);
    }

    public double getRealValue()
    {
        return (double)m_a / m_b;
    }

    public static MutableFraction add(int value, MutableFraction fraction)
    {
        return add(value, 1, fraction.m_a, fraction.m_b);
    }

    public MutableFraction add(MutableFraction other)
    {
        return add(m_a, m_b, other.m_a, other.m_b);
    }

    public MutableFraction add(int value)
    {
        return add(m_a, m_b, value, 1);
    }

    public static MutableFraction subtract(int value, MutableFraction fraction)
    {
        return subtract(value, 1, fraction.m_a, fraction.m_b);
    }

    public MutableFraction subtract(MutableFraction other)
    {
        return subtract(m_a, m_b, other.m_a, other.m_b);
    }

    public MutableFraction subtract(int value)
    {
        return subtract(m_a, m_b, value, 1);
    }

    public static MutableFraction multiply(int value, MutableFraction fraction)
    {
        return multiply(value, 1, fraction.m_a, fraction.m_b);
    }

    public MutableFraction multiply(MutableFraction other)
    {
        return multiply(m_a, m_b, other.m_a, other.m_b);
    }

    public MutableFraction multiply(int value)
    {
        return multiply(m_a, m_b, value, 1);
    }

    public static MutableFraction divide(int value, MutableFraction fraction)
    {
        return divide(value, 1, fraction.m_a, fraction.m_b);
    }

    public MutableFraction divide(MutableFraction other)
    {
        return divide(m_a, m_b, other.m_a, other.m_b);
    }

    public MutableFraction divide(int value)
    {
        return divide(m_a, m_b, value, 1);
    }

    public void inc(int value)
    {
        m_a += m_b * value;
    }

    public void inc()
    {
        inc(1);
    }

    public void dec(int value)
    {
        inc(-value);
    }

    public void dec()
    {
        dec(1);
    }

    public String toString()
    {
        return String.format("%d%s", m_a, m_b == 1 ? "" : " / " + m_b + " = " + getRealValue());
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Arayüzler (Interfaces):
	Bilindiği gibi Java'da sınıf ve enum bildirimi bir tür bildirimidir (user defined types). Java'da interface
	anahtar sözcüğü ile arayüz (interface) bildirimi yapılabilmektedir. Arayüz bildirimi de bir tür bildirimidir.

	Arayüzler daha çok abstract sınıflara benzese de farklı özelliklere de sahiptir

	Anahtar Notlar: interface isimlerini diğer tür bildirimlerinden ayırmak için biz kendi interface'lerimizin isimlerini
	"I" ile başlatacağız. JavaSE içerisindeki arayüzlerde bu kurala uyulmamıştır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	interface bildirimi
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

interface IX {
	//...
}

interface IY {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde veri elemanları bildirilebilir. Bu veri elemanları yazılsa da yazılmasa da public static ve
	final olarak bildirilmiş olur. Biz bildirimlerde bu anahtar sözcükleri yazmayacağız. interface içerisinde final olmayan
	veya public dışında erişim belirleyiciye sahip veya static olmayan bir veri bildirimi yapılamaz. Özellikle Java 5 ile
	birlikte interface içerisinde veri elemanı bildirimi çoğu zaman gerekmemektedir. Bu sebeple sık karşılaşılmaz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		System.out.println(IX.PI);
		IX.PI = 3.15; //error

	}
}

interface IX {
	double PI = 3.14;
}

interface IY {
	int x; //error
}

interface IZ {
	private int x = 20; //error
}

/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde gövdesiz metotlar yazılabilir. Bu metotlar yazılsa da yazılmasa da public ve abstract olarak
	bildirilmiş olur. Yine biz public ve abstract yazmayacağız
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

interface IX {
	void foo();
	int bar(int val);
}
/*----------------------------------------------------------------------------------------------------------------------
	Hiç bir abstract metodu olmayan arayüzlere "işaretleme arayüzleri (marker interfaces)" denir. Genel olarak işaretleme
	arayüzlerinin içerisi tamamen boş bırakılır. Java'da marker interface'ler çok fazla kullanılmamaktadır. Ancak
	kullanılanlar çok önemlidir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

interface IX {  //marker interface

}

interface IY { //marker interface
	double PI = 3.14;
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 8 ile birlikte interface içerisinde gövdeli (abstract olmayan) non-static metotlar yazılabilir. Bu metotlar
	default  anahtar sözcüğü ile bildirilmelidir. Yazılsa da yazılmasa da default metotlar public'dir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

interface IX {
	default void foo() //Since Java 8
	{
	}

	void bar();
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 8 ile birlikte interface içerisinde static metotlar. Şüphesiz static metotlar gövdeli olmalıdır. Bu metotlar da,
	yazılsa da yazılmasa da public'dir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		IX.foo();
	}
}

interface IX {
	static void foo() //Since Java 8
	{
	}

	void bar();
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 8 ile birlikte belirli koşullar altında arayüzler kullanım anlamında genişletilmiştir. Buna göre içerisinde
	bir ve yalnız bir tane abstract metodu olan arayüzler "fonksiyonel arayüzler (fonctional interface)" olarak
	kullanılabilir. Fonksiyonel arayüzler ile Java'da fonksiyonel programlama desteği daha kolay ve gelişmiş biçimde
	yapılabilmektedir.
	Aşağıdaki kodda Java'da fonksiyonel programlama tekniğine ilişkin basit bir örnek verilmiştir. Konunun detayları
	şu an için önemsizdir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	public static void main(String [] args)
	{
		String str = Console.read("Bir yazı giriniz:");
		StringConvertUtil.print(String::length, str);
	}
}

class StringConvertUtil {
	public static void print(IStringToIntFunction function, String str)
	{
		Console.writeLine("%d", function.convert(str));
	}
}

interface IStringToIntFunction {
	int convert(String str);
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 9 ile birlikte arayüzler içerisinde private static ve non-static fonksiyonlar bildirilebilir. Şüphesiz non-static
	metotların gövdeleri yazılmalıdır. Yani abstract olamazlar. private non-static metotlar için default anahtar
	sözcüğü kullanılmaz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

interface IX {
	private void foo() //Since Java 9
	{
		//...
	}

	default void tar()
	{
		foo();
	}

	private static void bar() //Since Java 9
	{
		//...
	}
}



/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde olabilecek elemanlar
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

interface IX {
	int NUM = 30;

	private static void bar() //Since Java 9
	{
		//...
	}

	private void foo() //Since Java 9
	{
		//...
	}

	default void tar() //Since Java 8
	{
		foo();
	}

	void car();
	void zar();
}


/*----------------------------------------------------------------------------------------------------------------------
	interface türünden bir nesne yaratılmaz, prgramcı tarafından da yaratılmaz. interface nesne özelliği olmayan bir
	tür bildirimidir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		IX ix = new IX(); //error
	}
}

interface IX {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	interface bildiriminde abstract anahtar sözcüğü kullanılabilir ancak biz yazmayacağız
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

abstract interface IX {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü implemt anahtar sözcüğü ile destekler (implementation)
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class A implements IX {
	//...
}

interface IX {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü implements anahtar sözcüğü ile destekler (implementation)
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class A implements IX {
	//...
}

interface IX {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf birden fazla arayüzü destekleyebilir. Bu durumda hangi arayüzün listede önce ya da sonra olduğunun
	önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class A implements IX, IY {
	//...
}

interface IX {
	//...
}

interface IY {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf başka bir sınıftan türetilip istediği kadar arayüzü destekleyebilir. Bu durumda extends'in başta olmnası
	gerekir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class A extends B implements IX, IY {
	//...
}

class B {
	//...
}
interface IX {
	//...
}

interface IY {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü destekliyorsa o arayüzün tüm abstract metotlarını override etmelidir. Eğer birini bile
	override etmezse sınıf bildiriminde abstract yazılmalıdır. Yani sınıf abstract olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class C implements IX { //error
	public void foo()
	{
		//...
	}
}

abstract class B implements IX {
	public void foo()
	{
		//...
	}

}

class A implements IX {
	public void foo()
	{
		//...
	}

	public void bar()
	{
		//...
	}
}
interface IX {
	void foo();
	void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
	Arayüz referansları taban sınıf referansı gibi kullanılabilir. Böylelikle "polymorphism" arayüzler ile de
	gerçekleştirilebilmektedir. Yani arayüzler "çoklu türetmeyi (multiple inheritance)" kısmı olarak kullanabilme
	olanağı sağlar
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Util u = new Util();
		Sample s = new Sample();
		Test t = new Test();

		u.doWorkForIX(s);
		u.doWorkForIY(s);
		u.doWorkForIX(t);
	}
}

class Util {
	//...
	public void doWorkForIX(IX ix)
	{
		//...

		ix.foo();
	}


	public void doWorkForIY(IY iy)
	{
		//...

		iy.bar();
	}
}

class Test implements IX {
	public void foo()
	{
		System.out.println("Test.foo");
	}
}

class Sample implements IX, IY {
	public void foo()
	{
		System.out.println("Sample.foo");
	}

	public void bar()
	{
		System.out.println("Sample.bar");
	}
}


interface IX {
	void foo();
}

interface IY {
	void bar();
}


/*----------------------------------------------------------------------------------------------------------------------
	Arayüz referansları taban sınıf referansı gibi kullanılabilir. Böylelikle "polymorphism" arayüzler ile de
	gerçekleştirilebilmektedir. Yani arayüzler "çoklu türetmeyi (multiple inheritance)" kısmı olarak kullanabilme
	olanağı sağlar.

	Aşağıdaki örnekte Test sınıfo IY arayüzünü desteklemediğinde ** ile belirtilen çağrıda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Util u = new Util();
		Sample s = new Sample();
		Test t = new Test();

		u.doWorkForIX(s);
		u.doWorkForIY(s);
		u.doWorkForIX(t);
		u.doWorkForIY(t); //** error

	}
}

class Util {
	//...
	public void doWorkForIX(IX ix)
	{
		//...

		ix.foo();
	}


	public void doWorkForIY(IY iy)
	{
		//...

		iy.bar();
	}
}

class Test implements IX {
	public void foo()
	{
		System.out.println("Test.foo");
	}
}

class Sample implements IX, IY {
	public void foo()
	{
		System.out.println("Sample.foo");
	}

	public void bar()
	{
		System.out.println("Sample.bar");
	}
}


interface IX {
	void foo();
}

interface IY {
	void bar();
}


/*----------------------------------------------------------------------------------------------------------------------
	Birden fazla arayüz içerisinde aynı imzaya ve aynı geri dönüş değerine sahip bir sanal metot varsa ve bir sınıf bu
	arayüzleri destekliyorsa tüm arayüzler için bir tane metot override edilmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Util u = new Util();
		Sample s = new Sample();
		Test t = new Test();

		u.doWorkForIX(s);
		u.doWorkForIY(s);
		u.doWorkForIX(t);
	}
}

class Util {
	//...
	public void doWorkForIX(IX ix)
	{
		//...

		ix.foo();
	}


	public void doWorkForIY(IY iy)
	{
		//...

		iy.foo();
	}
}

class Test implements IX {
	public void foo()
	{
		System.out.println("Test.foo");
	}
}

class Sample implements IX, IY {
	public void foo()
	{
		System.out.println("Sample.foo");
	}
}


interface IX {
	void foo();
}

interface IY {
	void foo();
}



/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü destekliyorsa o sınıftan türetilmiş olan bir sınıf da aynı arayüzü doğrudan destekler. Bu durum
	türemiş sınıfın arayüz listesinde belirtilmek zorunda değildir. İstenirse belirtilebilir

	Örnekte B, C ve D sınıfları açısından foo metodu A'nın metodudur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Util u = new Util();
		A a = new A();
		B b = new B();
		C c = new C();
		D d = new D();

		u.doWorkForIX(a);
		u.doWorkForIX(b);
		u.doWorkForIX(c);
		u.doWorkForIX(d);
	}
}

class Util {
	//...
	public void doWorkForIX(IX ix)
	{
		//...

		ix.foo();
	}
}


class D extends A implements IX {
	//...
}

class C extends A {
	//...
}

class B extends A {
	public void foo()
	{
		System.out.println("B.foo");
	}
}

class A implements IX {
	public void foo()
	{
		System.out.println("A.foo");
	}
}

interface IX {
	void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte foo metodu final olarak override edilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class B extends A implements IX {
	public void foo() //error
	{
		System.out.println("B.foo");
	}
}

class A implements IX {
	public final void foo()
	{
		System.out.println("A.foo");
	}
}

interface IX {
	void foo();
}
/*----------------------------------------------------------------------------------------------------------------------
	Bir arayüz başka bir arayüzden türetilebilir. Burada extends anahtar sözcüğü kullanılır. Bu durumda türemiş arayüzü
	destekleyeb bir sıonıf taban arayüzü de desteklemiş olur yani somut sınıf olabilmek için tüm abstract metotları
	override etmesi gerekir. Aşağıdaki örnekte A sınıfı hem IY'yi hem de IX'i desteklemiş olur. Arayüz listesinde sadece
	IY yazılması yeterli olur. İstenirse IX mde yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Util u = new Util();
		A a = new A();

		u.doWorkForIX(a);
		u.doWorkForIY(a);
	}
}

class Util {
	//...
	public void doWorkForIX(IX ix)
	{
		//...

		ix.foo();
	}

	public void doWorkForIY(IY iy)
	{
		//...

		iy.foo();
		iy.bar();
	}
}


class A implements IY {
	public void foo()
	{
		System.out.println("A.foo");
	}

	public void bar()
	{
		System.out.println("A.bar");
	}
}

interface IY extends IX {
	void bar();
}

interface IX {
	void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Arayüzler arasında "çoklu türetme (multipla inheritance)" yapılabilir. Aşağıdaki örnekte A sınıfı IZ'yi
	desteklediği için ayrıca IX'i ve IY'yi de desteklemiş olur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Util u = new Util();
		A a = new A();

		u.doWorkForIZ(a);
	}
}

class Util {
	//...

	public void doWorkForIZ(IZ iz)
	{
		//...

		iz.foo();
		iz.bar();
		iz.tar();
	}
}


class A implements IZ {
	public void foo()
	{
		System.out.println("A.foo");
	}

	public void bar()
	{
		System.out.println("A.bar");
	}

	public void tar()
	{
		System.out.println("A.tar");
	}
}


interface IZ extends IX, IY {
	void tar();
}

interface IY {
	void bar();
}

interface IX {
	void foo();
}


/*----------------------------------------------------------------------------------------------------------------------
	default metotlar sanaldır. Dolayısyla override edilebilirler. Bu durumda çok biçimli olarak override edilen çağrılır.
	default metotlar gövdeli olduğundan override edilmek zorunda değildir. Aşağıdaki örnekte A sınıfı defaul foo metodunu
	override etmiştir, B sınıfı ise override etmemiştir. Örneği çalıştırarak sonucu gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		Util u = new Util();
		A a = new A();
		B b = new B();

		u.doWorkForIX(a);
		u.doWorkForIX(b);
	}
}

class Util {
	//...

	public void doWorkForIX(IX ix)
	{
		//...

		ix.foo();
	}
}


class B implements IX {
	//...
}

class A implements IX {
	//...
	public void foo()
	{
		System.out.println("A.foo");
	}
}

interface IX {
	//...
	default void foo()
	{
		System.out.println("IX.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	super referansı taban sınıfı temsil ettiğinden aşağıdaki örnekte taban sınıf da Object olduğunda error oluşur. Çünkü
	foo ismi nitelikli kullanılmıştır ve nitelikli isim arama genel kurallarına göre aranır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class A implements IX {
	public void foo()
	{
		System.out.println("A.foo");
		super.foo(); //error: Burada super referansı Object türündendir
	}
}

interface IX {
	default void foo()
	{
		System.out.println("IX.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	(Abstract) sınıflar ile arayüzler arasındaki farklar: (Maddelerin sırasının önemi yoktur)
	- Arayüzler interface anahtar sözcüğü ile abstract sınıfar ise class anahtar sözcüğü ile bildirilir

	- Arayüzler non-static veri elemanlarına sahip olamaz, abstract sınıflar olabilir

	- Arayüzler nesne özelliği göstermediğinden ctor'ları olamaz, abstract sınıfların olabilir

	- Arayüzlerin abstract metotları public ve abstract yazılmasa da bu şekildedir, abstract sınıflarda ise yazılmalıdır

	- Arayüzlere Java 8 ile eklenen gövdeli non-static metotlar default anahtar sözcüğü ile bildirilmelidir, abstract
	sınıflarda doğrudan erişim belirleyici yazılmalıdır

	-  Arayüzlerin veri elemanları yazılsa da yazılmasa da public, static ve final olur, abstract sınıflarda bunlar
	beliritlmeldir

	- Bir sınıf bir arayüzü implements anahtar sözcüğü ile destekler (implementation), abstract sınıftan ise extends
	anahtar sözcüğü ile türetilir. Burada arayüzler için türetme teriminin kullanılmadığına dikkat ediniz

	- Bir sınıf istediği kadar arayüzü destekleyebilir, ancak tek bir sınıftan türetilebilir

	- Arayüzler arasında çoklu türetme yapılabilir, sınıflar arasında geçersizdir

	- Arayüzler türünden nesne hiç bir şekilde yaratıl(a)maz, abstract sınıf türünden nesne türemiş sınıf nesnesi içerisinde
	otomatik olarak yaratılır

	- Bir sınıfın en az bir tane abstract metodu varsa sınıf da abstract olarak bildirilmelidir. Bir arayüz abstract
	olarak bildirilebilse de bildirilmemesiyle aynı anlamdadır

	- Bir arayüzün protected ve no-modifier metotları olamaz, abstract sınıfların olabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Soyut bir türün abstract sınıf mı yoksa arayüz mü yapılacağına nasıl karar verilecektir? Bu durumda şöyle bir
	yol izlenebilir: "Önce interface düşünülmeli, interface özellikleri yazılacak türü karşılamıyprsa (abstract) sınıf
	tercih edilmeldir"

	interface yapılabildiği yerde abstact sınıf yerine yapılması, bu interface'i destekleyen sınıfın başka bir sınıftan
	türetilmesine olanak sağlar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	06.08.2024
	Bazı durumlarda nesne içerisinde bir takım kaynaklar (resources) kullanılıyor olabilir. Bu kaynakların kullanılmaya
	başlanmasına mantıksal olarak "kaynağın açılması" dersek, kaynak kullanımı bittikten sonra bu kaynağın artık
	mantıksal olarak "kapatılması" yani artık serbest bırakılması gerekebilir. Java'da nesneler garbage collector tarafından
	yok edildiğinden kullanılan kaynağı geri bırakmak için nesnenin ölmesi beklenmez. Çünkü örneğin bu kaynak iş bittikten
	sonra başka nesneler tarafından tekrar kullanılmaya başlanabilir. Bu durumda eskiden kullanan nesne ölmezse yeni nesne
	bu kaynağın kullanımına başlayamayabilir. Burada kaynak olarak belirttiğimiz bir dosya, bir cihaza erişim vb. olabilir.
	Böylesi bir durumda Closeable arayüzü kullanılır. Closeable arayüzü abstract close metoduna sahiptir. Anlatılana benzer
	kaynağı kullanan sınıf bu arayüzü destekler ve bu sınıfı kullanan programcı (client) kaynakla işi bittikten sonra
	close metodunu çağırır. Java'da bu arayüzü destekleyen bir sınıf gören programcı yukarıdaki anlatılanları bilir ve
	close metodunu çağırması gerektiğini anlar. Ya da tersine sınıf tasarımında yukarıdaki anlatılanlar gibi kaynak
	kullanımı söz konusuysa ve kapatılması gerekiyorsa sınıf Closeable arayüzünü destekle ve close metodunda kullandığı
	kaynağı geri bırakır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte finally bloğunda çağrılan close metodu metodu try-catch içerisine alınarak checked exception
	fırlatılmasından dolayı oluşan error engellenmiştir. Ancak çoğu zaman (her zaman değil) close metodunun exception
	fırlatması durumu programın ilgileneceği bir şey değildir. Yani açık olan bir kaynağınm close yapılamaması durumunda
	çoğu zaman programcının yapabileceği birşey yoktur. Dolayısıyla aşağıdaki örnekte finally içerisinde try-catch
	kullanılması checked exception probleminden dolayı yapılmıştır. Yani aslında gereksiz bir işlemdir. Örneğimizde
	DeviceConnection demo sınıfının kaynak açıksa, close metodunun kontrol edilmesi gerekliliğini yok varsayınız
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.io.Closeable;
import java.io.IOException;
import java.util.Random;

class App {
	public static void main(String [] args)
	{
		DeviceApp.run();
	}
}


class DeviceApp {
	public static void run()
	{
		DeviceConnection connection = null;

		try {
			connection = new DeviceConnection("https://123.67.87.98:50500/device/weather");
			connection.doWork();
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
		}
		finally {
			try {
				if (connection != null)
					connection.close();
			}
			catch (Exception ex) {
				//...
			}
		}
	}
}

class DeviceConnection implements Closeable {
	private final String m_url;

	public DeviceConnection(String url)
	{
		//...
		m_url= url;
		System.out.printf("Connected: %s%n", m_url);
	}

	public void doWork()
	{
		Random r = new Random();

		//...

		if (r.nextBoolean())
			throw new IllegalStateException("Illegal state");

		System.out.printf("Working on connection at '%s'%n", m_url);
	}

	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kod aşağıdaki gibi daha az karmaşık ve daha okunabilir olarak yazılabilir. Ayrıca bu yaklaşımda close
	metodu için exception işlemesi de yapılabilir. Ancak yukarıdaki yaklaşımda close için yapılacak exception işlemesi
	ayrıca yapılmak zorundadır. Java 7'ye kadar bu tarz durumlar için yaklaşım en yalın aşağıdaki gibi yapılabilmekteydi
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.io.Closeable;
import java.io.IOException;
import java.util.Random;

class App {
	public static void main(String [] args)
	{
		DeviceApp.run();
	}
}

class DeviceApp {
	public static void run()
	{
		DeviceConnection connection = null;

		try {
			DeviceConnectionUtil.doWorkForDeviceConnection("https://123.67.87.98:50500/device/weather");
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
		}
	}
}

class DeviceConnectionUtil {
	public static void doWorkForDeviceConnection(String url) throws IOException
	{
		DeviceConnection connection = null;

		try {
			connection = new DeviceConnection(url);
			connection.doWork();
		}
		finally {
			if (connection != null)
				connection.close();
		}
	}
}
class DeviceConnection implements Closeable {
	private final String m_url;

	public DeviceConnection(String url)
	{
		//...
		m_url= url;
		System.out.printf("Connected: %s%n", m_url);
	}

	public void doWork()
	{
		Random r = new Random();

		//...

		if (r.nextBoolean())
			throw new IllegalStateException("Illegal state");

		System.out.printf("Working on connection at '%s'%n", m_url);
	}

	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte eklenen eklenen "try-with resources (twr)" deyimi ile yukarıdaki problem daha etkin olarak
	ve yalın olarak çözülebilir.twr deyimi ile AutoCloseable arayüzünü destekleyen sınıflar kullanılabilir. twr yukarıdaki
	örnekteki işlemlerin otomatik olarak yapılanı biçiminde düşünülebilir. Closeable arayüzü Java 7 ile birlikte
	AutoCloseable arayüzünden türetilir duruma getirilmiştiri. Bu durumda tüm Closeable sınıflar da aynı zamanda twr
	ile kullanılabilir. Bu deyim ile close metodu otomatik olark çağrılacağından programcının çağırmayı unutması gibi
	bir olasılık da ortadan kaldırılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.io.Closeable;
import java.io.IOException;
import java.util.Random;

class App {
	public static void main(String [] args)
	{
		DeviceApp.run();
	}
}

class DeviceApp {
	public static void run()
	{
		try (DeviceConnection connection = new DeviceConnection("https://123.67.87.98:50500/device/weather")) {
			connection.doWork();
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
		}
	}
}


class DeviceConnection implements Closeable {
	private final String m_url;

	public DeviceConnection(String url)
	{
		//...
		m_url= url;
		System.out.printf("Connected: %s%n", m_url);
	}

	public void doWork()
	{
		Random r = new Random();

		//...

		if (r.nextBoolean())
			throw new IllegalStateException("Illegal state");

		System.out.printf("Working on connection at '%s'%n", m_url);
	}

	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	twr birden fazla sınıf ile de kullanılabilir. Bu durumda close metotları yaratılma sırasının tersinde çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.io.Closeable;
import java.io.IOException;
import java.util.Random;

class App {
	public static void main(String [] args)
	{
		DeviceApp.run();
	}
}

class DeviceApp {
	public static void run()
	{
		try (DeviceConnection connection = new DeviceConnection("https://123.67.87.98:50500/device/weather");
			 Image image = new Image("holiday.jpg")) {
			connection.doWork();
			image.doWork();
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
		}
	}
}


class DeviceConnection implements Closeable {
	private final String m_url;

	public DeviceConnection(String url)
	{
		//...
		m_url= url;
		System.out.printf("Connected: %s%n", m_url);
	}

	public void doWork()
	{
		Random r = new Random();

		//...

		if (r.nextBoolean())
			throw new IllegalStateException("Illegal state");

		System.out.printf("Working on connection at '%s'%n", m_url);
	}

	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}
}

class Image implements Closeable {
	private final String m_filename;

	public Image(String filename)
	{
		m_filename = filename;
		System.out.printf("%s image opened%n", m_filename);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on image:%s%n", m_filename);
	}

	public void close()
	{
		System.out.printf("%s image closed%n", m_filename);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	twr parantezi içerisinde yaratılan nesnelere ilişkin referanslar final kabul edilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.io.Closeable;
import java.io.IOException;
import java.util.Random;

class App {
	public static void main(String [] args)
	{
		DeviceApp.run();
	}
}

class DeviceApp {
	public static void run()
	{
		try (DeviceConnection connection = new DeviceConnection("https://123.67.87.98:50500/device/weather");
			 Image image = new Image("holiday.jpg")) {
			connection.doWork();
			image.doWork();
			connection = new DeviceConnection("test"); //error
			image = new Image("test.png"); //error
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
		}
	}
}


class DeviceConnection implements Closeable {
	private final String m_url;

	public DeviceConnection(String url)
	{
		//...
		m_url= url;
		System.out.printf("Connected: %s%n", m_url);
	}

	public void doWork()
	{
		Random r = new Random();

		//...

		if (r.nextBoolean())
			throw new IllegalStateException("Illegal state");

		System.out.printf("Working on connection at '%s'%n", m_url);
	}

	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}
}

class Image implements Closeable {
	private final String m_filename;

	public Image(String filename)
	{
		m_filename = filename;
		System.out.printf("%s image opened%n", m_filename);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on image:%s%n", m_filename);
	}

	public void close()
	{
		System.out.printf("%s image closed%n", m_filename);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Java 9 ile birlikte twr'den önce yaratılmış olan nesnelere ilişkin referanslar da twr paranetezi içerisinde
	kullanılabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.io.Closeable;
import java.io.IOException;
import java.util.Random;

class App {
	public static void main(String [] args)
	{
		DeviceApp.run();
	}
}

class DeviceApp {
	public static void run()
	{
		DeviceConnection connection = new DeviceConnection("https://123.67.87.98:50500/device/weather");
		Image image = new Image("holiday.jpg");

		Util.doSomething(connection, image);
	}
}

class Util {
	public static void doSomething(DeviceConnection deviceConnection, Image image)
	{
		try (deviceConnection; image) { //Since Java 9
			deviceConnection.doWork();
			image.doWork();
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
		}
	}
}


class DeviceConnection implements Closeable {
	private final String m_url;

	public DeviceConnection(String url)
	{
		//...
		m_url= url;
		System.out.printf("Connected: %s%n", m_url);
	}

	public void doWork()
	{
		Random r = new Random();

		//...

		if (r.nextBoolean())
			throw new IllegalStateException("Illegal state");

		System.out.printf("Working on connection at '%s'%n", m_url);
	}

	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}
}

class Image implements Closeable {
	private final String m_filename;

	public Image(String filename)
	{
		m_filename = filename;
		System.out.printf("%s image opened%n", m_filename);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on image:%s%n", m_filename);
	}

	public void close()
	{
		System.out.printf("%s image closed%n", m_filename);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	twr paranetezi içerisinde kullanılan referanslar da yine final erkisi gösterir (effectively final)
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.io.Closeable;
import java.io.IOException;
import java.util.Random;

class App {
	public static void main(String [] args)
	{
		DeviceApp.run();
	}
}

class DeviceApp {
	public static void run()
	{
		DeviceConnection connection = new DeviceConnection("https://123.67.87.98:50500/device/weather");
		Image image = new Image("holiday.jpg");


		Util.doSomething(connection, image);
	}
}

class Util {
	public static void doSomething(DeviceConnection deviceConnection, Image image)
	{
		try (deviceConnection; image) { //error
			deviceConnection.doWork();
			image.doWork();
			deviceConnection = new DeviceConnection("test.dat");
		}
		catch (Throwable ex) {
			System.out.println(ex.getMessage());
		}
	}
}


class DeviceConnection implements Closeable {
	private final String m_url;

	public DeviceConnection(String url)
	{
		//...
		m_url= url;
		System.out.printf("Connected: %s%n", m_url);
	}

	public void doWork()
	{
		Random r = new Random();

		//...

		if (r.nextBoolean())
			throw new IllegalStateException("Illegal state");

		System.out.printf("Working on connection at '%s'%n", m_url);
	}

	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}
}

class Image implements Closeable {
	private final String m_filename;

	public Image(String filename)
	{
		m_filename = filename;
		System.out.printf("%s image opened%n", m_filename);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on image:%s%n", m_filename);
	}

	public void close()
	{
		System.out.printf("%s image closed%n", m_filename);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	twr bloğu tek başına olabilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.io.Closeable;
import java.io.IOException;
import java.util.Random;

class App {
	public static void main(String [] args)
	{
		DeviceApp.run();
	}
}

class DeviceApp {
	public static void run()
	{
		DeviceConnection connection = new DeviceConnection("https://123.67.87.98:50500/device/weather");
		Image image = new Image("holiday.jpg");


		try {
			Util.doSomething(connection, image);
		}
		catch (IOException ex) {
			//...
		}
	}
}

class Util {
	public static void doSomething(DeviceConnection deviceConnection, Image image) throws IOException
	{
		try (deviceConnection; image) {
			deviceConnection.doWork();
			image.doWork();
		}
	}
}


class DeviceConnection implements Closeable {
	private final String m_url;

	public DeviceConnection(String url)
	{
		//...
		m_url= url;
		System.out.printf("Connected: %s%n", m_url);
	}

	public void doWork()
	{
		Random r = new Random();

		//...

		if (r.nextBoolean())
			throw new IllegalStateException("Illegal state");

		System.out.printf("Working on connection at '%s'%n", m_url);
	}

	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}
}

class Image implements Closeable {
	private final String m_filename;

	public Image(String filename)
	{
		m_filename = filename;
		System.out.printf("%s image opened%n", m_filename);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on image:%s%n", m_filename);
	}

	public void close()
	{
		System.out.printf("%s image closed%n", m_filename);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	twr bloğu tek başına olabilir. Scanner sınıfı Closeable arayüzünü destekler
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		try (Scanner kb = new Scanner(System.in)) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());

			System.out.println(val * val);
		}
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Biri sınıfın ya da arayüzün sanal metodu referansa geri dönen bir metot ise, bu metot override edilirken geri
	dönüş değeri olan referansa ilişkin sınıftan türetilen veya geri dönüş değeri bir arayüz referansı ise o arayüzü
	destekleyen bir sınıf türünden yazılabilir. Buna "covariant return type" denir. Bu kullanım yararlı olsa da Java'da
	pek tercih edilmez. JavaSE'de bulunan bu tarz sınıflar bu yapıyı kullanmazlar
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class Y implements IA {
	public X create()
	{
		X x = new X();

		//...

		return x;
	}
}
class X implements IX {
	//...
}

interface IA {
	IX create();
}

interface IX {
	//...
}
/*----------------------------------------------------------------------------------------------------------------------
	Arayüzlerle İlgili Tür Dönüştürmeleri:
	Bu dönüşümler 4 durum olarak ele alınabilir:
	1. Bir sınıf referansının onun desteklediği bir arayüz referansına dönüştürülmesi
	2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi
	4. Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	1. Bir sınıf referansının onun desteklediği bir arayüz referansına dönüştürülmesi doğrudan yapılabilir. Bu durum çok
	aşikar bir durumdur. Arayüz referansının taban sınıf referansı gibi kullanılmasıdır. Zaten interface'in hedeflerinden
	biri de budur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A a = new A();
		IX ix;

		ix = a;

		//...
	}
}

class A implements IX {
	//...
}

interface IX {
	//...
}
/*----------------------------------------------------------------------------------------------------------------------
	2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi tür dönmüştürülmesi operatörü yapılabilir. Ancak
	çalışmanında arayüz referansının dinamik türünün hedef türü kapsayıp kapsamadığına bakılır. Kapsıyorsa haklı dönüşümdür,
	akış devam eder. Kapsamıyorsa haksız dönüşümdür, ClassCastException nesnesi fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import java.util.Random;

class App {
	public static void main(String [] args)
	{
		RandomFactory factory = new RandomFactory();
		IX ix;

		ix = factory.create();

		System.out.println(ix.getClass().getName());
		A a = (A)ix;

		System.out.println("Tekrar yapıyor musunuz?");

		//...
	}
}

class RandomFactory {
	private final Random m_random = new Random();

	public IX create()
	{
		return m_random.nextBoolean() ? new B() : new C();
	}
}


class C extends A implements IX {
	//...
}

class B implements IX {
	//...
}


class A {
	//...
}

interface IX {
	//...
}
/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilmişse doğrudan yapılabilir

	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilMEmişse tür dönüştürme operatörü
	ile yapılabilir. Bu durumda çalışma zamanında kaynak arayüz referansının dinamik türünün hedef arayüzü destekleyip
	desteklemediğine bakılır. Destekliyorsa haklı dönüşümdür. Desteklemiyorsa haksız dönüşümdür, ClassCastException
	nesnesi fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A a = new A();
		IY iy;
		IX ix;

		iy = a;

		ix = iy; //upcasting

		//...

		B b = new B();

		IZ iz;

		iz = b;

		ix = (IX)iz; //Haklı dönüşüm

		C c = new C();

		iz = c;

		ix = (IX)iz; //Haksız dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");

	}
}


class C implements IZ {
	//...
}

class B implements IX, IZ {
	//...
}

class A implements IY {
	//...
}

interface IZ {
	//...
}

interface IY extends IX {
	//...
}

interface IX {
	//...
}
/*----------------------------------------------------------------------------------------------------------------------
	4. Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi tür dönüştürme operatörü ile
	yapılabilir. Çalışma zamanında kaynak referansın dinamik türünün hedef arayüzü destekleyipş desteklemediğine bakılır.
	Destekliyorsa haklı dönüşümdür. Desteklemiyorsa haksız dönüşümdür, ClassCastException nesnesi fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String [] args)
	{
		A a = new C();
		IX ix;

		ix = (IX)a; //Haklı dönüşüm

		a = new B();

		ix = (IX)a; //Haksız dönüşüm


		System.out.println("Tekrar yapıyor musunuz?");

	}
}

class C extends A implements IX {
	//...
}
class B extends A {
	//...
}

class A {
	//...
}

interface IX {
	//...
}


















