/*-----------------------------------------------------------------------------------------------------------------------
	Programın komut satırı argümanları (command line arguments): Program çalıştırılırken programa geçilen yazılar denir.
	 Bu argümanlar program çalıştırılırken şu şekildeki genel biçimle verilebilir:
		java <program> <arg1> <arg2> ... <argN>
	Burada argümanlar whitespace karakterler ile ayrılar. Eğer whitespace içeren bir yazı verilecekse argüman işletim
	sistemine göre "" veya '' içerisine alınır. Bu durumun bir standardı yoktur. Yani whitespace içeren tek bir argümanın
	verilmesi sisteme göre değişiklik gösterebilmektedir. Java'da programın komut satırı argümanları main metodunun
	parametresi olan String dizisinden elde edilebilir. Yani program çalıştırılırken main metodu komut satırı argümanlarından
	oluşan bir String dizi referansı çağrılır. Eğer hiç komut satırı argümanı geçilmezse length'i sıfır olan bir dizi referansı
	ile çağrılır.
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Program terimi teknik olarak çalışabilir veya çalıştırılabilir dosyaya verilen isimdir. Yani örneğin
	main metodu olan bir byte code veya çalıştırılabilir bir jar dosyası bir programdır. Programın işletim sistemi
	tarafından yüklenip çalıştırılması durumunda buna "process" denir. Java programları için işletim sistemi düzeyinde
	process aslında JVM'dir. JVM byte kodları yorumlayarak makine koduna dönüştürür. Bu işleme JIT compilation dendiğini
	anımsayınız
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	public static void main(String[] args)
	{
		for (String arg : args)
			Console.writeLine(arg);
	}
}

/*-----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;

class App {
	private static char getOperation(String s)
	{
		String ops = "+-x/%";
		int index;

		if (s.length() != 1 || (index = ops.indexOf(s.charAt(0))) == -1)
			throw new IllegalArgumentException();

		return ops.charAt(index);
	}

	private static double calculate(double a, double b, char op)
	{
		return switch (op) {
			case '+' -> a + b;
			case '-' -> a - b;
			case 'x' -> a * b;
			default -> a / b;
		};
	}

	public static void main(String[] args)
	{
		try {
			if (args.length != 3) {
				Console.writeErrLine("usage: java com.orhn.app.App <value1> <operation> <value2>");
				System.exit(1);
			}

			double a = Double.parseDouble(args[0]);
			double b = Double.parseDouble(args[2]);
			char op = getOperation(args[1]);

			Console.writeLine("%f %c %f = %f", a, op, b, calculate(a, b, op));
		}
		catch (NumberFormatException ignore) {
			Console.writeErrLine("Invalid values!...");
		}
		catch (IllegalArgumentException ignore) {
			Console.writeErrLine("Invalid operation!...");
		}
	}
}

/*-----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

import com.orhn.util.console.Console;
import com.orhn.util.console.CommandLineUtil;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;

class App {
	private static char getOperation(String s)
	{
		String ops = "+-x/%";
		int index;

		if (s.length() != 1 || (index = ops.indexOf(s.charAt(0))) == -1)
			throw new IllegalArgumentException();

		return ops.charAt(index);
	}

	private static double calculate(double a, double b, char op)
	{
		return switch (op) {
			case '+' -> a + b;
			case '-' -> a - b;
			case 'x' -> a * b;
			default -> a / b;
		};
	}

	public static void main(String[] args)
	{
		try {
			checkLengthEquals(3, args.length,"usage: java com.orhn.app.App <value1> <operation> <value2>");
			double a = Double.parseDouble(args[0]);
			double b = Double.parseDouble(args[2]);
			char op = getOperation(args[1]);

			Console.writeLine("%f %c %f = %f", a, op, b, calculate(a, b, op));
		}
		catch (NumberFormatException ignore) {
			Console.writeErrLine("Invalid values!...");
		}
		catch (IllegalArgumentException ignore) {
			Console.writeErrLine("Invalid operation!...");
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Temel Dosya İşlemleri: Java'da giriş/çıkış (input/output) işlemleri tarihsel süreç içerisinde çeşitli değişikliklere
    uğramış ve yine pek çok eklenti yapılmıştır. Dosya işlemleri de giriş çıkış işlemleri olduğundan bu tarihsel süreçten
    etkilenmiştir. Burada temel olan ve en çok kısımlar ele alınacaktır. Bu anlamda diğer detaylar "Java ile Uygulama Geliştirme 1 ve 2"
    kurslarında ele alınacaktır.

    İkincil belleklerde (secondary memory) organize edilmiş alanlara dosya (file) denir. Dosyaların isimleri ve özellikleri vardır.
    Dosya işlemleri aslında işletim sistemi tarafından yapılır. İşletim sisteminin dosya işlemleri ile ilgili faaliyetlerinden oluşan
    bölümüne dosya sistemi (file system) denir. Java'nın bu konudaki sınıfları dolaylı olarak işletim sisteminin sistem fonksiyonları
    veya API (Application Programming Interface) fonksiyonlarını çağırmaktadır.

    Bir dosyanın yerini belirten yazısal ifadeye "yol ifadesi (path)" denilmektedir. Windows'ta dizin (directory) geçişleri
    '\' karakteri ile UNIX/Linux ve Mac OS X sistemlerinde '/' ile belirtilir. Windows sistemlerinde ayrıca bir de
    sürücü (drive) kavramı vardır. UNIX/Linux sistemlerinde ve Mac OS X sistemlerinde sürücü kavramı yoktur. Windows
    sistemlerinde her sürücünün ayrı bir kökü ve dizin ağacı (directory tree) vardır. Sürücünün kök dizini onun en dış
    dizinidir.

    Yol ifadeleri mutlak (absolute) ve göreli (relative) olmak üzere ikiye ayrılmaktadır. Eğer sürücü ifadesinden
    sonraki (yol ifadesinde sürücü de belirtilmeyebilir) ilk karakter '\' veya '/' ise böyle yol ifadelerine mutlak,
    değilse göreli yol ifadeleri denilmektedir. Örneğin:

    "c:\a\b\c.dat"	---> mutlak yol ifadesi
    "\x\y\z.txt"	---> mutlak yol ifadesi
    "x\y\z.txt" 	---> göreli
    "x.txt"			---> göreli
    "c:/a/b/c.dat"	---> mutlak yol ifadesi
    "/x/y/z.txt"	---> mutlak yol ifadesi
    "x/y/z.txt" 	---> göreli
    "x.txt"			---> göreli

    Her process'in bir çalışma dizini (current working directory) vardır. Programın çalışma dizini göreli yol ifadelerinin
    çözülmesi (resolve) için orijin belirtir. Örneğin, process'imizin çalışma dizini (cwd) "c:\temp" olsun. Biz bu programda
    "x\y\z.dat" biçiminde bir yol ifadesi kullanırsak toplamda "c:\temp\x\y\z.dat" dosyasını belirtmiş oluruz. Prosesin
    çalışma dizini istenildiği zaman değiştirilebilir. Ancak işin başında genel olarak programın çalıştırıldığı dizindir.
    Örnek Windows işletim sistemi için anlatılmıştır. Benzer şekilde örneğin cwd /tmp dizini ise "x/y/z.dat" biçimindeki
    göreli yol ifadesi toplamda "/tmp/x/y/z.dat" biçiminde olacaktır.

    Mutlak yol ifadeleri kök dizinden itibaren çözülür. Windows sistemlerine özgü olarak eğer yol ifadesinde sürücü
    belirtilmemişse prosesin çalışma dizininin bulunduğu sürücü o mutlak yol ifadesindeki sürücü olarak alınır. Örneğin
    prosesin çalışma dizini "d:\temp" olsun. "\a\b\c.dat" mutlak yol ifadesi d'nin kök dizininden itibaren yol belirtir
    yani örnekteki yol ifadesi "d:\a\b\c.dat" olarak ele alınır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Java'da process'in çalışma dizini System sınıfının getProperty metoduna "user.dir" string sabiti argüman olarak
    geçilerek elde edilebilir. Bununla birlikte process'in çalışma dizinini değiştirmek için System sınıfının setProperty
    metodu yine "user.dir" string sabiti ile kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}


package com.orhn.app;

import com.orhn.util.console.Console;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;

public class Application {
    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");
        Console.writeLine(System.getProperty("user.dir"));
        System.setProperty("user.dir", args[0]);
        Console.writeLine(System.getProperty("user.dir"));
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    Aslında Java'da sisteme yönelik pek çok bilgi de çeşitli property isimleriyle alınabilir. Şüphesiz bunların hepsi
    değiştirilemez. Aşağıda bazı bilgilere ilişkin anahtarlar (key) kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}


package com.orhn.app;

import com.orhn.util.console.Console;

public class Application {
    public static void run(String[] args)
    {
        Console.writeLine(System.getProperty("file.separator") .charAt(0) == '/' ? "Unix-Linux" : "Windows");
        Console.writeLine(System.getProperty("os.arch"));
        Console.writeLine(System.getProperty("os.name"));
        Console.writeLine(System.getProperty("os.version"));
        Console.writeLine(System.getProperty("java.vendor"));
        Console.writeLine(System.getProperty("user.name"));
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Windows’ta dosya ve dizin isimlerinin büyük harf küçük harf duyarlılığı yoktur. Windows dosyanın ismini bizim
	belirttiğimiz gibi saklar. Ancak işleme sokarken büyük harf küçük harf farkını dikkate almaz. Ancak UNIX/Linux
	sistemlerinde (Mac OS X dahil) dosya ve dizin isimlerinin büyük harf küçük harf duyarlılığı vardır.

	Yol ifadelerinde kullanabileceğimiz iki özel dizin ismi vardır. Bunlar “.” ve “..” isimleridir. “.” o anda belirtilen
	dizinin aynısı, “..” ise o anda belirtilen dizinin üst dizini (parent directory) anlamına gelir. Örneğin “a\b\..\c.txt”
	yol ifadesi aslında “a\x.txt” ile eşdeğerdir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Dosya işlemleri sırasında bir çok durum oluşabilir. Örneğin, bir dosya ilgili dizinde bulunamayabilir,
    o anki processin o dosyaya yazma hakkı olmayabilir vs. Bu durumda genel olarak metotlar exception'lar fırlatabilmektedir.
    Programcı bu exceptionlara dikkat etmelidir. Bu exception sınıfları genel olarak IOException veya IOException sınıfından
    türetilmiş olan exception sınıflarıdır. IOException sınıfının checked bir exception sınıfı olduğuna dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Text ve Binary Dosyalar

    Bilgisayar dünyasında içeriklerine göre dosyalar kabaca “text” ve “binary” dosyalar biçiminde ikiye ayrılmaktadır.
    Aslında bu ayrım tamamen mantıksal düzeydedir. Dosyanın içerisinde ne olursa olsun dosyalar byte topluluklarından
    oluşurlar. Dosyaların uzantıları onların içerisinde ne olduğuna yönelik bir ipucu vermek için düşünülmüştür.
    İçerisinde yalnızca yazıların bulunduğu dosyalara “text” dosyalar, içerisinde yazıların dışında başka birtakım
    bilgilerin de bulunduğu dosyalara “binary” dosyalar denilmektedir. Örneğin notepad’te oluşturmuş olduğumuz dosyalar
    tipik text dosyalardır. Halbuki uzantısı “.exe” ve ya “.obj” olan dosyaların içerisinde yazı yoktur. Bunlar tipik
    binary dosyalardır. Uzantısı “.doc” olan veya “.docx” olan dosyalar da aslında “binary” dosyalardır. Her ne kadar bu
    dosyaların içerisinde yazılar varsa da yazıların dışında başka metadata bilgileri de vardır.

    Text ve binary modda açılan dosyalar için Windows ve Unix/Linux (Mac OS X dahil) sistemlerinde farklılıklar
    bulunmaktadır. Bir dosya text modda açılmışsa ve çalışılan sistem windows ise yazma yapan herhangi bir fonksiyon
    Line feed (LF) ('\n') karakterini yazdığında aslında dosyaya Carriage Return (CR)('\r') ve LF karakterlerinin ikisi
    birden yazılır. Benzer şekilde dosyadan okuma yapan fonksiyonlar çalışılan sistem Windows ise ve dosya text modda
    açılmışsa CRLF karakterlerini yanyana gördüğünde yalnızca LF olarak okuma yaparlar. Bu konu ileride detaylandırılacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Java'da dosyalar üzerinde işlem yapan pek çok sınıf vardır. Bu sınıfları iki gruba ayırabiliriz:
    - Dosyanın bütünü üzerinde işlem yapan sınıflar ve metotlar. Örneğin, bir dosyayı silen, kopyalayan, yer değiştiren
    gibi.

    - Dosyanın içerisindeki veriler üzerinde işlem yapan sınıflar ve metotlar. Örneğin, dosyaya yazma yapan, dosyadan
    okuma yapan sınıflar gibi.

    Java'da dosya işlemi yapan sınıflar genel olarak java.io ve java.nio paketlerinde bulunmaktadır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    10.09.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Dosyanın Bütünü Üzerinde İşlem Yapan Sınıflar ve Metotlar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    File Sınıfı
    Bu sınıf bir dosya ya da dizine (directory) ilişkin bütünsel işlemleri yapan sınıftır. File sınıfının kullanılması
    için önce programcı dosya yolunu (path) vererek bir File nesnesi oluşturur. Sınıfın dosyanın bütünü üzerinde işlem
    yapan birçok yararlı metodu bulunmaktadır. File sınıfının ayrıca başka parametreli ctor'ları da bulunmaktadır. File
    sınıfının hemen hemen tüm metotları SecurityException fırlatabilirler. Bu exception özel durumlarda fırlatılır. Bu
    exception'a ilişkin durumlar burada ele alınmayacaktır. Aslında input/output yönelik bir çok metot bu exception'ı
    fırlatır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    File sınıfı türünden nesne yaratıldığında yol ifadesinin geçerli olup olmadığı kontrol edilmez. File sınıfının exists
    metodu verilen yol ifadesine ilişkin dosya ya da dizinin varlığını test etmek amaçlı kullanılabilir. File sınıfının
    isDirectory ve isFile metotları ilgili path'in bir dizin ve dosya belirtip belirtmediğini test etmek
    için kullanılabilir. Bu metotlar yol ifadesinin bulunmaması olması durumunda da false değerine geri dönerler. Bu
    sebeple yol ifadesi geçerliliği gerekirse ayrıca kontrol edilmelidir. İşletim sistemlerinde dosya gibi ele alınan
    ancak ne teknik anlamda dosya ne de teknik anlamda directory olan yapılar da bulunmaktadır. Bunlar sisteme göre
    değişiklik gösterebilmektedir. Aşağıdaki örneği inceleyiniz ve çeşitli işletim sistemlerinde çalıştırarak test ediniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.File;

import static com.orhn.util.console.CommandLineUtil.*;
import static com.orhn.util.console.Console.*;

public class Application {
    private static void printStatus(File f)
    {
        if(f.isDirectory())
            writeLine("Directory");
        else if(f.isFile())
            writeLine("File");
        else
            writeLine("Unknown");
    }

    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            File f = new File(args[0]);

            if(f.exists()){
                printStatus(f);
            } else
                writeLine("No path in system!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının getAbsolutePath isimli metodu ile File sınıfına verilen yol ifadesi mutlak olarak elde edilir. Zaten
    mutlak verilmişse aynısı, mutlak verilmemişse çalışma dizini ile birleştirilmiş hali elde edilir. File sınıfının
    getName isimli metodu ile yol ifadesine ilişkin dosyanın veya dizinin doğrudan ismi elde edilebilir. Benzer şekilde
    getParent isimli metodu ile de dosya ya da dizinin üst dizini (parent) elde edilebilir. geParentFile isimli metodu
    ile üst dizine ilişkin File referansı elde edilebilir. getParent ve getParentFile metotları, içerisinde hiç '/' ve '\'
    olmayan bir yol ifadesi ile yaratılmış File nesnesinden elde ediliyorsa null değere dönerler. Bu durumda en iyi
    yöntem getAbsoluteFile metodu ile mutlak yol ifadesine ilişkin File referansı alınıp getParent veya getParentFile
    çağrılmalıdır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.File;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.writeErrLine;
import static com.orhn.util.console.Console.writeLine;

public class Application {
    private static void printDetails(File f)
    {
        File path = f.getAbsoluteFile();
        writeLine("Absoulute Path:%s", f.getAbsolutePath());
        writeLine("Parent:%s", path.getParent());
    }

    private static void printStatus(File f)
    {
        if(f.isDirectory())
            writeLine("%s is a Directory", f.getName());
        else if(f.isFile())
            writeLine("%s is a File", f.getName());
        else
            writeLine("%s is Unknown", f.getName());

        printDetails(f);
    }

    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            File f = new File(args[0]);

            if(f.exists()){
                printStatus(f);
            } else
                writeLine("%s is invalid!", f.getAbsolutePath());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının delete metodu ilgili yol ifadesinde bulunan dosya ya da dizini silmektedir. Boş olmayan dizinler
    silinemez. Bunun için önce dizinin boşaltılması sonra silinmesi gerekir. File sınıfının delete metodunun geri dönüş
    değeri yol ifadesine ilişkin bilginin silinip silinmediğine belirten boolean türündendir. Bu geri dönüş değerinden
    dosyanın hangi sebepten silinemediği anlaşılamaz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.File;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    private static void delete(File f)
    {
        if(f.delete())
            writeLine("%s deleted", f.getName());
        else
            writeLine("%s can not be deleted", f.getName());
    }

    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            File f = new File(args[0]);

            if(f.exists()){
                delete(f);
            } else
                writeLine("%s not found!", f.getName());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    File nesnesi bir dizin gösteriyorsa bu durumda o dizin içerisindeki dosyalar ve dizinler elde edilebilir. Bir dizin
    içerisindeki dosyaların ve dizinlerin isimleri list metoduyla elde edilebilir. list metodu eğer File nesnesine
    ilişkin yol ifadesi bir dizin değilse veya bir IO problemi oluşursa null değerine geri döner
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.File;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    private static void listContentsForDirectory(File dir)
    {
        String [] files = dir.list();

        if(files != null)
            for (String file : files)
                writeLine(file);
        else
            writeLine("Io error occurred!...");
    }

    private static void listContents(File f) {
        if (f.isDirectory()) {
            listContentsForDirectory(f);
        }
        else
            writeErrLine("%s is not a directory", f.getName());
    }

    public static void run(String[] args) {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            File f = new File(args[0]);

            if (f.exists()) {
                listContents(f);
            } else writeLine("%s not found!", f.getName());
        } catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    File nesnesi bir dizin gösteriyorsa bu durumda o dizin içerisindeki dosyalar ve dizinler elde edilebilir. Bir dizin
    içerisindeki dosyaların ve dizinlerin isimleri list metoduyla elde edilebilir. list metodu eğer File nesnesine
    ilişkin yol ifadesi bir dizin değilse veya bir IO problemi oluşursa null değerine geri döner
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.File;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;


public class Application {
    private static void listContentsForDirectory(File dir)
    {
        String [] files = dir.list();

        if (files != null)
            for (String file : files)
                writeLine(file);
        else
            writeErrLine("IO error occurred!...");
    }

    private static void listContents(File f)
    {
        if (f.isDirectory())
            listContentsForDirectory(f);
        else
            writeErrLine("%s is not a directory", f.getName());
    }

    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            File f = new File(args[0]);

            if (f.exists())
                listContents(f);
            else
                writeLine("'%s' not found", f.getName());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir içerisindeki dosyalara ve dizinlere işlişkin File referanlarından oluşan dizi listFiles metodu ile elde edilebilir.
    listFiles metodu eğer File nesnesine ilişkin yol ifadesi bir dizin değilse veya IO problemi oluşursa null değerine
    geri döner. File sınıfının length metodu ile ilgili dosyanın uzunluğu byte cinsinden elde edilebilir.

    Anahtar Notlar: İşletim sistemlerinde dizinlerin uzunlukları (length) dizine ilişkin bir bilgi olarak tutulmaz. Bu
    durumda dizin ağacı dolaşılarak içerisindeki dosyalardan hesaplanması gerekir. Bu sebeple bir dizine ilişkin File
    nesnesi ile length metodu çağrıldığında sisteme göre farklı değerler elde edilebilir. Yani aslında bu length bilgisinin
    bir dizinin kapladığı alan anlamında doğrudan bir ilişkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.File;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    private static void printFile(File file)
    {
        if(file.isFile())
            writeLine("%s %d", file.getName(), file.length());
        else if (file.isDirectory())
            writeLine("%s <DIR>", file.getName());
        else
            writeLine("%s <Unknown>", file.getName());
    }

    private static void listContentsForDirectory(File dir) {
        File[] files = dir.listFiles();

        if (files != null)
            for (var file : files)
                printFile(file);
        else
            writeErrLine("IO error occurred!...");
    }

    private static void listContents(File f) {
        if (f.isDirectory())
            listContentsForDirectory(f);
        else
            writeErrLine("%s is not a directory", f.getName());
    }

    public static void run(String[] args) {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            File f = new File(args[0]);

            if (f.exists())
                listContents(f);
            else
                writeLine("'%s' not found", f.getName());
        } catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    File sınıfının mkdir metodu verilen yol ifadesine ilişkin bir dizin yaratır. Eğer yol ifadesine ilişkin dizin
    varsa bu durumda hiç birşey yapmaz. Metodun geri dönüş değeri dizinin yaratılıp yaratılmadığını gösteren boolean
    türden değerdir. mkdir metodu yaratılmak istenen dizine ilişkin yol ifadesi geçersizse dizini yaratamaz ve false
    değerine döner.
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.File;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {

    public static void run(String[] args) {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            File f = new File(args[0]);

            if(f.getAbsoluteFile().getParentFile().exists())
                writeLine(f.mkdir() ? "%s created" : "%s exists", f.getName());
            else
                writeLine("Invalid path");

        } catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Verilen yol ifadesine ilişkin tüm dizinlerin yaratılabilmesi için mkdirs metodu kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.File;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            File f = new File(args[0]);

            writeLine(f.mkdirs() ? "%s created" : "%s exists", f.getName());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    12.09.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Dosyanın bütünü üzerinde işlem yapan bazı sınıflar ve arayüzler JavaSE'ye daha sonradan eklenmiştir. Yeni eklenen bu
    sınıflar ve arayüzler genel olarak java.nio paketi içerisinde bulunurlar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Path Arayüzü, Paths ve Files Sınıfları
    Path arayüzü dosya ve dizinler üzerinde daha kolay işlem yapılmasını sağlayan bir arayüzdür. Kullanımı karışık gibi
    gözükse de birçok işlemi kolaylaştırmaktadır. Tipik olarak bir Path referansı elde etmek için Java 11 ile birlikte
    of metodu kullanılabilir. Java 11 öncesinde Path referansı elde etmek için genel olarak Paths isimli sınıfın get
    metotları kullanılıyordu. Ancak bu sınıfın dökümanlarına göre ileride "deprecated" olabileceği söylendiğinden Java 11+
    için bu sınıfın kullanımı tavsiye edilmez. Path arayüzü, Paths sınıfı ve Files sınıfı java.nio.file paketi içerisinde
    bildirilmiştir ve Java 7 ile birlikte eklenmiştir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki basit örnek Java 11 öncesi Path referansı elde edilmesinin Paths sınıfıyla yapılışını göstermektedir. Paths
    sınıfının get metodu formatı geçersiz bir path için InvalidPathException fırlatır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            Path path = Paths.get(args[0]);
            writeLine(path);
        }
        catch (InvalidPathException ignore) {
            writeErrLine("Invalid path");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki basit örnek Java 11+ için Path referansı elde edilmesinin of metodu ile yapılışını göstermektedir. Path
    arayüzünün of metodu formatı geçersiz bir path için InvalidPathException fırlatır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            Path path = Path.of(args[0]);

            writeLine(String.valueOf(path));
        }
        catch (InvalidPathException ignore) {
            writeErrLine("Invalid path");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Bir path'in geçerli veya geçersiz olmasına yönelik formatı işletime sistemine özgüdür, değişiklik
    gösterebilmektedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Files utility sınıfı birçok yararlı static metot barındırır. Aslında File sınıfının da içerisinde bulunan birçok yararlı
    metodu barındırır. Ancak File sınıfında da Files'da da olmayan bazı metotlar vardır. Benzer şekilde Files sınıfında da
    File sınıfında olmayan bazı metotlar vardır. Aslında genel olarak Files sınıfı, File sınıfının birçok işleminin daha
    detaylandırılmış biçimidir. Files sınıfı (aslında bazı metotları anlamında File sınıfı da) yalnızca dosyanın bütünü
    üzerinde işlemler yapan metotlara sahip değildir. Dosyanın verileri üzerinde işlem yapan çeşitli metotları da vardır.
    Dosyanın verileri üzerinde işlem yapan metotlar ileride ele alınacaktır. Files sınıfının bir çok metodu yol ifadesini
    Path arayüzü olarak alırlar. Files sınıfının metotları çeşitli durumlar için çeşitli exception'lar fırlatırlar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfının exists, notExists, isRegularFile, isDirectory gibi metotları vardır. Bu metotların LinkOption parametresi
    optional'dır, geçilmeyebilir. Bu parametrenin anlamı bu kursta ele alınmayacaktır. Files sınıfının delete ve deleteIfExists
    metotları path'e ilişkin dosyayı silerler. delete metodu parametresi ile aldığı path'e ilişkin dosya yoksa NoSuchFileException
    fırlatır. Path bir dizin belirtiyorsa ve boş değilse DirectoryNotEmptyException fırlatır. Herhangi bir IO problemi
    oluşursa IOException fırlatır. deleteIfExists metodu aldığı path'e ilişkin dosya yoksa false, varsa true değerine
    geri döner. Bu metot'da directory için doluysa DirectoryNotEmptyException fırlatır. Herhangi bir IO problemi oluşursa
    IOException fırlatır. Files sınıfının exists ve notExists isimli metotları da vardır. Bu metotların da LinkOption
    parametreleri optional'dır, geçilmeyebilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.IOException;
import java.nio.file.*;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    private static void delete(Path path)
    {
        try {
            Files.delete(path);
            writeLine("%s deleted", path.getFileName());
        }
        catch (NoSuchFileException ignore) {
            writeErrLine("No such file %s", path.getFileName());
        }
        catch (DirectoryNotEmptyException ignore) {
            writeErrLine("Directory not empty:%s", path.getFileName());
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            Path path = Path.of(args[0]);
            delete(path);
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte path'in kontrolü exists metodu ile aşağıdaki gibi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.IOException;
import java.nio.file.*;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    private static void delete(Path path)
    {
        try {
            Files.delete(path);
            writeLine("%s deleted", path.getFileName());
        }
        catch (DirectoryNotEmptyException ignore) {
            writeErrLine("Directory not empty:%s", path.getFileName());
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            Path path = Path.of(args[0]);
            if (Files.exists(path))
                delete(path);
            else
                writeErrLine("No such file %s", path.getFileName());

        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte path'in kontrolü notExists metodu ile aşağıdaki gibi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.IOException;
import java.nio.file.*;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    private static void delete(Path path)
    {
        try {
            Files.delete(path);
            writeLine("%s deleted", path.getFileName());
        }
        catch (DirectoryNotEmptyException ignore) {
            writeErrLine("Directory not empty:%s", path.getFileName());
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            Path path = Path.of(args[0]);

            if (Files.notExists(path))
                writeErrLine("No such file %s", path.getFileName());
            else
                delete(path);
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}}

/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfının copy metotları belirli bir kaynaktan başka bir kaynağa kopyalama yapmak amaçlı kullanılmaktadır. Bu
    metodun bir çok overload'u bulunmaktadır. Path türünden iki argümanla çağrılabilen overload'u birinci parametre ile
    alınan path'in, ikinci parametredeki path'e doğrudan kopyalanmasını sağlar. Bu metot kaynak (source) path ile
    belirtilen dosyayı bulamazsa NoSuchFileException fırlatır. Metot iki argüman ile çağrıldığında, hedef (destination/target)
    path'e ilişkin bir dosya mevcutsa bu durumda FileAlreadyExistsException nesnesini fırlatır. Bu metot hedef Path
    referansına geri döner
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.IOException;
import java.nio.file.*;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    public static void run(String[] args)
    {
        checkLengthEquals(2, args.length, "wrong number of arguments");

        try {
            Path src = Path.of(args[0]);
            Path dest = Path.of(args[1]);

            Files.copy(src, dest);

        }
        catch (NoSuchFileException ex) {
            writeLine("Source file not found!");
        } catch (FileAlreadyExistsException ex) {
            writeLine("Destination already exists. You can not copy!...");
        }
        catch (InvalidPathException ex) {
            writeErrLine("Invalid path: %s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfının aşağıda kullanılan copy metodu CopyOption arayüzü türünden bir referans alır. Bu arayüzü destekleyen
    StandardCopyOption isimli bir enum ile bu argüman verilebilir. REPLACE_EXISTING isimli enum sabiti ile hedef dosya
    varsa bile yenisi ile değiştirilir. REPLACE_EXISTING değeri ile dizin kopyalaması yapıldığında hedef dizin varsa
    ve içi boş değilse DirectoryEmptyException nesnesi fırlatılır. COPY_ATTRIBUTES isimli enum sabiti dosyanın tüm
    özelliklerini hedef dosya için de kopyalar. Bir dosyaya ilişkin attribute'lar sistemden sisteme değişiklik gösterebilmektedir.
    Bir standardı yoktur. ATOMIC_MOVE move metodu ve "multi-threaded" uygulamalara yöneliktir. Burada ele alınmayacaktır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.IOException;
import java.nio.file.*;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    public static void run(String[] args)
    {
        checkLengthEquals(2, args.length, "wrong number of arguments");

        try {
            Path src = Path.of(args[0]);
            Path dest = Path.of(args[1]);

            Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);

        }
        catch (NoSuchFileException ex) {
            writeLine("Source file not found!");
        }
        catch (DirectoryNotEmptyException ex){
            writeLine("Target directory is not empty!...");
        }
        catch (InvalidPathException ex) {
            writeErrLine("Invalid path: %s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfının move metodu kaynak yol ifadesinden hedef yol ifadesine taşıma işlemi yapar. copy metoduna benzer
    şekilde kullanılabilir. move metodu iki argüman ile çağrılırsa exception bakımından copy metodu gibi davranır. Ayrıca
    move metodu "rename" için de kullanılabilir. move metodu COPY_ATTRIBUTES sabitini desteklemez. Bu gesabitin geçilmesi
    durumunda UnsupportedOperationExceoption fırlatılır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.IOException;
import java.nio.file.*;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    public static void run(String[] args)
    {
        checkLengthEquals(2, args.length, "wrong number of arguments");

        try {
            Path src = Path.of(args[0]);
            Path dest = Path.of(args[1]);

            Files.move(src, dest, StandardCopyOption.REPLACE_EXISTING);

        }
        catch (NoSuchFileException ex) {
            writeLine("Source file not found!");
        }
        catch (DirectoryNotEmptyException ex){
            writeLine("Target directory is not empty!...");
        }
        catch (InvalidPathException ex) {
            writeErrLine("Invalid path: %s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.nio.file.*;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class Application {
    public static void run(String[] args)
    {
        checkLengthEquals(2, args.length, "wrong number of arguments");

        try {
            Path src = Path.of(args[0]);
            Path dest = Path.of(args[1]);

            Files.move(src, dest, StandardCopyOption.REPLACE_EXISTING);
        }
        catch (NoSuchFileException ex) {
            writeLine("Source file not found!...");
        }
        catch (DirectoryNotEmptyException ex) {
            writeLine("Target directory is not empty!...");
        }
        catch (InvalidPathException ex) {
            writeErrLine("Invalid path: %s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.io.file.copy.BackupAndCopyApp <src> <dest>
    Program src ile aldığı dosyayı dest ile aldığı dosya olarak kopyalayacaktır. Hedef dosya varsa hedef dosya ismi ve
    uzantısının sonuna "-bak" eklenerek yedeklenecektir. Daha önce yedeklenmişse üzerine yazılacaktır. Bu işlemden sonra
    kopyalama yapılacaktır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app.io.file.copy;

import com.orhn.app.io.file.BackupAndCopy;

import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.nio.file.NoSuchFileException;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.writeErrLine;

public class BackupAndCopyApp {
    private static void run(String [] args)
    {
        checkLengthEquals(2, args.length, "usage: java org.csystem.app.io.file.copy.BackupAndCopyApp <src> <dest>");

        try {
            BackupAndCopy backupAndCopy = new BackupAndCopy(args[0], args[1]);

            backupAndCopy.copy("-bak");
        }
        catch (InvalidPathException ex) {
            writeErrLine("Invalid path:", ex.getInput());
        }
        catch (NoSuchFileException ex) {
            writeErrLine("Source file not found!...");
        }
        catch (IOException ex) {
            writeErrLine("IO problem occurred:%s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}


package com.orhn.app.io.file;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

public class BackupAndCopy {
    private final Path m_src;
    private final Path m_dest;

    private void checkSourceFileIfExists() throws NoSuchFileException
    {
        if(Files.notExists(m_src))
            throw new NoSuchFileException(m_src.toString());
    }

    private void backup(String suffix) throws IOException
    {
        Files.move(m_dest, Path.of(m_dest + suffix), StandardCopyOption.REPLACE_EXISTING);
    }

    public BackupAndCopy(String src, String dest)
    {
        this(Path.of(src), Path.of(dest));
    }

    public BackupAndCopy(Path src, Path dest)
    {
        m_src = src;
        m_dest = dest;
    }

    public void copy(String suffix) throws IOException
    {
        checkSourceFileIfExists();

        if(Files.exists(m_dest))
            backup(suffix);

        Files.copy(m_src, m_dest, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
    }
}

kullanımı :  /usr/lib/jvm/openjdk-22.0.1/bin/java com.orhn.app.io.file.copy.BackupAndCopyApp test jest


/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Yukarıdaki örneği backup yapılan dosya varsa kullanıcıya  aşağıdaki gibi soracak biçime getiriniz:
        Backup file exists. Do you want to overwrite?
    Cevabın Y ve N olmasına göre işlemi yapınız. Burada Y veya N karakteri dışında bir karakter için hiç bir işlem
    yapılmayacaktır. Eğer N girilirse hedef dosya, yedekeleme yapılmadan kopyalanacaktır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.copy;

import com.orhn.app.io.file.BackupAndCopy;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.readChar;
import static com.orhn.util.console.Console.writeErrLine;

public class BackupAndCopyOverwriteBackupApp {
    private static boolean overwrite(String path)
    {
        if (!Files.exists(Path.of(path + "-bak")))
            return true;
        char c;

        while ((c = readChar("Backup file exists. Do you want to overwrite?")) != 'N' && c != 'n' && c != 'Y' && c != 'y')
            ;

        return c == 'Y';
    }

    private static void run(String [] args)
    {
        checkLengthEquals(2, args.length, "usage: java org.csystem.app.io.file.copy.BackupAndCopyApp <src> <dest>");

        try {
            BackupAndCopy backupAndCopy = new BackupAndCopy(Path.of(args[0]), Path.of(args[1]));

            backupAndCopy.copy("-bak", overwrite(args[1]));
        }
        catch (InvalidPathException ex) {
            writeErrLine("Invalid path:", ex.getInput());
        }
        catch (NoSuchFileException ex) {
            writeErrLine("Source file not found!...");
        }
        catch (IOException ex) {
            writeErrLine("IO problem occurred:%s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}


package com.orhn.app.io.file;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

public class BackupAndCopy {
    private final Path m_src;
    private final Path m_dest;

    private void checkSourceFileIfExists() throws NoSuchFileException
    {
        if (Files.notExists(m_src))
            throw new NoSuchFileException(m_src.toString());
    }

    private void backup(String suffix) throws IOException
    {
        Files.move(m_dest, Path.of(m_dest + suffix), StandardCopyOption.REPLACE_EXISTING);
    }

    public BackupAndCopy(String src, String dest)
    {
        this(Path.of(src), Path.of(dest));
    }

    public BackupAndCopy(Path src, Path dest)
    {
        m_src = src;
        m_dest = dest;
    }

    public void copy(String suffix) throws IOException
    {
        copy(suffix, true);
    }

    public void copy(String suffix, boolean overwriteBackupFile) throws IOException
    {
        checkSourceFileIfExists();

        if (Files.exists(m_dest) && overwriteBackupFile)
            backup(suffix);

        Files.copy(m_src, m_dest, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    13.09.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfının createDirectory metodu aldığı Path'e ilişkin dizini yaratmak için kullanılabilir. Bu matodun ikinci
    parametresi dosya özelliklerine (file attributes) ilişkindir. Sistemden sisteme değişiklik gösterebilmektedir. Burada
    ele alınmayacaktır. Metodun ikinci parametresine argüman geçilmediğinde default attribute'lar geçerli olacaktır. Metot
    yaratılmak istenen directory'ye ilişkin path varsa FileAlreadyExistsException fırlatır. İkinci parametreye geçilen
    argüman geçersizse (aslında o sistemde desteklenmiyorsa) UnsupportedOperationException fırlatır. Herhangi bir IO problemi
    durumunda IOException fırlatır. createDirectory metodu yaratılmak istenen dizine ilişkin parent directory'ler yoksa
    yaratmaz. Parent directory'lerin de birlikte yaratılması için createDirectories metodu kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app;

class App {
	public static void main(String[] args)
	{
		Application.run(args);
	}
}

package com.orhn.app;

import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.writeErrLine;
import static com.orhn.util.console.Console.writeLine;

public class Application {
    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try {
            var path = Path.of(args[0]);

            Files.createDirectory(path);
            writeLine("'%s' created", path);
        }
        catch (FileAlreadyExistsException ex) {
            writeErrLine("'%s' already exists", ex.getFile());
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Dosya Verileri Üzerinde İşlem Yapan Sınıflar
    Dosyanın verileri üzerinde işlem yapan sınıflar genel olarak iki kategoriye ayrılmıştır: Dosyaya yazma (output) yapan
    ve dosyadan okuma (input) yapan sınıflar. Aslında Java'da genel olarak tüm giriş çıkış (input/output) işlemleri bu
    şekilde yapılmaktadır.

    InputStream ve OutputStream Sınıfları
    Temel giriş çıkış işlemleri için InputStream ve OutputStream isimli iki adet abstract sınıf bulunmaktadır. Bu sınıflar
    sadece dosyalar için değil, diğer giriş çıkış işlemleri için de kullanılabilmektedir. Yani Java'da "okuma (read) ve yazma (write)"
    ya da daha genel ismiyle "giriş (input) ve çıkış (output)" işlemleri bu sınıflar ile soyutlanmıştır (abstraction). Bu
    sınıflar Closeable arayüzünü desteklerler.

    FileInputStream ve FileOutputStream Sınıfları

    Dosya işlemleri için temel iki sınıf FileInputStream ve FileOutputStream sınıflarıdır. FileOutputStream sınıfı
    OutputStream sınıfından, FileInputStream sınıfı da InputStream sınıfından türetilmiştir. Bu sınıflar Closeable ve
    dolayısıyla AutoCloseable arayüzünü desteklediklerinden “try with resources (twr)” deyimi ile kullanılabilirler. Bir
    dosyanın verileri üzerinde işlem yapılmadan önce o dosyanın açılması gerekir. Dosyanın açılması demek işletim sistemi
    düzeyinde aşağı seviyeli bazı işlemlerin yapılması demektir. Dosyanın açılması işlemi bu sınıfların ctor'ları tarafından
    yapılmaktadır. Kapatılması için de close metodu kullanılmalıdır. Bilindiği gibi Java 7 ile eklenen twr deyimi close
    işlemini otomatik olarak yapmaktadır. Bu sınıflar java.io paketi içerisinde bildirilmişlerdir.

    Dosya Gösterici (file pointer) Kavramı

    Uzantı ne olursa olsun dosyaların içerisinde byte yığınları vardır. Biz de temelde dosyalardan byte okuyup onlara
    byte yazarız. Dosya içerisindeki her bir byte'ın ilk byte 0(sıfır) olmak üzere artan sırada bir pozisyon numarası vardır.
    Buna dosya terminolojisinde ilgili byte’ın offset’i denilmektedir. Dosya göstericisi bir imleç gibi (kalemin ucu gibi)
    düşünülebilir. Dosya göstericisi o anda dosyanın neresinden itibaren okuma ya da yazma yapılacağını anlatan bir
    konum (offset) belirtir:
        x x x x x x x x
        0 1 2 3 4 5 6 7
    Bu örnekte dosya göstericisinin 2 numaralı offset'i gösterdiğini düşünelim. Biz artık 2 byte'lık bir okuma yaparsak
    2 ve 3 numaralı offset'teki byte'ları okuruz. Okuma ve yazma metotları okunan ya da yazılan miktar kadar dosya
    göstericisini otomatik ilerletmektedir. Dosya açıldığında dosya göstericisi özel modlarda açılmamışsa başlangıçta
    0(sıfır)'ıncı offset'tedir. Yazma sırasında dosya göstericisinin gösterdiği yerden itibaren eski bilgiler ezilerek
    yeni bilgiler yazılır. Fakat, özel bir durum olarak dosya göstericisi dosyanın sonundaysa dosyaya yazma yapıldığında
    dosya büyütülmektedir. Başka bir deyişle bu durumda dosyaya yazma işlemi ekleme (append) anlamına gelir.

    Dosya Göstericisinin EOF Durumu

    Dosya göstericisinin dosyanın son byte'ından sonraki byte'ı göstermesi durumuna EOF (End Of File) durumu denir.
    EOF durumundan okuma yapılamaz. Fakat dosya göstericisi EOF durumundayken dosyaya yazma yapılabilir. Bu durum dosyaya
    ekleme anlamına gelir. Dosyaya ekleme yapmanın taşınabilir (portable) başka bir yolu yoktur. Dosya göstericisinin
    dosyanın son byte’ından sonraki byte’ı göstermesi taşınabilir olarak mümkündür. Ancak daha ileride bir yeri taşınabilir
    olarak göstermesi söz konusu değildir.

    Anahtar Notlar: Bazı işletim sistemleri dosyanın sonundan daha ileriye konumlanmaya ve veri yazmaya izin verebilmektedir.
    Bu duruma genel olarak dosya delikleri (file holes) denir. Aşağı seviyede anlamlıdır. Her işletim sistemi
    desteklemeyebileceğinden, Java'da doğrudan yapılamaz. Ayrıca yapılsa bile program taşınabilir olmaz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    FileOutputStream sınıfının File türden ve String türden tek parametreli ctor'ları yeni bir dosya yaratıp dosyayı açar.
    Eğer dosya varsa dosyayı sıfırlayarak (truncate), yani bilgileri kaybederek açar. Yazma işlemi için en temel metot
    bir byte'lık bilgiyi yazan write metodudur. Bu ctor'lar path'in bir dizin belirtmesi durumunda FileNotFoundException
    fırlatır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app.io.file.output;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Random;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class WriteRandomBytesApp {
    private static void writeFile(String path, int count)
    {
        try (FileOutputStream fos = new FileOutputStream(path)) {
            Random random = new Random();

            for (int i = 0; i < count; ++i) {
                byte val = (byte)random.nextInt(-128, 127);

                write("%d ", val);
                fos.write(val);
            }
            writeLine();
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("%s is directory", path);
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s",ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(2, args.length, "wrong number of arguments");

        try {
            int count = Integer.parseInt(args[1]);

            writeFile(args[0], count);
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid count value!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    FileInputStream sınıfının File türden ve String türden ctor'ları varolan bir dosyayı dosya göstericisi başta olacak
    şekilde (yani dosya göstericisi sıfır numaralı offset'i gösterecek şekilde) açar. Eğer dosya yoksa FileNotFoundException
    nesnesi fırlatılır. Okuma işlemi en temel olarak read isimli bir metot ile yapılabilir. read metodu dosya sonuna
    gelindiğinde -1 değerine geri döner. read metodunun başarı durumunda döndürdüğü değerin düşük anlamlı 1 byte'lık
    kısmında bilgi saklanır. Bu durumda programcı başarı durumunda tür dönüştürme operatörü kullanarak değeri elde edebilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.input;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;
import static com.orhn.util.console.Console.writeErrLine;

public class ReadBytesApp {
    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try (FileInputStream fis = new FileInputStream(args[0])) {
            int b;

            while ((b = fis.read()) != -1) {
                byte val = (byte)b;
                write("%d ", val);
            }

            writeLine();
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("%s not found", args[0]);
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s",ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    FileOutputStream sınıfının boolean türden parametresi de olan ctor'ları ile bu parametre true ise dosyanın sonuna
    ekleme yapılabilir. Bu parametrenin false verilmesi tek parametreli ctor'ları ile aynı anlamdadır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.output;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Random;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class AppendRandomBytesApp {
    private static void writeFile(String path, int count)
    {
        try (FileOutputStream fos = new FileOutputStream(path, true)) {
            Random random = new Random();

            for (int i = 0; i < count; ++i) {
                byte val = (byte)random.nextInt(-128, 127);

                write("%d ", val);
                fos.write(val);
            }
            writeLine();
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("%s is directory", path);
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s",ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(2, args.length, "wrong number of arguments");

        try {
            int count = Integer.parseInt(args[1]);

            writeFile(args[0], count);
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid count value!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    FileOutputStream sınıfının byte türden dizi parametreli write metotları ile yazma işlemi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.output;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Random;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class AppendRandomByteArrayApp {
    private static void writeFile(String path, int count)
    {
        try (FileOutputStream fos = new FileOutputStream(path, true)) {
            Random random = new Random();
            byte [] data = new byte[count];

            random.nextBytes(data);
            fos.write(data);

            for (byte val : data)
                write("%d ", val);

            writeLine();
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("%s is directory", path);
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s",ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(2, args.length, "wrong number of arguments");

        try {
            int count = Integer.parseInt(args[1]);

            writeFile(args[0], count);
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid count value!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    FileInputStream sınıfının byte dizi parametreli read metotları byte türden dizinin içerisine dosyadaki bilgileri
    okur. Ne kadar okuduğu miktarı ile de geri döner. Bu durumda programcının ne kadar okunduğu miktarına göre dizinin
    elemanlarını kullanması gerekir. Yani aslında dizinin uzunluğu ya da okumak için verilen sayı en fazla ne kadar
    okunacağını belirtir
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app.io.file.input;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class ReadByteArrayApp {
    private static void writeBytes(byte[] data, int count)
    {
        for (int i = 0; i < count; ++i)
            write("%d ", data[i]);
    }

    private static void readFile(String path, int blockSize)
    {
        try (FileInputStream fis = new FileInputStream(path)) {
            byte [] data = new byte[blockSize];
            int n;

            while ((n = fis.read(data)) > 0)
                writeBytes(data, n);

            writeLine();
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("%s not found", path);
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s",ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(2, args.length, "wrong number of arguments");

        try  {
            readFile(args[0], Integer.parseInt(args[1]));
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid block size value!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    17.09.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    FileInputStream sınıfının skip metodu parametresi ile aldığı n byte'ı atlamak ve sonrasından okuma yapabilmek
    için kullanılır. Bu metodun geri dönüş değeri ne kadar byte'ın atlanabildiği bilgisidir. Bu metoda geçilen atlama
    değeri sonucunda dosyanın sonuna geliniyorsa daha az bir değere geri döner. Yani bu metot en fazla parametresi ile
    aldığı değere geri döner
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.input;

import com.orhn.util.console.Console;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class ReadSkipNBytesApp {
    private static void writeBytes(byte[] data, int count)
    {
        for (int i = 0; i < count; ++i)
            write("%d ", data[i]);
    }

    private static void readFile(String path, int blockSize, int skip)
    {
        try (FileInputStream fis = new FileInputStream(path)) {
            long skipped = fis.skip(skip);

            Console.writeLine("%d bytes skipped", skipped);

            byte [] data = new byte[blockSize];
            int n;

            while ((n = fis.read(data)) > 0)
                writeBytes(data, n);

            writeLine();
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("%s not found", path);
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s",ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(3, args.length, "wrong number of arguments");

        try  {
            readFile(args[0], Integer.parseInt(args[1]), Integer.parseInt(args[2]));
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid block size value!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.io.file.copy.CopyFileViaBlockApp <src> <dest> <block size>
    - Programda Files sınıfı kullanılmayacaktır
    - Program src ile belirtilen yol ifadesine ilişkin dosyayı dest ile belirtilen yol ifadesine ilişkin dosyaya kopyalayacaktır
    - Dosya varsa "truncate" edilecektir
    - Dosya bloklar halinde kopayalanacak ve blok uzunluğu da komut satırı argümanından alınacaktır

    Anahtar Notlar: Files kullanılarak yapılanın daha iyi olduğu söylenebilir. Çünkü işletim sistemine özgü bazı özel
    fonksiyonlar da Files sınıfının metotları içerisinde kullanılır. Şüphesiz uygulamada blok miktarı uygun şekilde
    ayarlanabilir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.copy;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.writeErrLine;
import static com.orhn.util.console.Console.writeLine;

public class CopyFileViaBlockApp {
    private static void copy(String src, String dest, int blockSize)
    {
        try (FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(dest)) {
            byte [] buf = new byte[blockSize];
            int result;

            while ((result = fis.read(buf)) > 0)
                fos.write(buf, 0, result);
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("'%s' not found", src);
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(3, args.length, "usage: java org.csystem.app.io.file.copy.CopyFileViaBlockApp <src> <dest> <block size>");

        try {
            copy(args[0], args[1], Integer.parseInt(args[2]));
            writeLine("File copied successfully");
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid block size format!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnek yazılmış olan IOUtil sınıfı kullanılarak da yapılabilir. Örnekte stream'lerin kapatılması copy
    metodunu çağırana bırakılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.copy;

import com.orhn.app.io.util.IOUtil;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.writeErrLine;
import static com.orhn.util.console.Console.writeLine;

public class CopyFileViaBlockApp {
    private static void copy(String src, String dest, int blockSize)
    {
        try (FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(dest)) {
            IOUtil.copy(fis, fos, blockSize);
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("'%s' not found", src);
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(3, args.length, "usage: java org.csystem.app.io.file.copy.CopyFileViaBlockApp <src> <dest> <block size>");

        try {
            copy(args[0], args[1], Integer.parseInt(args[2]));
            writeLine("File copied successfully");
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid block size format!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}



package com.orhn.app.io.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public final class IOUtil {
    private IOUtil()
    {

    }

    public static void copy(InputStream inputStream, OutputStream outputStream, int blockSize) throws IOException
    {
        byte [] buf = new byte[blockSize];
        int result;

        while((result = inputStream.read(buf)) > 0)
            outputStream.write(buf, 0, result);
    }

    public static void copyAndClose(InputStream inputStream, OutputStream outputStream, int blockSize) throws IOException
    {
        try(inputStream ; outputStream) {
            copy(inputStream, outputStream, blockSize);
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnek yazılmış olan IOUtil sınıfı kullanılarak da yapılabilir. Örnekte stream'lerin kapatılması copyAndClose
    metoduna bırakılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.copy;

import com.orhn.app.io.util.IOUtil;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.writeErrLine;
import static com.orhn.util.console.Console.writeLine;

public class CopyFileViaBlockApp {
    private static void copy(String src, String dest, int blockSize)
    {
        try {
            FileInputStream fis = new FileInputStream(src);
            FileOutputStream fos = new FileOutputStream(dest);

            IOUtil.copy(fis, fos, blockSize);
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("'%s' not found", src);
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(3, args.length, "usage: java org.csystem.app.io.file.copy.CopyFileViaBlockApp <src> <dest> <block size>");

        try {
            copy(args[0], args[1], Integer.parseInt(args[2]));
            writeLine("File copied successfully");
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid block size format!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

package com.orhn.app.io.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public final class IOUtil {
    private IOUtil()
    {

    }

    public static void copy(InputStream inputStream, OutputStream outputStream, int blockSize) throws IOException
    {
        byte [] buf = new byte[blockSize];
        int result;

        while((result = inputStream.read(buf)) > 0)
            outputStream.write(buf, 0, result);
    }

    public static void copyAndClose(InputStream inputStream, OutputStream outputStream, int blockSize) throws IOException
    {
        try(inputStream ; outputStream) {
            copy(inputStream, outputStream, blockSize);
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması:Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.io.file.copy.CopyFileApp <src> <dest>
    Örnek aşağıdaki gibi Files sınıfının copy metodu ile yapılmıştır. Bu metot bir InputStream'den bir dosyaya
    kopyalama yapar. Benzer şekilde bir dosyadan da OutputStream'e kopyalama yapan bir copy metodu da vardır. Burada
    örnek olarak InputStream bir FileInputStream olarak alınmıştır
----------------------------------------------------------------------------------------------------------------------*/


package com.orhn.app.io.file.copy;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.writeErrLine;
import static com.orhn.util.console.Console.writeLine;

public class CopyFileApp {
    public static void run(String[] args)
    {
        checkLengthEquals(2, args.length, "usage: java org.csystem.app.io.file.copy.CopyFileApp <src> <dest>");

        try (FileInputStream fis = new FileInputStream(args[0])) {
            //...
            Files.copy(fis, Path.of(args[1]), StandardCopyOption.REPLACE_EXISTING);
            writeLine("File copied successfully");
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("'%s' not found", args[0]);
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    18.09.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.io.file.copy.CopyExistFilesApp <dest directory> <file path1> <file path2> ... <file pathN>
    Açıklamalar:
        - Program komut satırı argümanları ile aldığı dosyaları, ilk komut satırı argümanı ile aldığı dizine kopyalayacaktır.
        - Olmayan dosyalar için uygun mesajları verecek ve kopyalama işlemine devam edecektir.
        - Program dizinde varolan dosyaların üzerine yazacaktır (overwrite). Üzerine yazdığını uygun bir mesajla bildirecektir.
        - Directory yoksa yaratılacaktır
----------------------------------------------------------------------------------------------------------------------*/



package com.orhn.app.io.file.copy;

import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

import static com.orhn.util.console.CommandLineUtil.checkLengthGreaterOrEqual;
import static com.orhn.util.console.Console.writeErrLine;
import static com.orhn.util.console.Console.writeLine;

public class CopyExistFilesApp {
    private static void copyFiles(Path dest, String [] args) throws IOException
    {
        for (int i = 1; i < args.length; i++) {
            Path path = Path.of(args[i]);

            if (Files.notExists(path)) {
                writeErrLine("'%s' not found", args[i]);
                continue;
            }

            Path destFilePath = dest.resolve(path.getFileName());

            if (Files.exists(destFilePath))
                writeLine("'%s' found and will be overwritten", destFilePath.getFileName());

            Files.copy(path, destFilePath, StandardCopyOption.REPLACE_EXISTING);
            writeLine("'%s' copied successfully", destFilePath.getFileName());
        }
    }

    private static void checkAndCopy(String [] args) throws IOException
    {
        try {
            copyFiles(Files.createDirectories(Path.of(args[0])), args);
        }
        catch (FileAlreadyExistsException ex) {
            writeErrLine("'%s' is not a directory", ex.getFile());
        }
    }

    public static void run(String[] args)
    {
        checkLengthGreaterOrEqual(2, args.length, "usage: java org.csystem.app.io.file.copy.CopyExistFilesApp <dest directory> <file path1> <file path2> ... <file pathN>");

        try {
            checkAndCopy(args);
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.io.file.copy.CopyNotExistFilesApp <dest directory> <file path1> <file path2> ... <file pathN>
    Açıklamalar:
        - Program komut satırı argümanları ile aldığı dosyaları, ilk komut satırı argümanı ile aldığı dizine kopyalayacaktır.
        - Olmayan dosyalar için uygun mesajları verecek ve kopyalama işlemine devam edecektir.
        - Program dizinde varolan dosyalar için ilgili mesajları verecek ve kopyalamayacaktır.
        - Directory yoksa yaratılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.copy;

import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

import static com.orhn.util.console.CommandLineUtil.checkLengthGreaterOrEqual;
import static com.orhn.util.console.Console.writeErrLine;
import static com.orhn.util.console.Console.writeLine;

public class CopyNotExistFilesApp {
    private static void copyFiles(Path dest, String [] args) throws IOException
    {
        for (int i = 1; i < args.length; i++) {
            Path path = Path.of(args[i]);

            if (Files.notExists(path)) {
                writeErrLine("'%s' not found", args[i]);
                continue;
            }

            Path destFilePath = dest.resolve(path.getFileName());

            if (Files.exists(destFilePath)) {
                writeLine("'%s' found and will not be copied", destFilePath.getFileName());
                continue;
            }

            Files.copy(path, destFilePath, StandardCopyOption.REPLACE_EXISTING);
            writeLine("'%s' copied successfully", destFilePath.getFileName());
        }
    }

    private static void checkAndCopy(String [] args) throws IOException
    {
        try {
            copyFiles(Files.createDirectories(Path.of(args[0])), args);
        }
        catch (FileAlreadyExistsException ex) {
            writeErrLine("'%s' is not a directory", ex.getFile());
        }
    }

    public static void run(String[] args)
    {
        checkLengthGreaterOrEqual(2, args.length, "usage: java org.csystem.app.io.file.copy.CopyNotExistFilesApp <dest directory> <file path1> <file path2> ... <file pathN>");

        try {
            checkAndCopy(args);
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Files sınıfının newOutputStream ve newInputStream metotları ile ilgili path'e ilişkin OutputStream ve InputStream
    referansları elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: Komut satırından aşağıdaki gibi çalışan programı yazınız:
        java org.csystem.app.io.file.copy.CopyExistFilesViaOptionApp <dest directory> <file path1> <file path2> ... <file pathN>
    Açıklamalar:
        - Program komut satırı argümanları ile aldığı dosyaları, ilk komut satırı argümanı ile aldığı dizine kopyalayacaktır.
        - Olmayan dosyalar için uygun mesajları verecek ve kopyalama işlemine devam edecektir.
        - Program dizinde varolan dosyalar için aşağıdaki gibi bir menü çıkartacak ve seçime göre uygun işlemi yapacaktır:
            1. Overwrite
            2. Append
            Skip for other options
        - Directory yoksa yaratılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app.io.file.copy;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.*;

import static com.orhn.util.console.CommandLineUtil.checkLengthGreaterOrEqual;
import static com.orhn.util.console.Console.*;

public class CopyExistFilesViaOptionApp {
    private static void displayMenu()
    {
        writeLine("Choose an option:");
        writeLine("1.Overwrite");
        writeLine("2.Append");
        writeLine("Skip for other options");
    }

    private static void overwriteFile(Path path, Path destFilePath) throws IOException
    {
        Files.copy(path, destFilePath, StandardCopyOption.REPLACE_EXISTING);
        writeLine("'%s' copied successfully", destFilePath.getFileName());
    }

    private static void appendFile(Path path, Path destFilePath) throws IOException
    {
        try (OutputStream outputStream = Files.newOutputStream(destFilePath, StandardOpenOption.APPEND)) {
            Files.copy(path, outputStream);
            writeLine("'%s' append successfully", destFilePath.getFileName());
        }
    }

    private static void doOption(int option, Path path, Path destFilePath) throws IOException
    {
        switch (option) {
            case 1 -> overwriteFile(path, destFilePath);
            case 2 -> appendFile(path, destFilePath);
            default -> writeLine("'%s' Skipped!...", path);
        }
    }

    private static void doIfExists(Path path, Path destFilePath) throws IOException
    {
        writeLine("'%s' found:", destFilePath.getFileName());
        displayMenu();
        doOption(readInt("Option:", "Invalid value!..."), path, destFilePath);
    }

    private static void copyFiles(Path dest, String [] args) throws IOException
    {
        for (int i = 1; i < args.length; i++) {
            Path path = Path.of(args[i]);

            if (Files.notExists(path)) {
                writeErrLine("'%s' not found", args[i]);
                continue;
            }

            Path destFilePath = dest.resolve(path.getFileName());

            if (Files.notExists((destFilePath))) {
                Files.copy(path, destFilePath);
                writeLine("'%s' copied successfully", destFilePath.getFileName());
            }
            else
                doIfExists(path, destFilePath);
        }
    }

    private static void checkAndCopy(String [] args) throws IOException
    {
        try {
            copyFiles(Files.createDirectories(Path.of(args[0])), args);
        }
        catch (FileAlreadyExistsException ex) {
            writeErrLine("'%s' is not a directory", ex.getFile());
        }
    }

    public static void run(String[] args)
    {
        checkLengthGreaterOrEqual(2, args.length, "usage: java org.csystem.app.io.file.copy.CopyExistFilesViaOptionApp <dest directory> <file path1> <file path2> ... <file pathN>");

        try {
            checkAndCopy(args);
        }
        catch (IOException ex) {
            writeErrLine("IO Problem occurred:%s", ex.getMessage());
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    22.09.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Değerleri Byte Dizisine Dönüştürüp Geri Almak

    Madem ki stream tabanlı dosya işlemlerinde bir dosyaya biz write metoduyla bir byte dizisi yazabiliyoruz o halde bir
    bilgiyi dosyaya yazmadan önce onu byte dizisine dönüştürmemiz gerekir. Benzer biçimde dosyadan okuduklarımız da
    aslında bir byte dizisinin içerisine yerleştiriliyor, o halde byte dizisinin içerisine okunan bilgileri de yeniden
    ilgili türe dönüştürmemiz gerekir. Java'da temel bir türü byte türden diziye dönüştürmek ve byte türden bir diziyi
    ilgili temel türe dönüştürmek için tipik olarak ByteBuffer sınıfı kullanılabilir.

    Anahtar Notlar: ByteBuffer sınıfı burada anlatılan işlemlerin dışında da kullanılabilen oldukça yetenekli bir sınıftır.
    Burada tamamı ele alınmayacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ByteBuffer sınıfı kullanılarak int türden veriler byte dizisine çevrilip dosyaya eklenmiştir
----------------------------------------------------------------------------------------------------------------------*/
package com.orhn.app.io.file.output;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Random;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class AppendRandomIntsApp {
    private static void writeFile(String path, int count, int min, int bound)
    {
        try (FileOutputStream fos = new FileOutputStream(path, true)) {
            Random random = new Random();

            for (int i = 0; i < count; ++i) {
                int val = random.nextInt(min, bound);

                write("%d ", val);
                byte [] buf = ByteBuffer.allocate(Integer.BYTES).putInt(val).array();

                fos.write(buf);
            }

            writeLine();
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("%s is directory", path);
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s",ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(4, args.length, "wrong number of arguments");

        try {
            int count = Integer.parseInt(args[1]);
            int min = Integer.parseInt(args[2]);
            int bound = Integer.parseInt(args[3]);

            writeFile(args[0], count, min, bound);
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid count value!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ByteBuffer sınıfı kullanılarak veriler byte dizisi olarak okunup int türüne çevrilmiştir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.input;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.ByteBuffer;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class ReadIntsApp {
    private static void readFile(String path)
    {
        try (FileInputStream fis = new FileInputStream(path)) {
            byte [] data = new byte[Integer.BYTES];
            int n;

            while ((n = fis.read(data)) > 0) {
                if (n != Integer.BYTES)
                    throw new IOException("Invalid file format!...");

                int val = ByteBuffer.wrap(data).getInt();

                write("%d ", val);
            }

            writeLine();
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("%s not found", path);
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s",ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(1, args.length, "wrong number of arguments");

        try  {
            readFile(args[0]);
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid block size value!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ByteBuffer sınıfı kullanılarak double türden veriler byte dizisine çevrilip dosyaya eklenmiştir
----------------------------------------------------------------------------------------------------------------------*/

package com.orhn.app.io.file.output;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Random;

import static com.orhn.util.console.CommandLineUtil.checkLengthEquals;
import static com.orhn.util.console.Console.*;

public class AppendRandomDoublesApp {
    private static void writeFile(String path, int count, double min, double bound)
    {
        try (FileOutputStream fos = new FileOutputStream(path, true)) {
            Random random = new Random();

            for (int i = 0; i < count; ++i) {
                double val = random.nextDouble(min, bound);

                write("%f ", val);
                byte [] buf = ByteBuffer.allocate(Double.BYTES).putDouble(val).array();

                fos.write(buf);
            }

            writeLine();
        }
        catch (FileNotFoundException ignore) {
            writeErrLine("%s is directory", path);
        }
        catch (IOException ex) {
            writeErrLine("IO error occurred:%s",ex.getMessage());
        }
    }

    public static void run(String[] args)
    {
        checkLengthEquals(4, args.length, "wrong number of arguments");

        try {
            int count = Integer.parseInt(args[1]);
            double min = Double.parseDouble(args[2]);
            double bound = Double.parseDouble(args[3]);

            writeFile(args[0], count, min, bound);
        }
        catch (NumberFormatException ignore) {
            writeErrLine("Invalid count value!...");
        }
        catch (Throwable ex) {
            writeErrLine("Problem occurred:%s", ex.getMessage());
        }
    }

    public static void main(String[] args)
    {
        run(args);
    }
}



























































